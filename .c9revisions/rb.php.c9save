{"ts":1352500152485,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1352500187016,"patch":[[{"diffs":[[1,"<?php /*\r\n\r\n                   .______.\r\n_______   ____   __| _/\\_ |__   ____ _____    ____\r\n\\_  __ \\_/ __ \\ / __ |  | __ \\_/ __ \\\\__  \\  /    \\\r\n |  | \\/\\  ___// /_/ |  | \\_\\ \\  ___/ / __ \\|   |  \\\r\n |__|    \\___  >____ |  |___  /\\___  >____  /___|  /\r\n             \\/     \\/      \\/     \\/     \\/     \\/\r\n\r\n\r\n\r\nRedBean Database Objects -\r\nWritten by Gabor de Mooij (c) copyright 2009-2012\r\n\r\nRedBean is DUAL Licensed BSD and GPLv2. You may choose the license that fits\r\nbest for your project.\r\n\r\n\r\n/**\r\n * Interface for database drivers\r\n *\r\n * @file    \t\tRedBean/Driver.php\r\n * @description\t\tDescribes the API for database classes\r\n *\t\t\t\t\tThe Driver API conforms to the ADODB pseudo standard\r\n *\t\t\t\t\tfor database drivers.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\ninterface RedBean_Driver {\r\n\t/**\r\n\t * Runs a query and fetches results as a multi dimensional array.\r\n\t *\r\n\t * @param  string $sql SQL to be executed\r\n\t *\r\n\t * @return array $results result\r\n\t */\r\n\tpublic function GetAll( $sql, $aValues=array() );\r\n\r\n\t/**\r\n\t * Runs a query and fetches results as a column.\r\n\t *\r\n\t * @param  string $sql SQL Code to execute\r\n\t *\r\n\t * @return array\t$results Resultset\r\n\t */\r\n\tpublic function GetCol( $sql, $aValues=array() );\r\n\r\n\t/**\r\n\t * Runs a query an returns results as a single cell.\r\n\t *\r\n\t * @param string $sql SQL to execute\r\n\t *\r\n\t * @return mixed $cellvalue result cell\r\n\t */\r\n\tpublic function GetCell( $sql, $aValues=array() );\r\n\r\n\t/**\r\n\t * Runs a query and returns a flat array containing the values of\r\n\t * one row.\r\n\t *\r\n\t * @param string $sql SQL to execute\r\n\t *\r\n\t * @return array $row result row\r\n\t */\r\n\tpublic function GetRow( $sql, $aValues=array() );\r\n\r\n\t/**\r\n\t * Executes SQL code and allows key-value binding.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL. This method has no return value.\r\n\t *\r\n\t * @param string $sql\t  SQL Code to execute\r\n\t * @param array  $aValues Values to bind to SQL query\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function Execute( $sql, $aValues=array() );\r\n\r\n\t/**\r\n\t * Escapes a string for use in SQL using the currently selected\r\n\t * driver driver.\r\n\t *\r\n\t * @param string $string string to be escaped\r\n\t *\r\n\t * @return string $string escaped string\r\n\t */\r\n\tpublic function Escape( $str );\r\n\r\n\t/**\r\n\t * Returns the latest insert ID if driver does support this\r\n\t * feature.\r\n\t *\r\n\t * @return integer $id primary key ID\r\n\t */\r\n\tpublic function GetInsertID();\r\n\r\n\r\n\t/**\r\n\t * Returns the number of rows affected by the most recent query\r\n\t * if the currently selected driver driver supports this feature.\r\n\t *\r\n\t * @return integer $numOfRows number of rows affected\r\n\t */\r\n\tpublic function Affected_Rows();\r\n\r\n\t/**\r\n\t * Toggles debug mode. In debug mode the driver will print all\r\n\t * SQL to the screen together with some information about the\r\n\t * results. All SQL code that passes through the driver will be\r\n\t * passes on to the screen for inspection.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @param boolean $trueFalse turn on/off\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function setDebugMode( $tf );\r\n\r\n\t/**\r\n\t * Starts a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function CommitTrans();\r\n\r\n\t/**\r\n\t * Commits a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function StartTrans();\r\n\r\n\t/**\r\n\t * Rolls back a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function FailTrans();\r\n}\r\n\r\n\r\n/**\r\n * PDO Driver\r\n * @file\t\t\tRedBean/PDO.php\r\n * @description\t\tPDO Driver\r\n *\t\t\t\t\tThis Driver implements the RedBean Driver API\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community, Desfrenes\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright Desfrenes & Gabor de Mooij and the RedBeanPHP community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\nclass RedBean_Driver_PDO implements RedBean_Driver {\r\n\r\n\t/**\r\n\t * Contains database DSN for connecting to database.\r\n\t * @var string\r\n\t */\r\n\tprotected $dsn;\r\n\r\n\t/**\r\n\t * Whether we are in debugging mode or not.\r\n\t * @var boolean\r\n\t */\r\n\tprotected $debug = false;\r\n\r\n\t/**\r\n\t * Holds an instance of Logger implementation.\r\n\t * @var RedBean_Logger\r\n\t */\r\n\tprotected $logger = NULL;\r\n\r\n\t/**\r\n\t * Holds the PDO instance.\r\n\t * @var PDO\r\n\t */\r\n\tprotected $pdo;\r\n\r\n\t/**\r\n\t * Holds integer number of affected rows from latest query\r\n\t * if driver supports this feature.\r\n\t * @var integer\r\n\t */\r\n\tprotected $affected_rows;\r\n\r\n\t/**\r\n\t * Holds result resource.\r\n\t * @var integer\r\n\t */\r\n\tprotected $rs;\r\n\r\n\r\n\t/**\r\n\t * Contains arbitrary connection data.\r\n\t * @var array\r\n\t */\r\n\tprotected $connectInfo = array();\r\n\r\n\r\n\t/**\r\n\t * Whether you want to use classic String Only binding -\r\n\t * backward compatibility.\r\n\t * @var bool\r\n\t */\r\n\tpublic $flagUseStringOnlyBinding = false;\r\n\r\n\t/**\r\n\t * Whether we are currently connected or not.\r\n\t * This flag is being used to delay the connection until necessary.\r\n\t * Delaying connections is a good practice to speed up scripts that\r\n\t * don't need database connectivity but for some reason want to\r\n\t * init RedbeanPHP.\r\n\t * @var boolean\r\n\t */\r\n\tprotected $isConnected = false;\r\n\r\n\t/**\r\n\t * Constructor. You may either specify dsn, user and password or\r\n\t * just give an existing PDO connection.\r\n\t * Examples:\r\n\t *    $driver = new RedBean_Driver_PDO($dsn, $user, $password);\r\n\t *    $driver = new RedBean_Driver_PDO($existingConnection);\r\n\t *\r\n\t * @param string|PDO  $dsn\tdatabase connection string\r\n\t * @param string      $user optional, usename to sign in \r\n\t * @param string      $pass optional, password for connection login\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function __construct($dsn, $user = null, $pass = null) {\r\n\t\tif ($dsn instanceof PDO) {\r\n\t\t\t$this->pdo = $dsn;\r\n\t\t\t$this->isConnected = true;\r\n\t\t\t$this->pdo->setAttribute(1002, 'SET NAMES utf8');\r\n\t\t\t$this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\r\n\t\t\t$this->pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);\r\n\t\t\t// make sure that the dsn at least contains the type\r\n\t\t\t$this->dsn = $this->getDatabaseType();\r\n\t\t} else {\r\n\t\t\t$this->dsn = $dsn;\r\n\t\t\t$this->connectInfo = array( 'pass'=>$pass, 'user'=>$user );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Establishes a connection to the database using PHP PDO\r\n\t * functionality. If a connection has already been established this\r\n\t * method will simply return directly. This method also turns on\r\n\t * UTF8 for the database and PDO-ERRMODE-EXCEPTION as well as\r\n\t * PDO-FETCH-ASSOC.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function connect() {\r\n\t\tif ($this->isConnected) return;\r\n\t\t$user = $this->connectInfo['user'];\r\n\t\t$pass = $this->connectInfo['pass'];\r\n\t\t//PDO::MYSQL_ATTR_INIT_COMMAND\r\n\t\t$this->pdo = new PDO(\r\n\t\t\t\t  $this->dsn,\r\n\t\t\t\t  $user,\r\n\t\t\t\t  $pass,\r\n\t\t\t\t  array(1002 => 'SET NAMES utf8',\r\n\t\t\t\t\t\t\t PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,\r\n\t\t\t\t\t\t\t PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,\r\n\r\n\t\t\t\t  )\r\n\t\t);\r\n\t\t$this->pdo->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);\r\n\t\t$this->isConnected = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Binds parameters. This method binds parameters to a PDOStatement for\r\n\t * Query Execution. This method binds parameters as NULL, INTEGER or STRING\r\n\t * and supports both named keys and question mark keys.\r\n\t *\r\n\t * @param  PDOStatement $s       PDO Statement instance\r\n\t * @param  array        $aValues values that need to get bound to the statement\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tprotected function bindParams($s,$aValues) {\r\n\t\tforeach($aValues as $key=>&$value) {\r\n\t\t\tif (is_integer($key)) {\r\n\r\n\t\t\t\tif (is_null($value)){\r\n\t\t\t\t\t$s->bindValue($key+1,null,PDO::PARAM_NULL);\r\n\t\t\t\t}\r\n\t\t\t\telseif (!$this->flagUseStringOnlyBinding && RedBean_QueryWriter_AQueryWriter::canBeTreatedAsInt($value) && $value < 2147483648) {\r\n\t\t\t\t\t$s->bindParam($key+1,$value,PDO::PARAM_INT);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t$s->bindParam($key+1,$value,PDO::PARAM_STR);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (is_null($value)){\r\n\t\t\t\t\t$s->bindValue($key,null,PDO::PARAM_NULL);\r\n\t\t\t\t}\r\n\t\t\t\telseif (!$this->flagUseStringOnlyBinding && RedBean_QueryWriter_AQueryWriter::canBeTreatedAsInt($value) &&  $value < 2147483648) {\r\n\t\t\t\t\t$s->bindParam($key,$value,PDO::PARAM_INT);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t$s->bindParam($key,$value,PDO::PARAM_STR);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Runs a query. Internal function, available for subclasses. This method\r\n\t * runs the actual SQL query and binds a list of parameters to the query.\r\n\t * slots. The result of the query will be stored in the protected property\r\n\t * $rs (always array). The number of rows affected (result of rowcount, if supported by database)\r\n\t * is stored in protected property $affected_rows. If the debug flag is set\r\n\t * this function will send debugging output to screen buffer.\r\n\t * \r\n\t * @throws RedBean_Exception_SQL \r\n\t * \r\n\t * @param string $sql     the SQL string to be send to database server\r\n\t * @param array  $aValues the values that need to get bound to the query slots\r\n\t */\r\n\tprotected function runQuery($sql,$aValues) {\r\n\t\t$this->connect();\r\n\t\tif ($this->debug && $this->logger) {\r\n\t\t\t$this->logger->log($sql, $aValues);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tif (strpos('pgsql',$this->dsn)===0) {\r\n\t\t\t\t$s = $this->pdo->prepare($sql, array(PDO::PGSQL_ATTR_DISABLE_NATIVE_PREPARED_STATEMENT => true));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$s = $this->pdo->prepare($sql);\r\n\t\t\t}\r\n\t\t\t$this->bindParams( $s, $aValues );\r\n\t\t\t$s->execute();\r\n\t\t\t$this->affected_rows = $s->rowCount();\r\n\t\t\tif ($s->columnCount()) {\r\n\t\t    \t$this->rs = $s->fetchAll();\r\n\t\t    \tif ($this->debug && $this->logger) $this->logger->log('resultset: ' . count($this->rs) . ' rows');\r\n\t    \t}\r\n\t\t  \telse {\r\n\t\t    \t$this->rs = array();\r\n\t\t  \t}\r\n\t\t}catch(PDOException $e) {\r\n\t\t\t//Unfortunately the code field is supposed to be int by default (php)\r\n\t\t\t//So we need a property to convey the SQL State code.\r\n\t\t\t$err = $e->getMessage();\r\n\t\t\tif ($this->debug && $this->logger) $this->logger->log('An error occurred: '.$err);\r\n            $x = new RedBean_Exception_SQL( $err, 0);\r\n      \t\t$x->setSQLState( $e->getCode() );\r\n\t\t\tthrow $x;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Runs a query and fetches results as a multi dimensional array.\r\n\t *\r\n\t * @param  string $sql SQL to be executed\r\n\t *\r\n\t * @return array $results result\r\n\t */\r\n\tpublic function GetAll( $sql, $aValues=array() ) {\r\n\t\t$this->runQuery($sql,$aValues);\r\n\t\treturn $this->rs;\r\n\t}\r\n\r\n\t /**\r\n\t * Runs a query and fetches results as a column.\r\n\t *\r\n\t * @param  string $sql SQL Code to execute\r\n\t *\r\n\t * @return array\t$results Resultset\r\n\t */\r\n\tpublic function GetCol($sql, $aValues=array()) {\r\n\t\t$rows = $this->GetAll($sql,$aValues);\r\n\t\t$cols = array();\r\n\t\tif ($rows && is_array($rows) && count($rows)>0) {\r\n\t\t\tforeach ($rows as $row) {\r\n\t\t\t\t$cols[] = array_shift($row);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $cols;\r\n\t}\r\n\r\n\t/**\r\n\t * Runs a query an returns results as a single cell.\r\n\t *\r\n\t * @param string $sql SQL to execute\r\n\t *\r\n\t * @return mixed $cellvalue result cell\r\n\t */\r\n\tpublic function GetCell($sql, $aValues=array()) {\r\n\t\t$arr = $this->GetAll($sql,$aValues);\r\n\t\t$row1 = array_shift($arr);\r\n\t\t$col1 = array_shift($row1);\r\n\t\treturn $col1;\r\n\t}\r\n\r\n\t/**\r\n\t * Runs a query and returns a flat array containing the values of\r\n\t * one row.\r\n\t *\r\n\t * @param string $sql SQL to execute\r\n\t *\r\n\t * @return array $row result row\r\n\t */\r\n\tpublic function GetRow($sql, $aValues=array()) {\r\n\t\t$arr = $this->GetAll($sql, $aValues);\r\n\t\treturn array_shift($arr);\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Executes SQL code and allows key-value binding.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL. This method has no return value.\r\n\t *\r\n\t * @param string $sql\t  SQL Code to execute\r\n\t * @param array  $aValues Values to bind to SQL query\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function Execute( $sql, $aValues=array() ) {\r\n\t\t$this->runQuery($sql,$aValues);\r\n\t\treturn $this->affected_rows;\r\n\t}\r\n\r\n\t/**\r\n\t * Escapes a string for use in SQL using the currently selected\r\n\t * PDO driver.\r\n\t *\r\n\t * @param string $string string to be escaped\r\n\t *\r\n\t * @return string $string escaped string\r\n\t */\r\n\tpublic function Escape( $str ) {\r\n\t\t$this->connect();\r\n\t\treturn substr(substr($this->pdo->quote($str), 1), 0, -1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the latest insert ID if driver does support this\r\n\t * feature.\r\n\t *\r\n\t * @return integer $id primary key ID\r\n\t */\r\n\tpublic function GetInsertID() {\r\n\t\t$this->connect();\r\n\t\treturn (int) $this->pdo->lastInsertId();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of rows affected by the most recent query\r\n\t * if the currently selected PDO driver supports this feature.\r\n\t *\r\n\t * @return integer $numOfRows number of rows affected\r\n\t */\r\n\tpublic function Affected_Rows() {\r\n\t\t$this->connect();\r\n\t\treturn (int) $this->affected_rows;\r\n\t}\r\n\r\n\t/**\r\n\t * Toggles debug mode. In debug mode the driver will print all\r\n\t * SQL to the screen together with some information about the\r\n\t * results. All SQL code that passes through the driver will be\r\n\t * passes on to the screen for inspection.\r\n\t * This method has no return value.\r\n\t *\r\n\t * Additionally you can inject RedBean_Logger implementation\r\n\t * where you can define your own log() method\r\n\t *\r\n\t * @param boolean $trueFalse turn on/off\r\n\t * @param RedBean_Logger $logger \r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function setDebugMode( $tf, $logger = NULL ) {\r\n\t\t$this->connect();\r\n\t\t$this->debug = (bool)$tf;\r\n\t\tif ($this->debug and !$logger) $logger = new RedBean_Logger_Default();\r\n\t\t$this->setLogger($logger);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Injects RedBean_Logger object.\r\n\t *\r\n\t * @param RedBean_Logger $logger\r\n\t */\r\n\tpublic function setLogger( RedBean_Logger $logger ) {\r\n\t\t$this->logger = $logger;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets RedBean_Logger object.\r\n\t *\r\n\t * @return RedBean_Logger\r\n\t */\r\n\tpublic function getLogger() {\r\n\t\treturn $this->logger;\r\n\t}\r\n\r\n\t/**\r\n\t * Starts a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function StartTrans() {\r\n\t\t$this->connect();\r\n\t\t$this->pdo->beginTransaction();\r\n\t}\r\n\r\n\t/**\r\n\t * Commits a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function CommitTrans() {\r\n\t\t$this->connect();\r\n\t\t$this->pdo->commit();\r\n\t}\r\n\r\n\t/**\r\n\t * Rolls back a transaction.\r\n\t * This method is part of the transaction mechanism of\r\n\t * RedBeanPHP. All queries in a transaction are executed together.\r\n\t * In case of an error all commands will be rolled back so none of the\r\n\t * SQL in the transaction will affect the DB. Using transactions is\r\n\t * considered best practice.\r\n\t * This method has no return value.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function FailTrans() {\r\n\t\t$this->connect();\r\n\t\t$this->pdo->rollback();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the name of the database type/brand: i.e. mysql, db2 etc.\r\n\t *\r\n\t * @return string $typeName database identification\r\n\t */\r\n\tpublic function getDatabaseType() {\r\n\t\t$this->connect();\r\n\t\treturn $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the version number of the database.\r\n\t *\r\n\t * @return mixed $version version number of the database\r\n\t */\r\n\tpublic function getDatabaseVersion() {\r\n\t\t$this->connect();\r\n\t\treturn $this->pdo->getAttribute(PDO::ATTR_CLIENT_VERSION);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the underlying PHP PDO instance.\r\n\t *\r\n\t * @return PDO $pdo PDO instance used by PDO wrapper\r\n\t */\r\n\tpublic function getPDO() {\r\n\t\t$this->connect();\r\n\t\treturn $this->pdo;\r\n\t}\r\n\r\n\t/**\r\n\t * Closes database connection by destructing PDO.\r\n\t */\r\n\tpublic function close() {\r\n\t\t$this->pdo = null;\r\n\t\t$this->isConnected = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns TRUE if the current PDO instance is connected.\r\n\t * \r\n\t * @return boolean $yesNO \r\n\t */\r\n\tpublic function isConnected() {\r\n\t\tif (!$this->isConnected && !$this->pdo) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * RedBean_OODBBean (Object Oriented DataBase Bean)\r\n * \r\n * @file \t\t\tRedBean/RedBean_OODBBean.php\r\n * @description\t\tThe Bean class used for passing information\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_OODBBean implements IteratorAggregate, ArrayAccess, Countable {\r\n\r\n\r\n\t/**\r\n\t * By default own-lists and shared-lists no longer have IDs as keys (3.3+),\r\n\t * this is because exportAll also does not offer this feature and we want the\r\n\t * ORM to be more consistent. Also, exporting without keys makes it easier to\r\n\t * export lists to Javascript because unlike in PHP in JS arrays will fill up gaps.\r\n\t * \r\n\t * @var boolean  \r\n\t */\r\n\tprivate static $flagKeyedExport = false;\r\n\r\n    /**\r\n     * Reference to NULL property for magic getter.\r\n     * @var Null $null\r\n     */\r\n    private $null = null;\r\n\r\n\r\n\t/**\r\n\t * Properties of the bean. These are kept in a private\r\n\t * array called properties and exposed through the array interface.\r\n\t * @var array $properties\r\n\t */\r\n\tprivate $properties = array();\r\n\r\n\t/**\r\n\t * Meta Data storage. This is the internal property where all\r\n\t * Meta information gets stored.\r\n\t * @var array\r\n\t */\r\n\tprivate $__info = NULL;\r\n\r\n\t/**\r\n\t * Contains a BeanHelper to access service objects like\r\n\t * te association manager and OODB.\r\n\t * @var RedBean_BeanHelper\r\n\t */\r\n\tprivate $beanHelper = NULL;\r\n\r\n\t/**\r\n\t * Contains the latest Fetch Type.\r\n\t * A Fetch Type is a preferred type for the next nested bean.\r\n\t * @var null\r\n\t */\r\n\tprivate $fetchType = NULL;\r\n\r\n\t/**\r\n\t * Used store store SQL snippet for use with with()\r\n\t * method.\r\n\t * \r\n\t * @var string \r\n\t */\r\n\tprivate $withSql = '';\r\n\r\n\t/**\r\n\t * Alias name for a type.\r\n\t * \r\n\t * @var string \r\n\t */\r\n\tprivate $aliasName = NULL;\r\n\r\n\t/**\r\n\t * By default own-lists and shared-lists no longer have IDs as keys (3.3+),\r\n\t * this is because exportAll also does not offer this feature and we want the\r\n\t * ORM to be more consistent. Also, exporting without keys makes it easier to\r\n\t * export lists to Javascript because unlike in PHP in JS arrays will fill up gaps.\r\n\t * \r\n\t * @var boolean $yesNo \r\n\t */\r\n\tpublic static function setFlagKeyedExport($flag) {\r\n\t\tself::$flagKeyedExport = (boolean) $flag;\r\n\t}\r\n\r\n\t/** Returns the alias for a type\r\n\t *\r\n\t * @param  $type aliased type\r\n\t *\r\n\t * @return string $type type\r\n\t */\r\n\tprivate function getAlias( $type ) {\r\n\t\tif ($this->fetchType) {\r\n\t\t\t$type = $this->fetchType;\r\n\t\t\t$this->fetchType = null;\r\n\t\t}\r\n\t\treturn $type;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the Bean Helper. Normally the Bean Helper is set by OODB.\r\n\t * Here you can change the Bean Helper. The Bean Helper is an object\r\n\t * providing access to a toolbox for the bean necessary to retrieve\r\n\t * nested beans (bean lists: ownBean,sharedBean) without the need to\r\n\t * rely on static calls to the facade (or make this class dep. on OODB).\r\n\t *\r\n\t * @param RedBean_IBeanHelper $helper\r\n\t * @return void\r\n\t */\r\n\tpublic function setBeanHelper(RedBean_BeanHelper $helper) {\r\n\t\t$this->beanHelper = $helper;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns an ArrayIterator so you can treat the bean like\r\n\t * an array with the properties container as its contents.\r\n\t *\r\n\t * @return ArrayIterator $arrayIt an array iterator instance with $properties\r\n\t */\r\n\tpublic function getIterator() {\r\n\t\treturn new ArrayIterator($this->properties);\r\n\t}\r\n\r\n\t/**\r\n\t * Imports all values in associative array $array. Every key is used\r\n\t * for a property and every value will be assigned to the property\r\n\t * identified by the key. So basically this method converts the\r\n\t * associative array to a bean by loading the array. You can filter\r\n\t * the values using the $selection parameter. If $selection is boolean\r\n\t * false, no filtering will be applied. If $selection is an array\r\n\t * only the properties specified (as values) in the $selection\r\n\t * array will be taken into account. To skip a property, omit it from\r\n\t * the $selection array. Also, instead of providing an array you may\r\n\t * pass a comma separated list of property names. This method is\r\n\t * chainable because it returns its own object.\r\n\t * Imports data into bean\r\n\t *\r\n\t * @param array        $array     what you want to import\r\n\t * @param string|array $selection selection of values\r\n\t * @param boolean      $notrim    if TRUE values will not be trimmed\r\n\t *\r\n\t *    @return RedBean_OODBBean $this\r\n\t */\r\n\tpublic function import( $arr, $selection=false, $notrim=false ) {\r\n\t\tif (is_string($selection)) $selection = explode(',',$selection);\r\n\t\t//trim whitespaces\r\n\t\tif (!$notrim && is_array($selection)) foreach($selection as $k=>$s){ $selection[$k]=trim($s); }\r\n\t\tforeach($arr as $k=>$v) {\r\n\t\t\tif ($k!='__info') {\r\n\t\t\t\tif (!$selection || ($selection && in_array($k,$selection))) {\r\n\t\t\t\t\t$this->$k = $v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Injects the properties of another bean but keeps the original ID.\r\n\t * Just like import() but keeps the original ID.\r\n\t * Chainable.\r\n\t * \r\n\t * @param RedBean_OODBBean $otherBean the bean whose properties you would like to copy\r\n\t * \r\n\t * @return RedBean_OODBBean $self\r\n\t */\r\n\tpublic function inject(RedBean_OODBBean $otherBean) {\r\n\t\t$myID = $this->id;\r\n\t\t$array = $otherBean->export();\r\n\t\t$this->import($array);\r\n\t\t$this->id = $myID;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Very superficial export function\r\n\t * @return array $properties \r\n\t */\r\n\tpublic function getProperties() {\r\n\t\treturn $this->properties;\r\n\t}\r\n\r\n\t/**\r\n\t * Exports the bean as an array.\r\n\t * This function exports the contents of a bean to an array and returns\r\n\t * the resulting array. If $meta eq uals boolean TRUE, then the array will\r\n\t * also contain the __info section containing the meta data inside the\r\n\t * RedBean_OODBBean Bean object.\r\n\t * @param boolean $meta\r\n\t * @return array $arr\r\n\t */\r\n\tpublic function export($meta = false, $parents = false, $onlyMe = false, $filters = array()) {\r\n\t\t$arr=array();\r\n\t\tif ($parents) {\r\n\t\t\tforeach($this as $k=>$v) {\r\n\t\t\t\tif (substr($k,-3)=='_id') {\r\n\t\t\t\t\t$prop = substr($k,0,strlen($k)-3);\r\n\t\t\t\t\t$this->$prop;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tforeach($this as $k=>$v) {\r\n\t\t\tif (!$onlyMe && is_array($v)) {\r\n\t\t\t\t$vn = array();\r\n\t\t\t\tforeach($v as $i=>$b) {\r\n                    if(!is_object($b)) continue; // not exporting array fields\r\n\t\t\t\t\tif (is_numeric($i) && !self::$flagKeyedExport) {\r\n\t\t\t\t\t\t$vn[]=$b->export($meta,false,false,$filters);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t$vn[$i]=$b->export($meta,false,false,$filters);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$v = $vn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telseif ($v instanceof RedBean_OODBBean) {\r\n\t\t\t\tif (count($filters) && !in_array(strtolower($v->getMeta('type')),$filters)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t$v = $v->export($meta,$parents,false,$filters);\r\n\t\t\t}\r\n\t\t\t$arr[$k] = $v;\r\n\t\t}\r\n\t\tif ($meta) $arr['__info'] = $this->__info;\r\n\t\treturn $arr;\r\n\t}\r\n\r\n\t/**\r\n\t * Exports the bean to an object.\r\n\t * This function exports the contents of a bean to an object.\r\n\t * @param object $obj\r\n\t * @return array $arr\r\n\t */\r\n\tpublic function exportToObj($obj) {\r\n\t\tforeach($this->properties as $k=>$v) {\r\n\t\t\tif (!is_array($v) && !is_object($v))\r\n\t\t\t$obj->$k = $v;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Implements isset() function for use as an array.\r\n\t * Returns whether bean has an element with key\r\n\t * named $property. Returns TRUE if such an element exists\r\n\t * and FALSE otherwise.\r\n\t * @param string $property\r\n\t * @return boolean $hasProperty\r\n\t */\r\n\tpublic function __isset($property) {\r\n\t\treturn (isset($this->properties[$property]));\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Returns the ID of the bean no matter what the ID field is.\r\n\t *\r\n\t * @return string $id record Identifier for bean\r\n\t */\r\n\tpublic function getID() {\r\n\t\treturn (string) $this->id;\r\n\t}\r\n\r\n\t/**\r\n\t * Unsets a property. This method will load the property first using\r\n\t * __get.\r\n\t *\r\n\t * @param  string $property property\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function __unset($property) {\r\n\t\t$this->__get($property);\r\n\t\t$fieldLink = $property.'_id';\r\n\t\tif (isset($this->$fieldLink)) {\r\n\t\t\t//wanna unset a bean reference?\r\n\t\t\t$this->$fieldLink = null;\r\n\t\t}\r\n\t\tif ((isset($this->properties[$property]))) {\r\n\t\t\tunset($this->properties[$property]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a property from the properties list without invoking\r\n\t * an __unset on the bean.\r\n\t *\r\n\t * @param  string $property property that needs to be unset\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function removeProperty( $property ) {\r\n\t\tunset($this->properties[$property]);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds WHERE clause conditions to ownList retrieval.\r\n\t * For instance to get the pages that belong to a book you would\r\n\t * issue the following command: $book->ownPage\r\n\t * However, to order these pages by number use:\r\n\t * \r\n\t * $book->with(' ORDER BY `number` ASC ')->ownPage\r\n\t * \r\n\t * the additional SQL snippet will be merged into the final\r\n\t * query.\r\n\t * \r\n\t * @param string $sql SQL to be added to retrieval query.\r\n\t * \r\n\t * @return RedBean_OODBBean $self\r\n\t */\r\n\tpublic function with($sql) {\r\n\t\t$this->withSql = $sql;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Just like with(). Except that this method prepends the SQL query snippet \r\n\t * with AND which makes it slightly more comfortable to use a conditional\r\n\t * SQL snippet. For instance to filter an own-list with pages (belonging to\r\n\t * a book) on specific chapters you can use:\r\n\t * \r\n\t * $book->withCondition(' chapter = 3 ')->ownPage\r\n\t * \r\n\t * This will return in the own list only the pages having 'chapter == 3'. \r\n\t * \r\n\t * @param string $sql SQL to be added to retrieval query (prefixed by AND)\r\n\t * \r\n\t * @return RedBean_OODBBean $self\r\n\t */\r\n\tpublic function withCondition($sql) {\r\n\t\t$this->withSql = ' AND '.$sql;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Prepares an own-list to use an alias. This is best explained using\r\n\t * an example. Imagine a project and a person. The project always involves\r\n\t * two persons: a teacher and a student. The person beans have been aliased in this\r\n\t * case, so to the project has a teacher_id pointing to a person, and a student_id\r\n\t * also pointing to a person. Given a project, we obtain the teacher like this:\r\n\t * \r\n\t * $project->fetchAs('person')->teacher;\r\n\t * \r\n\t * Now, if we want all projects of a teacher we cant say:\r\n\t * \r\n\t * $teacher->ownProject\r\n\t * \r\n\t * because the $teacher is a bean of type 'person' and no project has been\r\n\t * assigned to a person. Instead we use the alias() method like this:\r\n\t * \r\n\t * $teacher->alias('teacher')->ownProject\r\n\t * \r\n\t * now we get the projects associated with the person bean aliased as\r\n\t * a teacher.\r\n\t * \r\n\t * @param string $aliasName the alias name to use\r\n\t * \r\n\t * @return RedBean_OODBBean \r\n\t */\r\n\tpublic function alias($aliasName) {\r\n\t\t$this->aliasName = $aliasName;\r\n\t\treturn $this;\r\n\t}\t\r\n\r\n\t/**\r\n\t * Magic Getter. Gets the value for a specific property in the bean.\r\n\t * If the property does not exist this getter will make sure no error\r\n\t * occurs. This is because RedBean allows you to query (probe) for\r\n\t * properties. If the property can not be found this method will\r\n\t * return NULL instead.\r\n\t * @param string $property\r\n\t * @return mixed $value\r\n\t */\r\n\tpublic function &__get( $property ) {\r\n\t\tif ($this->beanHelper)\r\n\t\t$toolbox = $this->beanHelper->getToolbox();\r\n\t\tif ($this->withSql!=='') {\r\n\t\t\tif (strpos($property,'own')===0) {\r\n\t\t\t\tunset($this->properties[$property]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!isset($this->properties[$property])) { \r\n\t\t\t$fieldLink = $property.'_id'; \r\n\t\t\t/**\r\n\t\t\t * All this magic can be become very complex quicly. For instance,\r\n\t\t\t * my PHP CLI produced a segfault while testing this code. Turns out that\r\n\t\t\t * if fieldlink equals idfield, scripts tend to recusrively load beans and\r\n\t\t\t * instead of giving a clue they simply crash and burn isnt that nice?\r\n\t\t\t */\r\n\t\t\tif (isset($this->$fieldLink) && $fieldLink != $this->getMeta('sys.idfield')) {\r\n\t\t\t\t$this->setMeta('tainted',true); \r\n\t\t\t\t$type =  $this->getAlias($property);\r\n\t\t\t\t$targetType = $this->properties[$fieldLink];\r\n\t\t\t\t$bean =  $toolbox->getRedBean()->load($type,$targetType);\r\n\t\t\t\t//return $bean;\r\n\t\t\t\t$this->properties[$property] = $bean;\r\n\t\t\t\treturn $this->properties[$property];\r\n\t\t\t}\r\n\t\t\tif (strpos($property,'own')===0) {\r\n\t\t\t\t$firstCharCode = ord(substr($property,3,1));\r\n\t\t\t\tif ($firstCharCode>=65 && $firstCharCode<=90) {\r\n\t\t\t\t\t$type = (__lcfirst(str_replace('own','',$property)));\r\n\t\t\t\t\tif ($this->aliasName) {\r\n\t\t\t\t\t\t$myFieldLink = $this->aliasName.'_id';\r\n\t\t\t\t\t\t$this->setMeta('sys.alias.'.$type,$this->aliasName);\r\n\t\t\t\t\t\t$this->aliasName = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t$myFieldLink =  $this->getMeta('type').'_id';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$beans = $toolbox->getRedBean()->find($type,array(),array(\" $myFieldLink = ? \".$this->withSql,array($this->getID())));\r\n\t\t\t\t\t$this->withSql = '';\r\n\t\t\t\t\t$this->properties[$property] = $beans;\r\n\t\t\t\t\t$this->setMeta('sys.shadow.'.$property,$beans);\r\n\t\t\t\t\t$this->setMeta('tainted',true);\r\n\t\t\t\t\treturn $this->properties[$property];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (strpos($property,'shared')===0) {\r\n\t\t\t\t$firstCharCode = ord(substr($property,6,1));\r\n\t\t\t\tif ($firstCharCode>=65 && $firstCharCode<=90) {\r\n\t\t\t\t\t$type = (__lcfirst(str_replace('shared','',$property)));\r\n\t\t\t\t\t$keys = $toolbox->getRedBean()->getAssociationManager()->related($this,$type);\r\n\t\t\t\t\tif (!count($keys)) $beans = array(); else\r\n\t\t\t\t\t$beans = $toolbox->getRedBean()->batch($type,$keys);\r\n\t\t\t\t\t$this->properties[$property] = $beans;\r\n\t\t\t\t\t$this->setMeta('sys.shadow.'.$property,$beans);\r\n\t\t\t\t\t$this->setMeta('tainted',true);\r\n\t\t\t\t\treturn $this->properties[$property];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $this->null;\r\n\t\t}\r\n\t\treturn $this->properties[$property];\r\n\t}\r\n\r\n\t/**\r\n\t * Magic Setter. Sets the value for a specific property.\r\n\t * This setter acts as a hook for OODB to mark beans as tainted.\r\n\t * The tainted meta property can be retrieved using getMeta(\"tainted\").\r\n\t * The tainted meta property indicates whether a bean has been modified and\r\n\t * can be used in various caching mechanisms.\r\n\t * @param string $property\r\n\t * @param  mixed $value\r\n\t */\r\n\r\n\tpublic function __set($property,$value) {\r\n\t\t$this->__get($property);\r\n\t\t$this->setMeta('tainted',true);\r\n\t\t$linkField = $property.'_id';\r\n\t\tif (isset($this->properties[$linkField]) && !($value instanceof RedBean_OODBBean)) {\r\n\t\t\tif (is_null($value) || $value === false) {\r\n\t\t\t\treturn $this->__unset($property);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow new RedBean_Exception_Security('Cannot cast to bean.');\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($value===false) {\r\n\t\t\t$value = '0';\r\n\t\t}\r\n\t\telseif ($value===true) {\r\n\t\t\t$value = '1';\r\n\t\t}\r\n\t\telseif ($value instanceof DateTime) {\r\n\t\t\t$value = $value->format('Y-m-d H:i:s');\r\n\t\t}\r\n\t\t$this->properties[$property] = $value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a property directly, for internal use only.\r\n\t * \r\n\t * @param string $property property\r\n\t * @param mixed  $value    value\r\n\t */\r\n\tpublic function setProperty($property,$value) {\r\n\t\t$this->properties[$property] = $value;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the value of a meta property. A meta property\r\n\t * contains extra information about the bean object that will not\r\n\t * get stored in the database. Meta information is used to instruct\r\n\t * RedBean as well as other systems how to deal with the bean.\r\n\t * For instance: $bean->setMeta(\"buildcommand.unique\", array(\r\n\t * array(\"column1\", \"column2\", \"column3\") ) );\r\n\t * Will add a UNIQUE constaint for the bean on columns: column1, column2 and\r\n     * column 3.\r\n\t * To access a Meta property we use a dot separated notation.\r\n\t * If the property cannot be found this getter will return NULL instead.\r\n\t * @param string $path\r\n\t * @param mixed $default\r\n\t * @return mixed $value\r\n\t */\r\n\tpublic function getMeta($path,$default = NULL) {\r\n\t\treturn (isset($this->__info[$path])) ? $this->__info[$path] : $default;\r\n\t}\r\n\r\n\t/**\r\n\t * Stores a value in the specified Meta information property. $value contains\r\n\t * the value you want to store in the Meta section of the bean and $path\r\n\t * specifies the dot separated path to the property. For instance \"my.meta.property\".\r\n\t * If \"my\" and \"meta\" do not exist they will be created automatically.\r\n\t * @param string $path\r\n\t * @param mixed $value\r\n\t */\r\n\tpublic function setMeta($path,$value) {\r\n\t\t$this->__info[$path] = $value;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the meta information of the specified bean\r\n\t * This is a convenience method to enable you to\r\n\t * exchange meta information easily.\r\n\t * @param RedBean_OODBBean $bean\r\n\t * @return RedBean_OODBBean\r\n\t */\r\n\tpublic function copyMetaFrom(RedBean_OODBBean $bean) {\r\n\t\t$this->__info = $bean->__info;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Reroutes a call to Model if exists. (new fuse)\r\n\t * @param string $method\r\n\t * @param array $args\r\n\t * @return mixed $mixed\r\n\t */\r\n\tpublic function __call($method, $args) {\r\n\t\tif (!isset($this->__info['model'])) {\r\n\t\t\t$model = $this->beanHelper->getModelForBean($this);\r\n\t\t\tif (!$model) return;\r\n\t\t\t$this->__info['model'] = $model;\r\n\t\t}\r\n\t\tif (!method_exists($this->__info['model'],$method)) return null;\r\n\t\treturn call_user_func_array(array($this->__info['model'],$method), $args);\r\n\t}\r\n\r\n\t/**\r\n\t * Implementation of __toString Method\r\n\t * Routes call to Model.\r\n\t * @return string $string\r\n\t */\r\n\tpublic function __toString() {\r\n\t\t$string = $this->__call('__toString',array());\r\n\t\tif ($string === null) {\r\n\t\t\treturn json_encode($this->properties);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn $string;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Implementation of Array Access Interface, you can access bean objects\r\n\t * like an array.\r\n\t * Call gets routed to __set.\r\n\t *\r\n\t * @param  mixed $offset offset string\r\n\t * @param  mixed $value value\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function offsetSet($offset, $value) {\r\n        $this->__set($offset, $value);\r\n    }\r\n\r\n\t/**\r\n\t * Implementation of Array Access Interface, you can access bean objects\r\n\t * like an array.\r\n\t *\r\n\t * @param  mixed $offset property\r\n\t *\r\n\t * @return\r\n\t */\r\n    public function offsetExists($offset) {\r\n        return isset($this->properties[$offset]);\r\n    }\r\n\r\n\t/**\r\n\t * Implementation of Array Access Interface, you can access bean objects\r\n\t * like an array.\r\n\t * Unsets a value from the array/bean.\r\n\t *\r\n\t * @param  mixed $offset property\r\n\t *\r\n\t * @return\r\n\t */\r\n    public function offsetUnset($offset) {\r\n        unset($this->properties[$offset]);\r\n    }\r\n\r\n\t/**\r\n\t * Implementation of Array Access Interface, you can access bean objects\r\n\t * like an array.\r\n\t * Returns value of a property.\r\n\t *\r\n\t * @param  mixed $offset property\r\n\t *\r\n\t * @return\r\n\t */\r\n    public function offsetGet($offset) {\r\n        return $this->__get($offset);\r\n    }\r\n\r\n\t/**\r\n\t * Chainable method to cast a certain ID to a bean; for instance:\r\n\t * $person = $club->fetchAs('person')->member;\r\n\t * This will load a bean of type person using member_id as ID.\r\n\t *\r\n\t * @param  string $type preferred fetch type\r\n\t *\r\n\t * @return RedBean_OODBBean\r\n\t */\r\n\tpublic function fetchAs($type) {\r\n\t\t$this->fetchType = $type;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Implementation of Countable interface. Makes it possible to use\r\n\t * count() function on a bean.\r\n\t * \r\n\t * @return integer $numberOfProperties number of properties in the bean. \r\n\t */\r\n\tpublic function count() {\r\n\t\treturn count($this->properties);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks wether a bean is empty or not.\r\n\t * A bean is empty if it has no other properties than the id field OR\r\n\t * if all the other property are empty().\r\n\t * \r\n\t * @return boolean \r\n\t */\r\n\tpublic function isEmpty() {\r\n\t\t$empty = true;\r\n\t\tforeach($this->properties as $key=>$value) {\r\n\t\t\tif ($key=='id') continue;\r\n\t\t\tif (!empty($value)) { \r\n\t\t\t\t$empty = false;\r\n\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn $empty;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Chainable setter.\r\n\t * \r\n\t * @param string $property the property of the bean\r\n\t * @param mixed  $value    the value you want to set \r\n\t * \r\n\t * @return RedBean_OODBBean the bean \r\n\t */\r\n\tpublic function setAttr($property,$value) {\r\n\t\t$this->$property = $value;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Comfort method.\r\n\t * Unsets all properties in array.\r\n\t * \r\n\t * @param array $properties properties you want to unset.\r\n\t * \r\n\t * @return RedBean_OODBBean \r\n\t */\r\n\tpublic function unsetAll($properties) {\r\n\t\tforeach($properties as $prop) {\r\n\t\t\tif (isset($this->properties[$prop])) {\r\n\t\t\t\tunset($this->properties[$prop]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $this;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Observable\r\n * Base class for Observables\r\n * \r\n * @file \t\t\tRedBean/Observable.php\r\n * @description\t\tPart of the observer pattern in RedBean\r\n *\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nabstract class RedBean_Observable {\r\n\t/**\r\n\t * Array that keeps track of observers.\r\n\t * @var array\r\n\t */\r\n\tprivate $observers = array();\r\n\r\n\t/**\r\n\t * Implementation of the Observer Pattern.\r\n\t * Adds a listener to this instance.\r\n\t * This method can be used to attach an observer to an object.\r\n\t * You can subscribe to a specific event by providing the ID\r\n\t * of the event you are interested in. Once the event occurs\r\n\t * the observable will notify the listeners by calling\r\n\t * onEvent(); providing the event ID and either a bean or\r\n\t * an information array.\r\n\t *\r\n\t * @param string           $eventname event\r\n\t * @param RedBean_Observer $observer observer\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addEventListener( $eventname, RedBean_Observer $observer ) {\r\n\t\tif (!isset($this->observers[ $eventname ])) {\r\n\t\t\t$this->observers[ $eventname ] = array();\r\n\t\t}\r\n\t\tforeach($this->observers[$eventname] as $o) if ($o==$observer) return;\r\n\t\t$this->observers[ $eventname ][] = $observer;\r\n\t}\r\n\r\n\t/**\r\n\t * Implementation of the Observer Pattern.\r\n\t * Sends an event (signal) to the registered listeners\r\n\t * This method is provided by the abstract class Observable for\r\n\t * convience. Observables can use this method to notify their\r\n\t * observers by sending an event ID and information parameter.\r\n\t *\r\n\t * @param string $eventname eventname\r\n\t * @param mixed  $info      info\r\n\t * @return unknown_ty\r\n\t */\r\n\tpublic function signal( $eventname, $info ) {\r\n\t\tif (!isset($this->observers[ $eventname ])) {\r\n\t\t\t$this->observers[ $eventname ] = array();\r\n\t\t}\r\n\t\tforeach($this->observers[$eventname] as $observer) {\r\n\t\t\t$observer->onEvent( $eventname, $info );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Observer\r\n * \r\n * @file \t\t\tRedBean/Observer.php\r\n * @description\t\tPart of the observer pattern in RedBean\r\n * \r\n * @author\t\t\tGabor de Mooijand the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\ninterface RedBean_Observer {\r\n\r\n\t/**\r\n\t * Part of the RedBean Observer Infrastructure.\r\n\t * The on-event method is called by an observable once the\r\n\t * event the observer has been registered for occurs.\r\n\t * Once the even occurs, the observable will signal the observer\r\n\t * using this method, sending the event name and the bean or\r\n\t * an information array.\r\n\t *\r\n\t * @param string $eventname\r\n\t * @param RedBean_OODBBean mixed $info\r\n\t */\r\n\tpublic function onEvent( $eventname, $bean );\r\n}\r\n\r\n/**\r\n * Adapter Interface\r\n *\r\n * @file \t\t\tRedBean/Adapter.php\r\n * @description\t\tDescribes the API for a RedBean Database Adapter.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\ninterface RedBean_Adapter {\r\n\r\n\t/**\r\n\t * Returns the latest SQL statement\r\n\t *\r\n\t * @return string $SQLString SQLString\r\n\t */\r\n\tpublic function getSQL();\r\n\r\n\t/**\r\n\t * Escapes a value for usage in an SQL statement\r\n\t *\r\n\t * @param string $sqlvalue value\r\n\t */\r\n\tpublic function escape( $sqlvalue );\r\n\r\n\t/**\r\n\t * Executes an SQL Statement using an array of values to bind\r\n\t * If $noevent is TRUE then this function will not signal its\r\n\t * observers to notify about the SQL execution; this to prevent\r\n\t * infinite recursion when using observers.\r\n\t *\r\n\t * @param string  $sql     SQL\r\n\t * @param array   $aValues values\r\n\t * @param boolean $noevent no event firing\r\n\t */\r\n\tpublic function exec( $sql , $aValues=array(), $noevent=false);\r\n\r\n\t/**\r\n\t * Executes an SQL Query and returns a resultset.\r\n\t * This method returns a multi dimensional resultset similar to getAll\r\n\t * The values array can be used to bind values to the place holders in the\r\n\t * SQL query.\r\n\t *\r\n\t * @param string $sql     SQL\r\n\t * @param array  $aValues values\r\n\t */\r\n\tpublic function get( $sql, $aValues = array() );\r\n\r\n\t/**\r\n\t * Executes an SQL Query and returns a resultset.\r\n\t * This method returns a single row (one array) resultset.\r\n\t * The values array can be used to bind values to the place holders in the\r\n\t * SQL query.\r\n\t *\r\n\t * @param string $sql\t  SQL\r\n\t * @param array  $aValues values to bind\r\n\t *\r\n\t * @return array $aMultiDimArray row\r\n\t */\r\n\tpublic function getRow( $sql, $aValues = array() );\r\n\r\n\t/**\r\n\t * Executes an SQL Query and returns a resultset.\r\n\t * This method returns a single column (one array) resultset.\r\n\t * The values array can be used to bind values to the place holders in the\r\n\t * SQL query.\r\n\t *\r\n\t * @param string $sql\t  SQL\r\n\t * @param array  $aValues values to bind\r\n\t *\r\n\t * @return array $aSingleDimArray column\r\n\t */\r\n\tpublic function getCol( $sql, $aValues = array() );\r\n\r\n\t/**\r\n\t * Executes an SQL Query and returns a resultset.\r\n\t * This method returns a single cell, a scalar value as the resultset.\r\n\t * The values array can be used to bind values to the place holders in the\r\n\t * SQL query.\r\n\t *\r\n\t * @param string $sql     SQL\r\n\t * @param array  $aValues values to bind\r\n\t *\r\n\t * @return string $sSingleValue value from cell\r\n\t */\r\n\tpublic function getCell( $sql, $aValues = array() );\r\n\r\n\t/**\r\n\t * Executes the SQL query specified in $sql and takes\r\n\t * the first two columns of the resultset. This function transforms the\r\n\t * resultset into an associative array. Values from the the first column will\r\n\t * serve as keys while the values of the second column will be used as values.\r\n\t * The values array can be used to bind values to the place holders in the\r\n\t * SQL query.\r\n\t *\r\n\t * @param string $sql    SQL\r\n\t * @param array  $values values to bind\r\n\t *\r\n\t * @return array $associativeArray associative array result set\r\n\t */\r\n\tpublic function getAssoc( $sql, $values = array() );\r\n\r\n\t/**\r\n\t * Returns the latest insert ID.\r\n\t *\r\n\t * @return integer $id primary key ID\r\n\t */\r\n\tpublic function getInsertID();\r\n\r\n\t/**\r\n\t * Returns the number of rows that have been\r\n\t * affected by the last update statement.\r\n\t *\r\n\t * @return integer $count number of rows affected\r\n\t */\r\n\tpublic function getAffectedRows();\r\n\r\n\t/**\r\n\t * Returns the original database resource. This is useful if you want to\r\n\t * perform operations on the driver directly instead of working with the\r\n\t * adapter. RedBean will only access the adapter and never to talk\r\n\t * directly to the driver though.\r\n\t *\r\n\t * @return object $driver driver\r\n\t */\r\n\tpublic function getDatabase();\r\n\r\n\t/**\r\n\t * This method is part of the RedBean Transaction Management\r\n\t * mechanisms.\r\n\t * Starts a transaction.\r\n\t */\r\n\tpublic function startTransaction();\r\n\r\n\t/**\r\n\t * This method is part of the RedBean Transaction Management\r\n\t * mechanisms.\r\n\t * Commits the transaction.\r\n\t */\r\n\tpublic function commit();\r\n\r\n\t/**\r\n\t * This method is part of the RedBean Transaction Management\r\n\t * mechanisms.\r\n\t * Rolls back the transaction.\r\n\t */\r\n\tpublic function rollback();\r\n\r\n\t/**\r\n\t * Closes database connection.\r\n\t */\r\n\tpublic function close();\r\n\r\n}\r\n\r\n/**\r\n * DBAdapter\t\t(Database Adapter)\r\n * @file\t\t\tRedBean/Adapter/DBAdapter.php\r\n * @description\t\tAn adapter class to connect various database systems to RedBean\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community. \r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Adapter_DBAdapter extends RedBean_Observable implements RedBean_Adapter {\r\n\r\n\t/**\r\n\t * ADODB compatible class\r\n\t * @var RedBean_Driver\r\n\t */\r\n\tprivate $db = null;\r\n\r\n\t/**\r\n\t * Contains SQL snippet\r\n\t * @var string\r\n\t */\r\n\tprivate $sql = '';\r\n\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * Creates an instance of the RedBean Adapter Class.\r\n\t * This class provides an interface for RedBean to work\r\n\t * with ADO compatible DB instances.\r\n\t *\r\n\t * @param RedBean_Driver $database ADO Compatible DB Instance\r\n\t */\r\n\tpublic function __construct($database) {\r\n\t\t$this->db = $database;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the latest SQL Statement.\r\n\t * This method returns the most recently executed SQL statement string.\r\n\t * This can be used for building logging features.\r\n\t *\r\n\t * @return string $SQL latest SQL statement\r\n\t */\r\n\tpublic function getSQL() {\r\n\t\treturn $this->sql;\r\n\t}\r\n\r\n\t/**\r\n\t * Escapes a string for use in a Query.\r\n\t * This method escapes the value argument using the native\r\n\t * driver escaping functions.\r\n\t *\r\n\t * @param  string $sqlvalue SQL value to escape\r\n\t *\r\n\t * @return string $escapedValue escaped value\r\n\t */\r\n\tpublic function escape( $sqlvalue ) {\r\n\t\treturn $this->db->Escape($sqlvalue);\r\n\t}\r\n\r\n\t/**\r\n\t * Executes SQL code; any query without\r\n\t * returning a resultset.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string  $sql\t\t\tSQL Code to execute\r\n\t * @param  array   $values\t\tassoc. array binding values\r\n\t * @param  boolean $noevent   if TRUE this will suppress the event 'sql_exec'\r\n\t *\r\n\t * @return mixed  $undefSet\twhatever driver returns, undefined\r\n\t */\r\n\tpublic function exec( $sql , $aValues=array(), $noevent=false) {\r\n\t\tif (!$noevent) {\r\n\t\t\t$this->sql = $sql;\r\n\t\t\t$this->signal('sql_exec', $this);\r\n\t\t}\r\n\t\treturn $this->db->Execute( $sql, $aValues );\r\n\t}\r\n\r\n\t/**\r\n\t * Multi array SQL fetch. Fetches a multi dimensional array.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string $sql\t\tSQL code to execute\r\n\t * @param  array  $values\tassoc. array binding values\r\n\t *\r\n\t * @return array  $result\ttwo dimensional array result set\r\n\t */\r\n\tpublic function get( $sql, $aValues = array() ) {\r\n\t\t$this->sql = $sql;\r\n\t\t$this->signal('sql_exec', $this);\r\n\t\treturn $this->db->GetAll( $sql,$aValues );\r\n\t}\r\n\r\n\t/**\r\n\t * Executes SQL and fetches a single row.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string $sql\t\tSQL code to execute\r\n\t * @param  array  $values\tassoc. array binding values\r\n\t *\r\n\t * @return array\t$result\tone dimensional array result set\r\n\t */\r\n\tpublic function getRow( $sql, $aValues = array() ) {\r\n\t\t$this->sql = $sql;\r\n\t\t$this->signal('sql_exec', $this);\r\n\t\treturn $this->db->GetRow( $sql,$aValues );\r\n\t}\r\n\r\n\t/**\r\n\t * Executes SQL and returns a one dimensional array result set.\r\n\t * This function rotates the result matrix to obtain a column result set.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string $sql\t\tSQL code to execute\r\n\t * @param  array  $values\tassoc. array binding values\r\n\t *\r\n\t * @return array  $result\tone dimensional array result set\r\n\t */\r\n\tpublic function getCol( $sql, $aValues = array() ) {\r\n\t\t$this->sql = $sql;\r\n\t\t$this->signal('sql_exec', $this);\r\n\t\treturn $this->db->GetCol( $sql,$aValues );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Executes an SQL Query and fetches the first two columns only.\r\n\t * Then this function builds an associative array using the first\r\n\t * column for the keys and the second result column for the\r\n\t * values. For instance: SELECT id, name FROM... will produce\r\n\t * an array like: id => name.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string $sql\t\tSQL code to execute\r\n\t * @param  array  $values\tassoc. array binding values\r\n\t *\r\n\t * @return array  $result\tmulti dimensional assoc. array result set\r\n\t */\r\n\tpublic function getAssoc( $sql, $aValues = array() ) {\r\n\t\t$this->sql = $sql;\r\n\t\t$this->signal('sql_exec', $this);\r\n\t\t$rows = $this->db->GetAll( $sql, $aValues );\r\n\t\t$assoc = array();\r\n\t\tif ($rows) {\r\n\t\t\tforeach($rows as $row) {\r\n\t\t\t\tif (count($row)>0) {\r\n\t\t\t\t\tif (count($row)>1) {\r\n\t\t\t\t\t\t$key = array_shift($row);\r\n\t\t\t\t\t\t$value = array_shift($row);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telseif (count($row)==1) {\r\n\t\t\t\t\t\t$key = array_shift($row);\r\n\t\t\t\t\t\t$value=$key;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$assoc[ $key ] = $value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $assoc;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Retrieves a single cell.\r\n\t * This function allows you to provide an array with values to bind\r\n\t * to query parameters. For instance you can bind values to question\r\n\t * marks in the query. Each value in the array corresponds to the\r\n\t * question mark in the query that matches the position of the value in the\r\n\t * array. You can also bind values using explicit keys, for instance\r\n\t * array(\":key\"=>123) will bind the integer 123 to the key :key in the\r\n\t * SQL.\r\n\t *\r\n\t * @param  string $sql\t  sql code to execute\r\n\t * @param  array  $values assoc. array binding values\r\n\t *\r\n\t * @return array  $result scalar result set\r\n\t */\r\n\r\n\tpublic function getCell( $sql, $aValues = array(), $noSignal = null ) {\r\n\t\t$this->sql = $sql;\r\n\t\tif (!$noSignal) $this->signal('sql_exec', $this);\r\n\t\t$arr = $this->db->getCol( $sql, $aValues );\r\n\t\tif ($arr && is_array($arr))\treturn ($arr[0]); else return false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns latest insert id, most recently inserted id.\r\n\t * Following an insert-SQL statement this method will return the most recently\r\n\t * primary key ID of an inserted record.\r\n\t *\r\n\t * @return integer $id latest insert ID\r\n\t */\r\n\tpublic function getInsertID() {\r\n\t\treturn $this->db->getInsertID();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns number of affected rows.\r\n\t * Returns the number of rows that have been affected by the most recent\r\n\t * SQL query.\r\n\t *\r\n\t * @return integer $numOfAffectRows\r\n\t */\r\n\tpublic function getAffectedRows() {\r\n\t\treturn $this->db->Affected_Rows();\r\n\t}\r\n\r\n\t/**\r\n\t * Unwrap the original database object.\r\n\t * Returns the database driver instance. For instance this can be\r\n\t * an OCI object or a PDO instance or some other third party driver.\r\n\t *\r\n\t * @return RedBean_Driver $database\treturns the inner database object\r\n\t */\r\n\tpublic function getDatabase() {\r\n\t\treturn $this->db;\r\n\t}\r\n\r\n\t/**\r\n\t * Transactions.\r\n\t * Part of the transaction management infrastructure of RedBeanPHP.\r\n\t * Starts a transaction.\r\n\t * Note that transactions may not work in fluid mode depending on your \r\n\t * database platform.\r\n\t */\r\n\tpublic function startTransaction() {\r\n\t\treturn $this->db->StartTrans();\r\n\t}\r\n\r\n\t/**\r\n\t * Transactions.\r\n\t * Part of the transaction management infrastructure of RedBeanPHP.\r\n\t * Commits a transaction.\r\n\t * Note that transactions may not work in fluid mode depending on your \r\n\t * database platform.\r\n\t */\r\n\tpublic function commit() {\r\n\t\treturn $this->db->CommitTrans();\r\n\t}\r\n\r\n\t/**\r\n\t * Transactions.\r\n\t * Part of the transaction management infrastructure of RedBeanPHP.\r\n\t * Rolls back transaction. This will undo all changes that have been\r\n\t * part of the transaction.\r\n\t * Note that transactions may not work in fluid mode depending on your \r\n\t * database platform.\r\n\t */\r\n\tpublic function rollback() {\r\n\t\treturn $this->db->FailTrans();\r\n\t}\r\n\r\n\t/**\r\n\t * Closes the database connection.\r\n\t */\r\n\tpublic function close() {\r\n\t\t$this->db->close();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * QueryWriter\r\n * Interface for QueryWriters\r\n * \r\n * @file\t\t\tRedBean/QueryWriter.php\r\n * @description\t\tDescribes the API for a QueryWriter\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * Notes:\r\n * - Whenever you see a parameter called $table or $type you should always\r\n * be aware of the fact that this argument contains a Bean Type string, not the\r\n * actual table name. These raw type names are passed to safeTable() to obtain the\r\n * actual name of the database table. Don't let the names confuse you $type/$table\r\n * refers to Bean Type, not physical database table names!\r\n * - This is the interface for FLUID database drivers. Drivers intended to support\r\n * just FROZEN mode should implement the IceWriter instead.\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\ninterface RedBean_QueryWriter {\r\n\r\n\t/**\r\n\t * QueryWriter Constant Identifier.\r\n\t * Identifies a situation in which a table has not been found in\r\n\t * the database.\r\n\t */\r\n\tconst C_SQLSTATE_NO_SUCH_TABLE = 1;\r\n\r\n\t/**\r\n\t * QueryWriter Constant Identifier.\r\n\t * Identifies a situation in which a perticular column has not\r\n\t * been found in the database.\r\n\t */\r\n\tconst C_SQLSTATE_NO_SUCH_COLUMN = 2;\r\n\r\n\t/**\r\n\t * QueryWriter Constant Identifier.\r\n\t * Identifies a situation in which a perticular column has not\r\n\t * been found in the database.\r\n\t */\r\n\tconst C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION = 3;\r\n\r\n\t/**\r\n\t * Returns the tables that are in the database.\r\n\t *\r\n\t * @return array $arrayOfTables list of tables\r\n\t */\r\n\tpublic function getTables();\r\n\r\n\t/**\r\n\t * This method should create a table for the bean.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string $type type of bean you want to create a table for\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function createTable($type);\r\n\r\n\t/**\r\n\t * Returns an array containing all the columns of the specified type.\r\n\t * The format of the return array looks like this:\r\n\t * $field => $type where $field is the name of the column and $type\r\n\t * is a database specific description of the datatype.\r\n\t *\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string $type type of bean you want to obtain a column list of\r\n\t *\r\n\t * @return array $listOfColumns list of columns ($field=>$type)\r\n\t */\r\n\tpublic function getColumns($type);\r\n\r\n\r\n\t/**\r\n\t * Returns the Column Type Code (integer) that corresponds\r\n\t * to the given value type. This method is used to determine the minimum\r\n\t * column type required to represent the given value.\r\n\t *\r\n\t * @param string $value value\r\n\t *\r\n\t * @return integer $type type\r\n\t */\r\n\tpublic function scanType($value, $alsoScanSpecialForTypes=false);\r\n\r\n\t/**\r\n\t * This method should add a column to a table.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type   name of the table\r\n\t * @param string  $column name of the column\r\n\t * @param integer $field  data type for field\r\n\t *\r\n\t * @return void\r\n\t *\r\n\t */\r\n\tpublic function addColumn($type, $column, $field);\r\n\r\n\t/**\r\n\t * This method should return a data type constant based on the\r\n\t * SQL type definition. This function is meant to compare column data\r\n\t * type to check whether a column is wide enough to represent the desired\r\n\t * values.\r\n\t *\r\n\t * @param integer $typedescription SQL type description from database\r\n\t *\r\n\t * @return integer $type\r\n\t */\r\n\tpublic function code($typedescription);\r\n\r\n\t/**\r\n\t * This method should widen the column to the specified data type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type       type / table that needs to be adjusted\r\n\t * @param string  $column     column that needs to be altered\r\n\t * @param integer $datatype   target data type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function widenColumn($type, $column, $datatype);\r\n\r\n\t/**\r\n\t * This method should update (or insert a record), it takes\r\n\t * a table name, a list of update values ( $field => $value ) and an\r\n\t * primary key ID (optional). If no primary key ID is provided, an\r\n\t * INSERT will take place.\r\n\t * Returns the new ID.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type         name of the table to update\r\n\t * @param array   $updatevalues list of update values\r\n\t * @param integer $id\t\t\toptional primary key ID value\r\n\t *\r\n\t * @return integer $id the primary key ID value of the new record\r\n\t */\r\n\tpublic function updateRecord($type, $updatevalues, $id=null);\r\n\r\n\r\n\t/**\r\n\t * This method should select a record. You should be able to provide a\r\n\t * collection of conditions using the following format:\r\n\t * array( $field1 => array($possibleValue1, $possibleValue2,... $possibleValueN ),\r\n\t * ...$fieldN=>array(...));\r\n\t * Also, additional SQL can be provided. This SQL snippet will be appended to the\r\n\t * query string. If the $delete parameter is set to TRUE instead of selecting the\r\n\t * records they will be deleted.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type   type of bean to select records from\r\n\t * @param array   $cond   conditions using the specified format\r\n\t * @param string  $asql   additional sql\r\n\t * @param boolean $delete  IF TRUE delete records (optional)\r\n\t * @param boolean $inverse IF TRUE inverse the selection (optional)\r\n\t *\r\n\t * @return array $records selected records\r\n\t */\r\n\tpublic function selectRecord($type, $conditions, $addSql = null, $delete = false, $inverse = false);\r\n\r\n\r\n\t/**\r\n\t * This method should add a UNIQUE constraint index to a table on columns $columns.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string $type               type\r\n\t * @param array  $columnsPartOfIndex columns to include in index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addUniqueIndex($type,$columns);\r\n\r\n\r\n\t/**\r\n\t * This method should check whether the SQL state is in the list of specified states\r\n\t * and returns true if it does appear in this list or false if it\r\n\t * does not. The purpose of this method is to translate the database specific state to\r\n\t * a one of the constants defined in this class and then check whether it is in the list\r\n\t * of standard states provided.\r\n\t *\r\n\t * @param string $state sql state\r\n\t * @param array  $list  list\r\n\t *\r\n\t * @return boolean $isInList\r\n\t */\r\n\tpublic function sqlStateIn( $state, $list );\r\n\r\n\t/**\r\n\t * This method should remove all beans of a certain type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  string $type bean type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function wipe($type);\r\n\r\n\t/**\r\n\t * This method should count the number of beans of the given type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  string $type type of bean to count\r\n\t *\r\n\t * @return integer $numOfBeans number of beans found\r\n\t */\r\n\tpublic function count($type);\r\n\r\n\t/**\r\n\t * This method should filter a column name so that it can\r\n\t * be used safely in a query for a specific database.\r\n\t *\r\n\t * @param  string $name\t\tthe column name\r\n\t * @param  bool   $noQuotes whether you want to omit quotes\r\n\t *\r\n\t * @return string $clean the clean version of the column name\r\n\t */\r\n\tpublic function safeColumn($name, $noQuotes = false);\r\n\r\n\t/**\r\n\t * This method should filter a type name so that it can\r\n\t * be used safely in a query for a specific database. It actually\r\n\t * converts a type to a table. TYPE -> TABLE\r\n\t *\r\n\t * @param string $name     the name of the type\r\n\t * @param bool   $noQuotes whether you want to omit quotes in table name\r\n\t *\r\n\t * @return string $tablename clean table name for use in query\r\n\t */\r\n\tpublic function safeTable($name, $noQuotes = false);\r\n\r\n\t/**\r\n\t * This method should add a constraint. If one of the beans gets trashed\r\n\t * the other, related bean should be removed as well.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1      first bean\r\n\t * @param RedBean_OODBBean $bean2      second bean\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addConstraint( RedBean_OODBBean $bean1, RedBean_OODBBean $bean2 );\r\n\r\n\t/**\r\n\t * This method should add a foreign key from type and field to\r\n\t * target type and target field.\r\n\t * The foreign key is created without an action. On delete/update\r\n\t * no action will be triggered. The FK is only used to allow database\r\n\t * tools to generate pretty diagrams and to make it easy to add actions\r\n\t * later on.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t *\r\n\t * @param  string $type\t       type that will have a foreign key field\r\n\t * @param  string $targetType  points to this type\r\n\t * @param  string $field       field that contains the foreign key value\r\n\t * @param  string $targetField field where the fk points to\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addFK( $type, $targetType, $field, $targetField);\r\n\r\n\r\n\t/**\r\n\t * This method should add an index to a type and field with name\r\n\t * $name.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  $type   type to add index to\r\n\t * @param  $name   name of the new index\r\n\t * @param  $column field to index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addIndex($type, $name, $column);\r\n\r\n\t/**\r\n\t * Returns a modified value from ScanType.\r\n\t * Used for special types.\r\n\t * \r\n\t * @return mixed $value changed value \r\n\t */\r\n\tpublic function getValue();\r\n\r\n}\r\n\r\n/**\r\n * RedBean Abstract Query Writer\r\n *\r\n * @file \t\t\tRedBean/QueryWriter/AQueryWriter.php\r\n * @description\t\tQuert Writer\r\n *\t\t\t\t\tRepresents an abstract Database to RedBean\r\n *\t\t\t\t\tTo write a driver for a different database for RedBean\r\n *\t\t\t\t\tContains a number of functions all implementors can\r\n *\t\t\t\t\tinherit or override.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nabstract class RedBean_QueryWriter_AQueryWriter {\r\n\r\n\t/**\r\n\t * Scanned value (scanType) \r\n\t * @var type\r\n\t */\r\n\tprotected $svalue;\r\n\r\n\t/**\r\n\t * Supported Column Types.\r\n\t * @var array\r\n\t */\r\n\tpublic $typeno_sqltype = array();\r\n\r\n\t/**\r\n\t * Holds a reference to the database adapter to be used.\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\r\n\t/**\r\n\t * default value to for blank field (passed to PK for auto-increment)\r\n\t * @var string\r\n\t */\r\n\tprotected $defaultValue = 'NULL';\r\n\r\n\t/**\r\n\t * character to escape keyword table/column names\r\n\t * @var string\r\n\t */\r\n\tprotected $quoteCharacter = '';\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * Sets the default Bean Formatter, use parent::__construct() in\r\n\t * subclass to achieve this.\r\n\t */\r\n\tpublic function __construct() {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Do everything that needs to be done to format a table name.\r\n\t *\r\n\t * @param string $name of table\r\n\t *\r\n\t * @return string table name\r\n\t */\r\n\tpublic function safeTable($name, $noQuotes = false) {\r\n\t\t$name = $this->check($name);\r\n\t\tif (!$noQuotes) $name = $this->noKW($name);\r\n\t\treturn $name;\r\n\t}\r\n\r\n\t/**\r\n\t * Do everything that needs to be done to format a column name.\r\n\t *\r\n\t * @param string $name of column\r\n\t *\r\n\t * @return string $column name\r\n\t */\r\n\tpublic function safeColumn($name, $noQuotes = false) {\r\n\t\t$name = $this->check($name);\r\n\t\tif (!$noQuotes) $name = $this->noKW($name);\r\n\t\treturn $name;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the sql that should follow an insert statement.\r\n\t *\r\n\t * @param string $table name\r\n\t *\r\n\t * @return string sql\r\n\t */\r\n  \tprotected function getInsertSuffix ($table) {\r\n    \treturn '';\r\n  \t}\r\n\r\n\t/**\r\n\t * Checks table name or column name.\r\n\t *\r\n\t * @param string $table table string\r\n\t *\r\n\t * @return string $table escaped string\r\n\t */\r\n\tprotected function check($table) {\r\n\t\tif ($this->quoteCharacter && strpos($table, $this->quoteCharacter)!==false) {\r\n\t\t  throw new Redbean_Exception_Security('Illegal chars in table name');\r\n\t    }\r\n\t\treturn $this->adapter->escape($table);\r\n\t}\r\n\r\n\t/**\r\n\t * Puts keyword escaping symbols around string.\r\n\t *\r\n\t * @param string $str keyword\r\n\t *\r\n\t * @return string $keywordSafeString escaped keyword\r\n\t */\r\n\tprotected function noKW($str) {\r\n\t\t$q = $this->quoteCharacter;\r\n\t\treturn $q.$str.$q;\r\n\t}\r\n\r\n\t/**\r\n\t * This method adds a column to a table.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type   name of the table\r\n\t * @param string  $column name of the column\r\n\t * @param integer $field  data type for field\r\n\t *\r\n\t * @return void\r\n\t *\r\n\t */\r\n\tpublic function addColumn( $type, $column, $field ) {\r\n\t\t$table = $type;\r\n\t\t$type = $field;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$type = array_key_exists($type, $this->typeno_sqltype) ? $this->typeno_sqltype[$type] : '';\r\n\t\t$sql = \"ALTER TABLE $table ADD $column $type \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\t/**\r\n\t * This method updates (or inserts) a record, it takes\r\n\t * a table name, a list of update values ( $field => $value ) and an\r\n\t * primary key ID (optional). If no primary key ID is provided, an\r\n\t * INSERT will take place.\r\n\t * Returns the new ID.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type         name of the table to update\r\n\t * @param array   $updatevalues list of update values\r\n\t * @param integer $id\t\t\toptional primary key ID value\r\n\t *\r\n\t * @return integer $id the primary key ID value of the new record\r\n\t */\r\n\tpublic function updateRecord( $type, $updatevalues, $id=null) {\r\n\t\t$table = $type;\r\n\t\tif (!$id) {\r\n\t\t\t$insertcolumns =  $insertvalues = array();\r\n\t\t\tforeach($updatevalues as $pair) {\r\n\t\t\t\t$insertcolumns[] = $pair['property'];\r\n\t\t\t\t$insertvalues[] = $pair['value'];\r\n\t\t\t}\r\n\t\t\treturn $this->insertRecord($table,$insertcolumns,array($insertvalues));\r\n\t\t}\r\n\t\tif ($id && !count($updatevalues)) return $id;\r\n\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \"UPDATE $table SET \";\r\n\t\t$p = $v = array();\r\n\t\tforeach($updatevalues as $uv) {\r\n\t\t\t$p[] = \" {$this->safeColumn($uv[\"property\"])} = ? \";\r\n\t\t\t$v[]=$uv['value'];\r\n\t\t}\r\n\t\t$sql .= implode(',', $p ) .' WHERE id = '.intval($id);\r\n\t\t$this->adapter->exec( $sql, $v );\r\n\t\treturn $id;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a record into the database using a series of insert columns\r\n\t * and corresponding insertvalues. Returns the insert id.\r\n\t *\r\n\t * @param string $table\t\t\t  table to perform query on\r\n\t * @param array  $insertcolumns columns to be inserted\r\n\t * @param array  $insertvalues  values to be inserted\r\n\t *\r\n\t * @return integer $insertid\t  insert id from driver, new record id\r\n\t */\r\n\tprotected function insertRecord( $table, $insertcolumns, $insertvalues ) {\r\n\t\t$default = $this->defaultValue;\r\n\t\t$suffix = $this->getInsertSuffix($table);\r\n\t\t$table = $this->safeTable($table);\r\n\t\tif (count($insertvalues)>0 && is_array($insertvalues[0]) && count($insertvalues[0])>0) {\r\n\t\t\tforeach($insertcolumns as $k=>$v) {\r\n\t\t\t\t$insertcolumns[$k] = $this->safeColumn($v);\r\n\t\t\t}\r\n\t\t\t$insertSQL = \"INSERT INTO $table ( id, \".implode(',',$insertcolumns).\" ) VALUES \r\n\t\t\t( $default, \". implode(',',array_fill(0,count($insertcolumns),' ? ')).\" ) $suffix\";\r\n\r\n\t\t\tforeach($insertvalues as $i=>$insertvalue) {\r\n\t\t\t\t$ids[] = $this->adapter->getCell( $insertSQL, $insertvalue, $i );\r\n\t\t\t}\r\n\t\t\t$result = count($ids)===1 ? array_pop($ids) : $ids;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$result = $this->adapter->getCell( \"INSERT INTO $table (id) VALUES($default) $suffix\");\r\n\t\t}\r\n\t\tif ($suffix) return $result;\r\n\t\t$last_id = $this->adapter->getInsertID();\r\n\t\treturn $last_id;\r\n\t}\r\n\r\n\r\n\r\n\r\n\t/**\r\n\t * This selects a record. You provide a\r\n\t * collection of conditions using the following format:\r\n\t * array( $field1 => array($possibleValue1, $possibleValue2,... $possibleValueN ),\r\n\t * ...$fieldN=>array(...));\r\n\t * Also, additional SQL can be provided. This SQL snippet will be appended to the\r\n\t * query string. If the $delete parameter is set to TRUE instead of selecting the\r\n\t * records they will be deleted.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @throws Exception\r\n\t * @param string  $type    type of bean to select records from\r\n\t * @param array   $cond    conditions using the specified format\r\n\t * @param string  $asql    additional sql\r\n\t * @param boolean $delete  IF TRUE delete records (optional)\r\n\t * @param boolean $inverse IF TRUE inverse the selection (optional)\r\n\t * @param boolean $all     IF TRUE suppress WHERE keyword, omitting WHERE clause\r\n\t *\r\n\t * @return array $records selected records\r\n\t */\r\n\tpublic function selectRecord( $type, $conditions, $addSql=null, $delete=null, $inverse=false, $all=false ) { \r\n\t\tif (!is_array($conditions)) throw new Exception('Conditions must be an array');\r\n\t\t$table = $this->safeTable($type);\r\n\t\t$sqlConditions = array();\r\n\t\t$bindings=array();\r\n\t\tforeach($conditions as $column=>$values) {\r\n\t\t\tif (!count($values)) continue;\r\n\t\t\t$sql = $this->safeColumn($column);\r\n\t\t\t$sql .= ' '.($inverse ? ' NOT ':'').' IN ( ';\r\n\t\t\t//If its safe to not use bindings please do... (fixes SQLite PDO issue limit 256 bindings)\r\n\t\t\tif (count($conditions)===1 \r\n\t\t\t\t&& isset($conditions['id']) \r\n\t\t\t\t&& is_array($values) \r\n\t\t\t\t&& preg_match('/^\\d+$/',implode('',$values))) {\r\n\t\t\t\t$sql .= implode(',',$values).') ';\r\n\t\t\t\t$sqlConditions[] = $sql;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$sql .= implode(',',array_fill(0,count($values),'?')).') ';\r\n\t\t\t\t$sqlConditions[] = $sql;\r\n\t\t\t\tif (!is_array($values)) $values = array($values);\r\n\t\t\t\tforeach($values as $k=>$v) {\r\n\t\t\t\t\t$values[$k]=strval($v);\r\n\t\t\t\t}\r\n\t\t\t\t$bindings = array_merge($bindings,$values);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//$addSql can be either just a string or array($sql, $bindings)\r\n\t\tif (is_array($addSql)) {\r\n\t\t\tif (count($addSql)>1) {\r\n\t\t\t\t$bindings = array_merge($bindings,$addSql[1]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$bindings = array();\r\n\t\t\t}\r\n\t\t\t$addSql = $addSql[0];\r\n\r\n\t\t}\r\n\t\t$sql = '';\r\n\t\tif (count($sqlConditions)>0) {\r\n\t\t\t$sql = implode(' AND ',$sqlConditions);\r\n\t\t\t$sql = \" WHERE ( $sql ) \";\r\n\t\t\tif ($addSql) $sql .= \" AND $addSql \";\r\n\t\t}\r\n\t\telseif ($addSql) {\r\n\t\t\tif ($all) {\r\n\t\t\t\t$sql = \" $addSql \";\r\n\t\t\t} \r\n\t\t\telse {\r\n\t\t\t\t$sql = \" WHERE $addSql \";\r\n\t\t\t}\r\n\t\t}\r\n\t\t$sql = (($delete) ? 'DELETE FROM ' : 'SELECT * FROM ').$table.$sql;\r\n\t\t$rows = $this->adapter->get($sql,$bindings);\r\n\t\treturn $rows;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This method removes all beans of a certain type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  string $type bean type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function wipe($type) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \"TRUNCATE $table \";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\r\n\r\n\t/**\r\n\t * Counts rows in a table.\r\n\t *\r\n\t * @param string $beanType type of bean to count\r\n\t * @param string $addSQL   additional SQL\r\n\t * @param array  $params   parameters to bind to SQL\r\n\t *\r\n\t * @return integer $numRowsFound\r\n\t */\r\n\tpublic function count($beanType,$addSQL = '',$params = array()) {\r\n\t\t$sql = \"SELECT count(*) FROM {$this->safeTable($beanType)} \";\r\n\t\tif ($addSQL!='') $addSQL = ' WHERE '.$addSQL; \r\n\t\treturn (int) $this->adapter->getCell($sql.$addSQL,$params);\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * This is a utility service method publicly available.\r\n\t * It allows you to check whether you can safely treat an certain value as an integer by\r\n\t * comparing an int-valled string representation with a default string casted string representation and\r\n\t * a ctype-digit check. It does not take into account numerical limitations (X-bit INT), just that it\r\n\t * can be treated like an INT. This is useful for binding parameters to query statements like\r\n\t * Query Writers and drivers can do.\r\n\t *\r\n\t * @static\r\n\t *\r\n\t * @param  string $value string representation of a certain value\r\n\t *\r\n\t * @return boolean $value boolean result of analysis\r\n\t */\r\n\tpublic static function canBeTreatedAsInt( $value ) {\r\n\t\treturn (boolean) (ctype_digit(strval($value)) && strval($value)===strval(intval($value)));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This method adds a foreign key from type and field to\r\n\t * target type and target field.\r\n\t * The foreign key is created without an action. On delete/update\r\n\t * no action will be triggered. The FK is only used to allow database\r\n\t * tools to generate pretty diagrams and to make it easy to add actions\r\n\t * later on.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t *\r\n\t * @param  string $type\t       type that will have a foreign key field\r\n\t * @param  string $targetType  points to this type\r\n\t * @param  string $field       field that contains the foreign key value\r\n\t * @param  string $targetField field where the fk points to\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addFK( $type, $targetType, $field, $targetField, $isDependent = false) {\r\n\t\t$table = $this->safeTable($type);\r\n\t\t$tableNoQ = $this->safeTable($type,true);\r\n\t\t$targetTable = $this->safeTable($targetType);\r\n\t\t$column = $this->safeColumn($field);\r\n\t\t$columnNoQ = $this->safeColumn($field,true);\r\n\t\t$targetColumn  = $this->safeColumn($targetField);\r\n\t\t$targetColumnNoQ  = $this->safeColumn($targetField,true);\r\n\t\t$db = $this->adapter->getCell('select database()');\r\n\t\t$fkName = 'fk_'.$tableNoQ.'_'.$columnNoQ.'_'.$targetColumnNoQ.($isDependent ? '_casc':'');\r\n\t\t$cName = 'cons_'.$fkName;\r\n\t\t$cfks =  $this->adapter->getCell(\"\r\n\t\t\tSELECT CONSTRAINT_NAME\r\n\t\t\tFROM information_schema.KEY_COLUMN_USAGE\r\n\t\t\tWHERE TABLE_SCHEMA ='$db' AND TABLE_NAME = '$tableNoQ'  AND COLUMN_NAME = '$columnNoQ' AND\r\n\t\t\tCONSTRAINT_NAME <>'PRIMARY' AND REFERENCED_TABLE_NAME is not null\r\n\t\t\");\r\n\t\t$flagAddKey = false;\r\n\r\n\t\ttry{\r\n\t\t\t//No keys\r\n\t\t\tif (!$cfks) {\r\n\t\t\t\t$flagAddKey = true; //go get a new key\r\n\t\t\t}\r\n\t\t\t//has fk, but different setting, --remove\r\n\t\t\tif ($cfks && $cfks!=$cName) {\r\n\t\t\t\t$this->adapter->exec(\"ALTER TABLE $table DROP FOREIGN KEY $cfks \");\r\n\t\t\t\t$flagAddKey = true; //go get a new key.\r\n\t\t\t}\r\n\t\t\tif ($flagAddKey) { \r\n\t\t\t\t$this->adapter->exec(\"ALTER TABLE  $table\r\n\t\t\t\tADD CONSTRAINT $cName FOREIGN KEY $fkName (  $column ) REFERENCES  $targetTable (\r\n\t\t\t\t$targetColumn) ON DELETE \".($isDependent ? 'CASCADE':'SET NULL').' ON UPDATE SET NULL ;');\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception $e) { } //Failure of fk-constraints is not a problem\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the format for link tables.\r\n\t * Given an array containing two type names this method returns the\r\n\t * name of the link table to be used to store and retrieve\r\n\t * association records.\r\n\t *\r\n\t * @param  array $types two types array($type1,$type2)\r\n\t *\r\n\t * @return string $linktable name of the link table\r\n\t */\r\n\tpublic static function getAssocTableFormat($types) {\r\n\t\tsort($types);\r\n\t\treturn ( implode('_', $types) );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Adds a constraint. If one of the beans gets trashed\r\n\t * the other, related bean should be removed as well.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1      first bean\r\n\t * @param RedBean_OODBBean $bean2      second bean\r\n\t * @param bool \t\t\t   $dontCache  by default we use a cache, TRUE = NO CACHING (optional)\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addConstraint( RedBean_OODBBean $bean1, RedBean_OODBBean $bean2) {\r\n\t\t$table1 = $bean1->getMeta('type');\r\n\t\t$table2 = $bean2->getMeta('type');\r\n\t\t$writer = $this;\r\n\t\t$adapter = $this->adapter;\r\n\t\t$table = RedBean_QueryWriter_AQueryWriter::getAssocTableFormat( array( $table1,$table2) );\r\n\r\n\t\t$property1 = $bean1->getMeta('type') . '_id';\r\n\t\t$property2 = $bean2->getMeta('type') . '_id';\r\n\t\tif ($property1==$property2) $property2 = $bean2->getMeta('type').'2_id';\r\n\r\n\t\t$table = $adapter->escape($table);\r\n\t\t$table1 = $adapter->escape($table1);\r\n\t\t$table2 = $adapter->escape($table2);\r\n\t\t$property1 = $adapter->escape($property1);\r\n\t\t$property2 = $adapter->escape($property2);\r\n\r\n\t\t//Dispatch to right method\r\n\t\treturn $this->constrain($table, $table1, $table2, $property1, $property2);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a value starts with zeros. In this case\r\n\t * the value should probably be stored using a text datatype instead of a\r\n\t * numerical type in order to preserve the zeros.\r\n\t * \r\n\t * @param string $value value to be checked.\r\n\t */\r\n\tprotected function startsWithZeros($value) {\r\n\t\t$value = strval($value);\r\n\t\tif (strlen($value)>1 && strpos($value,'0')===0 && strpos($value,'0.')!==0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a modified value from ScanType.\r\n\t * Used for special types.\r\n\t * \r\n\t * @return mixed $value changed value \r\n\t */\r\n\tpublic function getValue(){\r\n\t\treturn $this->svalue;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean MySQLWriter\r\n *\r\n * @file\t\t\tRedBean/QueryWriter/MySQL.php\r\n * @description\t\tRepresents a MySQL Database to RedBean\r\n *\t\t\t\t\tTo write a driver for a different database for RedBean\r\n *\t\t\t\t\tyou should only have to change this file.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_QueryWriter_MySQL extends RedBean_QueryWriter_AQueryWriter implements RedBean_QueryWriter {\r\n\r\n\t/**\r\n\t * Here we describe the datatypes that RedBean\r\n\t * Uses internally. If you write a QueryWriter for\r\n\t * RedBean you should provide a list of types like this.\r\n\t */\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Boolean Data type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_BOOL = 0;\r\n\r\n\t/**\r\n\t *\r\n\t * DATA TYPE\r\n\t * Unsigned 8BIT Integer\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_UINT8 = 1;\r\n\r\n\t/**\r\n\t *\r\n\t * DATA TYPE\r\n\t * Unsigned 32BIT Integer\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_UINT32 = 2;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Double precision floating point number and\r\n\t * negative numbers.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_DOUBLE = 3;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Standard Text column (like varchar255)\r\n\t * At least 8BIT character support.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_TEXT8 = 4;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Long text column (16BIT)\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_TEXT16 = 5;\r\n\r\n\t/**\r\n\t * \r\n\t * DATA TYPE\r\n\t * 32BIT long textfield (number of characters can be as high as 32BIT) Data type\r\n\t * This is the biggest column that RedBean supports. If possible you may write\r\n\t * an implementation that stores even bigger values.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_TEXT32 = 6;\r\n\r\n\t/**\r\n\t * Special type date for storing date values: YYYY-MM-DD\r\n\t * @var integer\r\n\t */\t\r\n\tconst C_DATATYPE_SPECIAL_DATE = 80;\r\n\r\n\t/**\r\n\t * Special type datetime for store date-time values: YYYY-MM-DD HH:II:SS\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIAL_DATETIME = 81;\r\n\r\n\r\n\t/**\r\n\t * \r\n\t * DATA TYPE\r\n\t * Specified. This means the developer or DBA\r\n\t * has altered the column to a different type not\r\n\t * recognized by RedBean. This high number makes sure\r\n\t * it will not be converted back to another type by accident.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIFIED = 99;\r\n\r\n\t/**\r\n\t * Spatial types\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIAL_POINT = 100;\r\n\tconst C_DATATYPE_SPECIAL_LINESTRING = 101;\r\n\tconst C_DATATYPE_SPECIAL_GEOMETRY = 102;\r\n\tconst C_DATATYPE_SPECIAL_POLYGON = 103;\r\n\tconst C_DATATYPE_SPECIAL_MULTIPOINT = 104;\r\n\tconst C_DATATYPE_SPECIAL_MULTIPOLYGON = 105;\r\n\tconst C_DATATYPE_SPECIAL_GEOMETRYCOLLECTION = 106;\r\n\r\n\t/**\r\n\t * Holds the RedBean Database Adapter.\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * character to escape keyword table/column names\r\n\t * @var string\r\n\t */\r\n  \tprotected $quoteCharacter = '`';\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * The Query Writer Constructor also sets up the database.\r\n\t *\r\n\t * @param RedBean_Adapter_DBAdapter $adapter adapter\r\n\t *\r\n\t */\r\n\tpublic function __construct( RedBean_Adapter $adapter ) {\r\n\r\n\t\t$this->typeno_sqltype = array(\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_BOOL=>\"  SET('1')  \",\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_UINT8=>' TINYINT(3) UNSIGNED ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32=>' INT(11) UNSIGNED ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_DOUBLE=>' DOUBLE ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT8=>' VARCHAR(255) ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT16=>' TEXT ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT32=>' LONGTEXT ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_DATE=>' DATE ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_DATETIME=>' DATETIME ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_POINT=>' POINT ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_LINESTRING=>' LINESTRING  ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_GEOMETRY=>' GEOMETRY ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_POLYGON=>' POLYGON ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_MULTIPOINT=>' MULTIPOINT ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_MULTIPOLYGON=>' MULTIPOLYGON ',\r\n\t\t\t  RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_GEOMETRYCOLLECTION=>' GEOMETRYCOLLECTION ',\r\n\t\t);\r\n\r\n\t\t$this->sqltype_typeno = array();\r\n\t\tforeach($this->typeno_sqltype as $k=>$v)\r\n\t\t$this->sqltype_typeno[trim(strtolower($v))]=$k;\r\n\r\n\r\n\t\t$this->adapter = $adapter;\r\n\t\tparent::__construct();\r\n\t}\r\n\r\n\t/**\r\n\t * This method returns the datatype to be used for primary key IDS and\r\n\t * foreign keys. Returns one if the data type constants.\r\n\t *\r\n\t * @return integer $const data type to be used for IDS.\r\n\t */\r\n\tpublic function getTypeForID() {\r\n\t\treturn self::C_DATATYPE_UINT32;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all tables in the database.\r\n\t *\r\n\t * @return array $tables tables\r\n\t */\r\n\tpublic function getTables() {\r\n\t\treturn $this->adapter->getCol( 'show tables' );\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an empty, column-less table for a bean based on it's type.\r\n\t * This function creates an empty table for a bean. It uses the\r\n\t * safeTable() function to convert the type name to a table name.\r\n\t *\r\n\t * @param string $table type of bean you want to create a table for\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function createTable( $table ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \"     CREATE TABLE $table (\r\n                     id INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,\r\n                     PRIMARY KEY ( id )\r\n                     ) ENGINE = InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array containing the column names of the specified table.\r\n\t *\r\n\t * @param string $table table\r\n\t *\r\n\t * @return array $columns columns\r\n\t */\r\n\tpublic function getColumns( $table ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$columnsRaw = $this->adapter->get(\"DESCRIBE $table\");\r\n\t\tforeach($columnsRaw as $r) {\r\n\t\t\t$columns[$r['Field']]=$r['Type'];\r\n\t\t}\r\n\t\treturn $columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the MySQL Column Type Code (integer) that corresponds\r\n\t * to the given value type.\r\n\t *\r\n\t * @param string $value value\r\n\t *\r\n\t * @return integer $type type\r\n\t */\r\n\tpublic function scanType( $value, $flagSpecial=false ) {\r\n\t\t$this->svalue = $value;\r\n\r\n\t\tif (is_null($value)) {\r\n\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_BOOL;\r\n\t\t}\r\n\r\n\t\tif ($flagSpecial) {\r\n\t\t\tif (strpos($value,'POINT(')===0) {\r\n\t\t\t\t$this->svalue = $this->adapter->getCell('SELECT GeomFromText(?)',array($value));\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_POINT;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'LINESTRING(')===0) {\r\n\t\t\t\t$this->svalue = $this->adapter->getCell('SELECT GeomFromText(?)',array($value));\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_LINESTRING;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'POLYGON(')===0) {\r\n\t\t\t\t$this->svalue = $this->adapter->getCell('SELECT GeomFromText(?)',array($value));\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_POLYGON;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'MULTIPOINT(')===0) {\r\n\t\t\t\t$this->svalue = $this->adapter->getCell('SELECT GeomFromText(?)',array($value));\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_MULTIPOINT;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d$/',$value)) {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_DATE;\r\n\t\t\t}\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d\\s\\d\\d:\\d\\d:\\d\\d$/',$value)) {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_SPECIAL_DATETIME;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$value = strval($value);\r\n\t\tif (!$this->startsWithZeros($value)) {\r\n\r\n\t\t\tif ($value=='1' || $value=='') {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_BOOL;\r\n\t\t\t}\r\n\t\t\tif (is_numeric($value) && (floor($value)==$value) && $value >= 0 && $value <= 255 ) {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_UINT8;\r\n\t\t\t}\r\n\t\t\tif (is_numeric($value) && (floor($value)==$value) && $value >= 0  && $value <= 4294967295 ) {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32;\r\n\t\t\t}\r\n\t\t\tif (is_numeric($value)) {\r\n\t\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_DOUBLE;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (strlen($value) <= 255) {\r\n\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT8;\r\n\t\t}\r\n\t\tif (strlen($value) <= 65535) {\r\n\t\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT16;\r\n\t\t}\r\n\t\treturn RedBean_QueryWriter_MySQL::C_DATATYPE_TEXT32;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Type Code for a Column Description.\r\n\t * Given an SQL column description this method will return the corresponding\r\n\t * code for the writer. If the include specials flag is set it will also\r\n\t * return codes for special columns. Otherwise special columns will be identified\r\n\t * as specified columns.\r\n\t *\r\n\t * @param string  $typedescription description\r\n\t * @param boolean $includeSpecials whether you want to get codes for special columns as well\r\n\t *\r\n\t * @return integer $typecode code\r\n\t */\r\n\tpublic function code( $typedescription, $includeSpecials = false ) {\r\n\t\t$r = ((isset($this->sqltype_typeno[$typedescription])) ? $this->sqltype_typeno[$typedescription] : self::C_DATATYPE_SPECIFIED);\r\n\t\tif ($includeSpecials) return $r;\r\n\t\tif ($r > self::C_DATATYPE_SPECIFIED) return self::C_DATATYPE_SPECIFIED;\r\n\t\treturn $r;\r\n\t}\r\n\r\n\t/**\r\n\t * This method upgrades the column to the specified data type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type       type / table that needs to be adjusted\r\n\t * @param string  $column     column that needs to be altered\r\n\t * @param integer $datatype   target data type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function widenColumn( $type, $column, $datatype ) {\r\n\t\t$table = $type;\r\n\t\t$type = $datatype;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$newtype = array_key_exists($type, $this->typeno_sqltype) ? $this->typeno_sqltype[$type] : '';\r\n\t\t$changecolumnSQL = \"ALTER TABLE $table CHANGE $column $column $newtype \";\r\n\t\t$this->adapter->exec( $changecolumnSQL );\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a Unique index constrain to the table.\r\n\t *\r\n\t * @param string $table table\r\n\t * @param string $col1  column\r\n\t * @param string $col2  column\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addUniqueIndex( $table,$columns ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\tsort($columns); //else we get multiple indexes due to order-effects\r\n\t\tforeach($columns as $k=>$v) {\r\n\t\t\t$columns[$k]= $this->safeColumn($v);\r\n\t\t}\r\n\t\t$r = $this->adapter->get(\"SHOW INDEX FROM $table\");\r\n\t\t$name = 'UQ_'.sha1(implode(',',$columns));\r\n\t\tif ($r) {\r\n\t\t\tforeach($r as $i) {\r\n\t\t\t\tif ($i['Key_name']== $name) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$sql = \"ALTER IGNORE TABLE $table\r\n                ADD UNIQUE INDEX $name (\".implode(',',$columns).\")\";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\r\n\r\n\t/**\r\n\t * This method should add an index to a type and field with name\r\n\t * $name.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  $type   type to add index to\r\n\t * @param  $name   name of the new index\r\n\t * @param  $column field to index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addIndex($type, $name, $column) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$name = preg_replace('/\\W/','',$name);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\tforeach( $this->adapter->get(\"SHOW INDEX FROM $table \") as $ind) {\r\n\t\t\tif ($ind['Key_name']===$name) return;\r\n\t\t}\r\n\t\ttry{ $this->adapter->exec(\"CREATE INDEX $name ON $table ($column) \"); }catch(Exception $e){}\r\n\t}\r\n\r\n\t/**\r\n\t * Tests whether a given SQL state is in the list of states.\r\n\t *\r\n\t * @param string $state code\r\n\t * @param array  $list  array of sql states\r\n\t *\r\n\t * @return boolean $yesno occurs in list\r\n\t */\r\n\tpublic function sqlStateIn($state, $list) {\r\n\t\t$stateMap = array(\r\n\t\t\t'42S02'=>RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE,\r\n\t\t\t'42S22'=>RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\t'23000'=>RedBean_QueryWriter::C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION\r\n\t\t);\r\n\t\treturn in_array((isset($stateMap[$state]) ? $stateMap[$state] : '0'),$list); \r\n\t}\r\n\r\n\t/**\r\n\t * Add the constraints for a specific database driver: MySQL.\r\n\t * @todo Too many arguments; find a way to solve this in a neater way.\r\n\t *\r\n\t * @param string\t\t\t  $table     table\r\n\t * @param string\t\t\t  $table1    table1\r\n\t * @param string\t\t\t  $table2    table2\r\n\t * @param string\t\t\t  $property1 property1\r\n\t * @param string\t\t\t  $property2 property2\r\n\t *\r\n\t * @return boolean $succes whether the constraint has been applied\r\n\t */\r\n\tprotected function constrain($table, $table1, $table2, $property1, $property2) {\r\n\t\ttry{\r\n\t\t\t$db = $this->adapter->getCell('select database()');\r\n\t\t\t$fks =  $this->adapter->getCell(\"\r\n\t\t\t\tSELECT count(*)\r\n\t\t\t\tFROM information_schema.KEY_COLUMN_USAGE\r\n\t\t\t\tWHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? AND\r\n\t\t\t\tCONSTRAINT_NAME <>'PRIMARY' AND REFERENCED_TABLE_NAME is not null\r\n\t\t\t\t\t  \",array($db,$table));\r\n\t\t\t//already foreign keys added in this association table\r\n\t\t\tif ($fks>0) return false;\r\n\t\t\t$columns = $this->getColumns($table);\r\n\t\t\tif ($this->code($columns[$property1])!==RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32) {\r\n\t\t\t\t$this->widenColumn($table, $property1, RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32);\r\n\t\t\t}\r\n\t\t\tif ($this->code($columns[$property2])!==RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32) {\r\n\t\t\t\t$this->widenColumn($table, $property2, RedBean_QueryWriter_MySQL::C_DATATYPE_UINT32);\r\n\t\t\t}\r\n\r\n\t\t\t$sql = \"\r\n\t\t\t\tALTER TABLE \".$this->noKW($table).\"\r\n\t\t\t\tADD FOREIGN KEY($property1) references `$table1`(id) ON DELETE CASCADE;\r\n\t\t\t\t\t  \";\r\n\t\t\t$this->adapter->exec( $sql );\r\n\t\t\t$sql =\"\r\n\t\t\t\tALTER TABLE \".$this->noKW($table).\"\r\n\t\t\t\tADD FOREIGN KEY($property2) references `$table2`(id) ON DELETE CASCADE\r\n\t\t\t\t\t  \";\r\n\t\t\t$this->adapter->exec( $sql );\r\n\t\t\treturn true;\r\n\t\t} catch(Exception $e){ return false; }\r\n\t}\r\n\r\n\t/**\r\n\t * Drops all tables in database\r\n\t */\r\n\tpublic function wipeAll() {\r\n\t\t$this->adapter->exec('SET FOREIGN_KEY_CHECKS=0;');\r\n\t\tforeach($this->getTables() as $t) {\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop table if exists`$t`\");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){}\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop view if exists`$t`\");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){}\r\n\t\t}\r\n\t\t$this->adapter->exec('SET FOREIGN_KEY_CHECKS=1;');\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean SQLiteWriter with support for SQLite types\r\n *\r\n * @file\t\t\t\tRedBean/QueryWriter/SQLiteT.php\r\n * @description\t\t\tRepresents a SQLite Database to RedBean\r\n *\t\t\t\t\t\tTo write a driver for a different database for RedBean\r\n *\t\t\t\t\t\tyou should only have to change this file.\r\n * @author\t\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\t\tBSD/GPLv2\r\n * \r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_QueryWriter_SQLiteT extends RedBean_QueryWriter_AQueryWriter implements RedBean_QueryWriter {\r\n\t/**\r\n\t *\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t * Holds database adapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * @var string\r\n\t * character to escape keyword table/column names\r\n\t */\r\n  \tprotected $quoteCharacter = '`';\r\n\r\n\t/**\r\n\t * Here we describe the datatypes that RedBean\r\n\t * Uses internally. If you write a QueryWriter for\r\n\t * RedBean you should provide a list of types like this.\r\n\t */\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Integer Data type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_INTEGER = 0;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Numeric Data type (for REAL and date/time)\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_NUMERIC = 1;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Text type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_TEXT = 2;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Specified. This means the developer or DBA\r\n\t * has altered the column to a different type not\r\n\t * recognized by RedBean. This high number makes sure\r\n\t * it will not be converted back to another type by accident.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIFIED = 99;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * The Query Writer Constructor also sets up the database\r\n\t *\r\n\t * @param RedBean_Adapter_DBAdapter $adapter adapter\r\n\t */\r\n\tpublic function __construct( RedBean_Adapter $adapter ) {\r\n\r\n\t\t$this->typeno_sqltype = array(\r\n\t\t\t  RedBean_QueryWriter_SQLiteT::C_DATATYPE_INTEGER=>'INTEGER',\r\n\t\t\t  RedBean_QueryWriter_SQLiteT::C_DATATYPE_NUMERIC=>'NUMERIC',\r\n\t\t\t  RedBean_QueryWriter_SQLiteT::C_DATATYPE_TEXT=>'TEXT',\r\n\t\t);\r\n\r\n\t\t$this->sqltype_typeno = array();\r\n\t\tforeach($this->typeno_sqltype as $k=>$v)\r\n\t\t$this->sqltype_typeno[$v]=$k;\r\n\r\n\r\n\t\t$this->adapter = $adapter;\r\n\t\tparent::__construct($adapter);\r\n\t}\r\n\r\n\t/**\r\n\t * This method returns the datatype to be used for primary key IDS and\r\n\t * foreign keys. Returns one if the data type constants.\r\n\t *\r\n\t * @return integer $const data type to be used for IDS.\r\n\t */\r\n\tpublic function getTypeForID() {\r\n\t\treturn self::C_DATATYPE_INTEGER;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the MySQL Column Type Code (integer) that corresponds\r\n\t * to the given value type.\r\n\t *\r\n\t * @param  string $value value\r\n\t *\r\n\t * @return integer $type type\r\n\t */\r\n\tpublic function scanType( $value, $flagSpecial=false ) {\r\n\t\t$this->svalue=$value;\r\n\t\tif ($value===false) return self::C_DATATYPE_INTEGER;\r\n\t\tif ($value===null) return self::C_DATATYPE_INTEGER; //for fks\r\n\t\tif ($this->startsWithZeros($value)) return self::C_DATATYPE_TEXT;\r\n\t\tif (is_numeric($value) && (intval($value)==$value) && $value<2147483648) return self::C_DATATYPE_INTEGER;\r\n\t\tif ((is_numeric($value) && $value < 2147483648)\r\n\t\t\t\t  || preg_match('/\\d{4}\\-\\d\\d\\-\\d\\d/',$value)\r\n\t\t\t\t  || preg_match('/\\d{4}\\-\\d\\d\\-\\d\\d\\s\\d\\d:\\d\\d:\\d\\d/',$value)\r\n\t\t) {\r\n\t\t\treturn self::C_DATATYPE_NUMERIC;\r\n\t\t}\r\n\t\treturn self::C_DATATYPE_TEXT;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a column of a given type to a table\r\n\t *\r\n\t * @param string  $table  table\r\n\t * @param string  $column column\r\n\t * @param integer $type\t  type\r\n\t */\r\n\tpublic function addColumn( $table, $column, $type) {\r\n\t\t$column = $this->check($column);\r\n\t\t$table = $this->check($table);\r\n\t\t$type=$this->typeno_sqltype[$type];\r\n\t\t$sql = \"ALTER TABLE `$table` ADD `$column` $type \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Type Code for a Column Description.\r\n\t * Given an SQL column description this method will return the corresponding\r\n\t * code for the writer. If the include specials flag is set it will also\r\n\t * return codes for special columns. Otherwise special columns will be identified\r\n\t * as specified columns.\r\n\t *\r\n\t * @param string  $typedescription description\r\n\t * @param boolean $includeSpecials whether you want to get codes for special columns as well\r\n\t *\r\n\t * @return integer $typecode code\r\n\t */\r\n\tpublic function code( $typedescription, $includeSpecials = false ) {\r\n\t\t$r =  ((isset($this->sqltype_typeno[$typedescription])) ? $this->sqltype_typeno[$typedescription] : 99);\r\n\t\tif ($includeSpecials) return $r;\r\n\t\tif ($r > self::C_DATATYPE_SPECIFIED) return self::C_DATATYPE_SPECIFIED;\r\n\t\treturn $r;\r\n\t}\r\n\r\n\r\n\r\n\r\n\t/**\r\n\t * Gets all information about a table (from a type).\r\n\t * \r\n\t * Format:\r\n\t * array(\r\n\t *\t\tname => name of the table\r\n\t *\t\tcolumns => array( name => datatype )\r\n\t *\t\tindexes => array() raw index information rows from PRAGMA query\r\n\t *\t\tkeys => array() raw key information rows from PRAGMA query\r\n\t * )\r\n\t * \r\n\t * @param string $type type you want to get info of\r\n\t * \r\n\t * @return array $info \r\n\t */\r\n\tprotected function getTable($type) {\r\n\t\t$tableName = $this->safeTable($type,true);\r\n\t\t$columns = $this->getColumns($type);\r\n\t\t$indexes = $this->getIndexes($type);\r\n\t\t$keys = $this->getKeys($type);\r\n\t\t$table = array('columns'=>$columns,'indexes'=>$indexes,'keys'=>$keys,'name'=>$tableName);\r\n\t\t$this->tableArchive[$tableName] = $table;\r\n\t\treturn $table;\r\n\t}\r\n\r\n\t/**\r\n\t * Puts a table. Updates the table structure.\r\n\t * In SQLite we can't change columns, drop columns, change or add foreign keys so we\r\n\t * have a table-rebuild function. You simply load your table with getTable(), modify it and\r\n\t * then store it with putTable()...\r\n\t * \r\n\t * @param array $tableMap information array \r\n\t */\r\n\tprotected function putTable($tableMap) {\r\n\t\t$table = $tableMap['name'];\r\n\t\t$q = array();\r\n\t\t$q[] = \"DROP TABLE IF EXISTS tmp_backup;\";\r\n\t\t$oldColumnNames = array_keys($this->getColumns($table));\r\n\t\tforeach($oldColumnNames as $k=>$v) $oldColumnNames[$k] = \"`$v`\";\r\n\t\t$q[] = \"CREATE TEMPORARY TABLE tmp_backup(\".implode(\",\",$oldColumnNames).\");\";\r\n\t\t$q[] = \"INSERT INTO tmp_backup SELECT * FROM `$table`;\";\r\n\t\t$q[] = \"PRAGMA foreign_keys = 0 \";\r\n\t\t$q[] = \"DROP TABLE `$table`;\";\r\n\t\t$newTableDefStr = '';\r\n\t\tforeach($tableMap['columns'] as $column=>$type) {\r\n\t\t\tif ($column != 'id') {\r\n\t\t\t\t$newTableDefStr .= \",`$column` $type\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t$fkDef = '';\r\n\t\tforeach($tableMap['keys'] as $key) {\r\n\t\t\t$fkDef .= \", FOREIGN KEY(`{$key['from']}`) \r\n\t\t\t\t\t\t REFERENCES `{$key['table']}`(`{$key['to']}`) \r\n\t\t\t\t\t\t ON DELETE {$key['on_delete']} ON UPDATE {$key['on_update']}\";\r\n\t\t}\r\n\t\t$q[] = \"CREATE TABLE `$table` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT  $newTableDefStr  $fkDef );\";\r\n\t\tforeach($tableMap['indexes'] as $name=>$index)  {\r\n\t\t\tif (strpos($name,'UQ_')===0) {\r\n\t\t\t\t$cols = explode('__',substr($name,strlen('UQ_'.$table)));\r\n\t\t\t\tforeach($cols as $k=>$v) $cols[$k] = \"`$v`\";\r\n\t\t\t\t$q[] = \"CREATE UNIQUE INDEX $name ON `$table` (\".implode(',',$cols).\")\";\r\n\t\t\t}\r\n\t\t\telse $q[] = \"CREATE INDEX $name ON `$table` ({$index['name']}) \";\r\n\t\t}\r\n\t\t$q[] = \"INSERT INTO `$table` SELECT * FROM tmp_backup;\";\r\n\t\t$q[] = \"DROP TABLE tmp_backup;\";\r\n\t\t$q[] = \"PRAGMA foreign_keys = 1 \";\r\n\t\tforeach($q as $sq) $this->adapter->exec($sq);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * This method upgrades the column to the specified data type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type       type / table that needs to be adjusted\r\n\t * @param string  $column     column that needs to be altered\r\n\t * @param integer $datatype   target data type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function widenColumn( $type, $column, $datatype ) {\r\n\t\t$t = $this->getTable($type);\r\n\t\t$t['columns'][$column] = $this->typeno_sqltype[$datatype];\r\n\t\t$this->putTable($t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns all tables in the database\r\n\t *\r\n\t * @return array $tables tables\r\n\t */\r\n\tpublic function getTables() {\r\n\t\treturn $this->adapter->getCol( \"SELECT name FROM sqlite_master\r\n\t\t\tWHERE type='table' AND name!='sqlite_sequence';\" );\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an empty, column-less table for a bean.\r\n\t *\r\n\t * @param string $table table\r\n\t */\r\n\tpublic function createTable( $table ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \"CREATE TABLE $table ( id INTEGER PRIMARY KEY AUTOINCREMENT ) \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array containing the column names of the specified table.\r\n\t *\r\n\t * @param string $table table\r\n\t *\r\n\t * @return array $columns columns\r\n\t */\r\n\tpublic function getColumns( $table ) {\r\n\t\t$table = $this->safeTable($table, true);\r\n\t\t$columnsRaw = $this->adapter->get(\"PRAGMA table_info('$table')\");\r\n\t\t$columns = array();\r\n\t\tforeach($columnsRaw as $r) {\r\n\t\t\t$columns[$r['name']]=$r['type'];\r\n\t\t}\r\n\t\treturn $columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the indexes for type $type.\r\n\t * \r\n\t * @param string $type\r\n\t * \r\n\t * @return array $indexInfo index information\r\n\t */\r\n\tprotected function getIndexes($type) {\r\n\t\t$table = $this->safeTable($type, true);\r\n\t\t$indexes = $this->adapter->get(\"PRAGMA index_list('$table')\");\r\n\t\t$indexInfoList = array();\r\n\t\tforeach($indexes as $i) {\r\n\t\t\t$indexInfoList[$i['name']] = $this->adapter->getRow(\"PRAGMA index_info('{$i['name']}') \");\r\n\t\t\t$indexInfoList[$i['name']]['unique'] = $i['unique'];\r\n\t\t}\r\n\t\treturn $indexInfoList;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys for type $type.\r\n\t * \r\n\t * @param string $type\r\n\t * \r\n\t * @return array $keysInfo keys information\r\n\t */\r\n\tprotected function getKeys($type) {\r\n\t\t$table = $this->safeTable($type,true);\r\n\t\t$keys = $this->adapter->get(\"PRAGMA foreign_key_list('$table')\");\r\n\t\t$keyInfoList = array();\r\n\t\tforeach($keys as $k) {\r\n\t\t\t$keyInfoList['from_'.$k['from'].'_to_table_'.$k['table'].'_col_'.$k['to']] = $k;\r\n\t\t}\r\n\t\treturn $keyInfoList;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a Unique index constrain to the table.\r\n\t *\r\n\t * @param string $table   table\r\n\t * @param string $column1 first column\r\n\t * @param string $column2 second column\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addUniqueIndex( $type,$columns ) {\r\n\t\t$table = $this->safeTable($type,true);\r\n\t\t$name = 'UQ_'.$table.implode('__',$columns);\r\n\t\t$t = $this->getTable($type);\r\n\t\tif (isset($t['indexes'][$name])) return;\r\n\t\t$t['indexes'][$name] = array('name'=>$name);\r\n\t\t$this->putTable($t);\r\n\t}\r\n\r\n\t/**\r\n\t * Given an Database Specific SQLState and a list of QueryWriter\r\n\t * Standard SQL States this function converts the raw SQL state to a\r\n\t * database agnostic ANSI-92 SQL states and checks if the given state\r\n\t * is in the list of agnostic states.\r\n\t *\r\n\t * @param string $state state\r\n\t * @param array  $list  list of states\r\n\t *\r\n\t * @return boolean $isInArray whether state is in list\r\n\t */\r\n\tpublic function sqlStateIn($state, $list) {\r\n\t\t$stateMap = array(\r\n\t\t\t'HY000'=>RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE,\r\n\t\t\t'23000'=>RedBean_QueryWriter::C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION\r\n\t\t);\r\n\t\treturn in_array((isset($stateMap[$state]) ? $stateMap[$state] : '0'),$list);\r\n\t}\r\n\r\n\t/**\r\n\t * This method should add an index to a type and field with name\r\n\t * $name.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  $type   type to add index to\r\n\t * @param  $name   name of the new index\r\n\t * @param  $column field to index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addIndex($type, $name, $column) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$name = preg_replace('/\\W/','',$name);\r\n\t\t$column = $this->safeColumn($column,true);\r\n\t\tforeach( $this->adapter->get(\"PRAGMA INDEX_LIST($table) \") as $ind) {\r\n\t\t\tif ($ind['name']===$name) return;\r\n\t\t}\r\n\t\t$t = $this->getTable($type);\r\n\t\t$t['indexes'][$name] = array('name'=>$column);\r\n\t\treturn $this->putTable($t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Counts rows in a table.\r\n\t * Uses SQLite optimization for deleting all records (i.e. no WHERE)\r\n\t *\r\n\t * @param string $beanType\r\n\t *\r\n\t * @return integer $numRowsFound\r\n\t */\r\n\tpublic function wipe($type) {\r\n\t\t$table = $this->safeTable($type);\r\n\t\t$this->adapter->exec(\"DELETE FROM $table\");\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a foreign key to a type\r\n\t *\r\n\t * @param string  $type        type you want to modify table of\r\n\t * @param string  $targetType  target type\r\n\t * @param string  $field       field of the type that needs to get the fk\r\n\t * @param string  $targetField field where the fk needs to point to\r\n\t * @param boolean $isDep       whether this field is dependent on it's referenced record\r\n\t *\r\n\t * @return bool $success whether an FK has been added\r\n\t */\r\n\tpublic function addFK( $type, $targetType, $field, $targetField, $isDep=false) {\r\n\t\treturn $this->buildFK($type, $targetType, $field, $targetField, $isDep);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a foreign key to a type\r\n\t *\r\n\t * @param  string $type        type you want to modify table of\r\n\t * @param  string $targetType  target type\r\n\t * @param  string $field       field of the type that needs to get the fk\r\n\t * @param  string $targetField field where the fk needs to point to\r\n\t * @param  integer $buildopt   0 = NO ACTION, 1 = ON DELETE CASCADE\r\n\t *\r\n\t * @return boolean $didIt\r\n\t * \r\n\t * @note: cant put this in try-catch because that can hide the fact\r\n\t * that database has been damaged. \r\n\t */\r\n\r\n\tprotected function buildFK($type, $targetType, $field, $targetField,$constraint=false) {\r\n\t\t$consSQL = ($constraint ? 'CASCADE' : 'SET NULL');\r\n\t\t$t = $this->getTable($type);\r\n\t\t$label = 'from_'.$field.'_to_table_'.$targetType.'_col_'.$targetField;\r\n\t\tif (isset($t['keys'][$label]) \r\n\t\t\t\t&& $t['keys'][$label]['table']===$targetType \r\n\t\t\t\t&& $t['keys'][$label]['from']===$field\r\n\t\t\t\t&& $t['keys'][$label]['to']===$targetField\r\n\t\t\t\t&& $t['keys'][$label]['on_delete']===$consSQL\r\n\t\t) return false;\r\n\r\n\t\t$t['keys'][$label] = array(\r\n\t\t\t'table' => $targetType,\r\n\t\t\t'from' => $field,\r\n\t\t\t'to' => $targetField,\r\n\t\t\t'on_update' => 'SET NULL',\r\n\t\t\t'on_delete' => $consSQL\r\n\t\t);\r\n\t\t$this->putTable($t);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add the constraints for a specific database driver: SQLite.\r\n\t * @todo Too many arguments; find a way to solve this in a neater way.\r\n\t *\r\n\t * @param string\t\t\t  $table     table\r\n\t * @param string\t\t\t  $table1    table1\r\n\t * @param string\t\t\t  $table2    table2\r\n\t * @param string\t\t\t  $property1 property1\r\n\t * @param string\t\t\t  $property2 property2\r\n\t *\r\n\t * @return boolean $succes whether the constraint has been applied\r\n\t */\r\n\tprotected  function constrain($table, $table1, $table2, $property1, $property2) {\r\n\t\t$writer = $this;\r\n\t\t$adapter = $this->adapter;\r\n\t\t$firstState = $this->buildFK($table,$table1,$property1,'id',true);\r\n\t\t$secondState = $this->buildFK($table,$table2,$property2,'id',true);\r\n\t\treturn ($firstState && $secondState);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all tables and views from the database.\r\n\t * \r\n\t * @return void\r\n\t */\r\n\tpublic function wipeAll() {\r\n\t\t$this->adapter->exec('PRAGMA foreign_keys = 0 ');\r\n\t\tforeach($this->getTables() as $t) {\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop table if exists`$t`\");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){}\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop view if exists`$t`\");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){}\r\n\t\t}\r\n\t\t$this->adapter->exec('PRAGMA foreign_keys = 1 ');\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean PostgreSQL Query Writer\r\n * \r\n * @file\t\t\tRedBean/QueryWriter/PostgreSQL.php\r\n * @description\t\tQueryWriter for the PostgreSQL database system.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_QueryWriter_PostgreSQL extends RedBean_QueryWriter_AQueryWriter implements RedBean_QueryWriter {\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Integer Data Type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_INTEGER = 0;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Double Precision Type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_DOUBLE = 1;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * String Data Type\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_TEXT = 3;\r\n\r\n\r\n\t/**\r\n\t * Special type date for storing date values: YYYY-MM-DD\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIAL_DATE = 80;\r\n\r\n\t/**\r\n\t * Special type date for storing date values: YYYY-MM-DD HH:MM:SS\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIAL_DATETIME = 81;\r\n\r\n\tconst C_DATATYPE_SPECIAL_POINT\t\t= 101;\r\n\tconst C_DATATYPE_SPECIAL_LINE\t\t= 102;\r\n\tconst C_DATATYPE_SPECIAL_LSEG\t\t= 103;\r\n\tconst C_DATATYPE_SPECIAL_BOX\t\t= 104;\r\n\tconst C_DATATYPE_SPECIAL_CIRCLE\t\t= 105;\r\n\tconst C_DATATYPE_SPECIAL_POLYGON\t= 106;\r\n\r\n\r\n\r\n\t/**\r\n\t * Specified field type cannot be overruled\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIFIED = 99;\r\n\r\n\r\n\t/**\r\n\t * Holds Database Adapter\r\n\t * @var RedBean_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * character to escape keyword table/column names\r\n\t * @var string\r\n\t */\r\n\tprotected $quoteCharacter = '\"';\r\n\r\n\t/**\r\n\t * Default Value\r\n\t * @var string\r\n\t */\r\n\tprotected $defaultValue = 'DEFAULT';\r\n\r\n\t/**\r\n\t* This method returns the datatype to be used for primary key IDS and\r\n\t* foreign keys. Returns one if the data type constants.\r\n\t*\r\n\t* @return integer $const data type to be used for IDS.\r\n\t*/\r\n\tpublic function getTypeForID() {\r\n\t\treturn self::C_DATATYPE_INTEGER;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the insert suffix SQL Snippet\r\n\t *\r\n\t * @param string $table table\r\n\t *\r\n\t * @return  string $sql SQL Snippet\r\n\t */\r\n\tprotected function getInsertSuffix($table) {\r\n\t\treturn 'RETURNING id ';\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * The Query Writer Constructor also sets up the database\r\n\t *\r\n\t * @param RedBean_DBAdapter $adapter adapter\r\n\t */\r\n\tpublic function __construct( RedBean_Adapter $adapter ) {\r\n\r\n\r\n\t\t$this->typeno_sqltype = array(\r\n\t\t\t\t  self::C_DATATYPE_INTEGER=>' integer ',\r\n\t\t\t\t  self::C_DATATYPE_DOUBLE=>' double precision ',\r\n\t\t\t\t  self::C_DATATYPE_TEXT=>' text ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_DATE => ' date ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_DATETIME => ' timestamp without time zone ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_POINT => ' point ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_LINE => ' line ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_LSEG => ' lseg ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_BOX => ' box ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_CIRCLE => ' circle ',\r\n\t\t\t\t  self::C_DATATYPE_SPECIAL_POLYGON => ' polygon ',\r\n\r\n\t\t);\r\n\r\n\t\t$this->sqltype_typeno = array();\r\n\t\tforeach($this->typeno_sqltype as $k=>$v)\r\n\t\t$this->sqltype_typeno[trim(strtolower($v))]=$k;\r\n\r\n\r\n\t\t$this->adapter = $adapter;\r\n\t\tparent::__construct();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all tables in the database\r\n\t *\r\n\t * @return array $tables tables\r\n\t */\r\n\tpublic function getTables() {\r\n\t\treturn $this->adapter->getCol( \"select table_name from information_schema.tables\r\n\t\twhere table_schema = 'public'\" );\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an empty, column-less table for a bean.\r\n\t *\r\n\t * @param string $table table to create\r\n\t */\r\n\tpublic function createTable( $table ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \" CREATE TABLE $table (id SERIAL PRIMARY KEY); \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array containing the column names of the specified table.\r\n\t *\r\n\t * @param string $table table to get columns from\r\n\t *\r\n\t * @return array $columns array filled with column (name=>type)\r\n\t */\r\n\tpublic function getColumns( $table ) {\r\n\t\t$table = $this->safeTable($table, true);\r\n\t\t$columnsRaw = $this->adapter->get(\"select column_name, data_type from information_schema.columns where table_name='$table'\");\r\n\t\tforeach($columnsRaw as $r) {\r\n\t\t\t$columns[$r['column_name']]=$r['data_type'];\r\n\t\t}\r\n\t\treturn $columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the pgSQL Column Type Code (integer) that corresponds\r\n\t * to the given value type.\r\n\t *\r\n\t * @param string $value value to determine type of\r\n\t *\r\n\t * @return integer $type type code for this value\r\n\t */\r\n\tpublic function scanType( $value, $flagSpecial=false ) {\r\n\r\n\t\t$this->svalue=$value;\r\n\r\n\t\tif ($flagSpecial && $value) {\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d$/',$value)) {\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_DATE;\r\n\t\t\t}\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d\\s\\d\\d:\\d\\d:\\d\\d(\\.\\d{1,6})?$/',$value)) {\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_DATETIME;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'POINT(')===0) {\r\n\t\t\t\t$this->svalue = str_replace('POINT','',$value);\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_POINT;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'LSEG(')===0) {\r\n\t\t\t\t$this->svalue = str_replace('LSEG','',$value);\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_LSEG;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'BOX(')===0) {\r\n\t\t\t\t$this->svalue = str_replace('BOX','',$value);\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_BOX;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'CIRCLE(')===0) {\r\n\t\t\t\t$this->svalue = str_replace('CIRCLE','',$value);\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_CIRCLE;\r\n\t\t\t}\r\n\t\t\tif (strpos($value,'POLYGON(')===0) {\r\n\t\t\t\t$this->svalue = str_replace('POLYGON','',$value);\r\n\t\t\t\treturn RedBean_QueryWriter_PostgreSQL::C_DATATYPE_SPECIAL_POLYGON;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t$sz = ($this->startsWithZeros($value));\r\n\t\tif ($sz) return self::C_DATATYPE_TEXT;\r\n\t\tif ($value===null || ($value instanceof RedBean_Driver_PDO_NULL) ||(is_numeric($value)\r\n\t\t\t\t  && floor($value)==$value\r\n\t\t\t\t  && $value < 2147483648\r\n\t\t\t\t  && $value > -2147483648)) {\r\n\t\t\treturn self::C_DATATYPE_INTEGER;\r\n\t\t}\r\n\t\telseif(is_numeric($value)) {\r\n\t\t\treturn self::C_DATATYPE_DOUBLE;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn self::C_DATATYPE_TEXT;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Type Code for a Column Description.\r\n\t * Given an SQL column description this method will return the corresponding\r\n\t * code for the writer. If the include specials flag is set it will also\r\n\t * return codes for special columns. Otherwise special columns will be identified\r\n\t * as specified columns.\r\n\t *\r\n\t * @param string  $typedescription description\r\n\t * @param boolean $includeSpecials whether you want to get codes for special columns as well\r\n\t *\r\n\t * @return integer $typecode code\r\n\t */\r\n\tpublic function code( $typedescription, $includeSpecials = false ) {\r\n\t\t$r = ((isset($this->sqltype_typeno[$typedescription])) ? $this->sqltype_typeno[$typedescription] : 99);\r\n\t\tif ($includeSpecials) return $r;\r\n\t\tif ($r > self::C_DATATYPE_SPECIFIED) return self::C_DATATYPE_SPECIFIED;\r\n\t\treturn $r;\r\n\t}\r\n\r\n\t/**\r\n\t * This method upgrades the column to the specified data type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type       type / table that needs to be adjusted\r\n\t * @param string  $column     column that needs to be altered\r\n\t * @param integer $datatype   target data type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function widenColumn( $type, $column, $datatype ) {\r\n\t\t$table = $type;\r\n\t\t$type = $datatype;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$newtype = $this->typeno_sqltype[$type];\r\n\t\t$changecolumnSQL = \"ALTER TABLE $table \\n\\t ALTER COLUMN $column TYPE $newtype \";\r\n\t\t$this->adapter->exec( $changecolumnSQL );\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a Unique index constrain to the table.\r\n\t *\r\n\t * @param string $table table to add index to\r\n\t * @param string $col1  column to be part of index\r\n\t * @param string $col2  column 2 to be part of index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addUniqueIndex( $table,$columns ) {\r\n\t\t$table = $this->safeTable($table, true);\r\n\t\tsort($columns); //else we get multiple indexes due to order-effects\r\n\t\tforeach($columns as $k=>$v) {\r\n\t\t\t$columns[$k]=$this->safeColumn($v);\r\n\t\t}\r\n\t\t$r = $this->adapter->get(\"SELECT\r\n\t\t\t\t\t\t\t\t\ti.relname as index_name\r\n\t\t\t\t\t\t\t\tFROM\r\n\t\t\t\t\t\t\t\t\tpg_class t,\r\n\t\t\t\t\t\t\t\t\tpg_class i,\r\n\t\t\t\t\t\t\t\t\tpg_index ix,\r\n\t\t\t\t\t\t\t\t\tpg_attribute a\r\n\t\t\t\t\t\t\t\tWHERE\r\n\t\t\t\t\t\t\t\t\tt.oid = ix.indrelid\r\n\t\t\t\t\t\t\t\t\tAND i.oid = ix.indexrelid\r\n\t\t\t\t\t\t\t\t\tAND a.attrelid = t.oid\r\n\t\t\t\t\t\t\t\t\tAND a.attnum = ANY(ix.indkey)\r\n\t\t\t\t\t\t\t\t\tAND t.relkind = 'r'\r\n\t\t\t\t\t\t\t\t\tAND t.relname = '$table'\r\n\t\t\t\t\t\t\t\tORDER BY  t.relname,  i.relname;\");\r\n\r\n\t\t$name = \"UQ_\".sha1($table.implode(',',$columns));\r\n\t\tif ($r) {\r\n\t\t\tforeach($r as $i) {\r\n\t\t\t\tif (strtolower( $i['index_name'] )== strtolower( $name )) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$sql = \"ALTER TABLE \\\"$table\\\"\r\n                ADD CONSTRAINT $name UNIQUE (\".implode(',',$columns).\")\";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\r\n\r\n\t/**\r\n\t * Given an Database Specific SQLState and a list of QueryWriter\r\n\t * Standard SQL States this function converts the raw SQL state to a\r\n\t * database agnostic ANSI-92 SQL states and checks if the given state\r\n\t * is in the list of agnostic states.\r\n\t *\r\n\t * @param string $state state\r\n\t * @param array  $list  list of states\r\n\t *\r\n\t * @return boolean $isInArray whether state is in list\r\n\t */\r\n\tpublic function sqlStateIn($state, $list) {\r\n\t\t$stateMap = array(\r\n\t\t\t'42P01'=>RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE,\r\n\t\t\t'42703'=>RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\t'23505'=>RedBean_QueryWriter::C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION\r\n\t\t);\r\n\t\treturn in_array((isset($stateMap[$state]) ? $stateMap[$state] : '0'),$list);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This method should add an index to a type and field with name\r\n\t * $name.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  $type   type to add index to\r\n\t * @param  $name   name of the new index\r\n\t * @param  $column field to index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addIndex($type, $name, $column) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$name = preg_replace('/\\W/','',$name);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\tif ($this->adapter->getCell(\"SELECT COUNT(*) FROM pg_class WHERE relname = '$name'\")) return;\r\n\t\ttry{ $this->adapter->exec(\"CREATE INDEX $name ON $table ($column) \"); }catch(Exception $e){}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a foreign key to a table. The foreign key will not have any action; you\r\n\t * may configure this afterwards.\r\n\t *\r\n\t * @param  string $type        type you want to modify table of\r\n\t * @param  string $targetType  target type\r\n\t * @param  string $field       field of the type that needs to get the fk\r\n\t * @param  string $targetField field where the fk needs to point to\r\n\t *\r\n\t * @return bool $success whether an FK has been added\r\n\t */\r\n\tpublic function addFK( $type, $targetType, $field, $targetField, $isDep = false) {\r\n\t\ttry{\r\n\t\t\t$table = $this->safeTable($type);\r\n\t\t\t$column = $this->safeColumn($field);\r\n\t\t\t$tableNoQ = $this->safeTable($type,true);\r\n\t\t\t$columnNoQ = $this->safeColumn($field,true);\r\n\t\t\t$targetTable = $this->safeTable($targetType);\r\n\t\t\t$targetTableNoQ = $this->safeTable($targetType,true);\r\n\t\t\t$targetColumn  = $this->safeColumn($targetField);\r\n\t\t\t$targetColumnNoQ  = $this->safeColumn($targetField,true);\r\n\r\n\r\n\t\t\t$sql = \"SELECT\r\n\t\t\t\t\ttc.constraint_name, \r\n\t\t\t\t\ttc.table_name, \r\n\t\t\t\t\tkcu.column_name, \r\n\t\t\t\t\tccu.table_name AS foreign_table_name,\r\n\t\t\t\t\tccu.column_name AS foreign_column_name,\r\n\t\t\t\t\trc.delete_rule\r\n\t\t\t\t\tFROM \r\n\t\t\t\t\tinformation_schema.table_constraints AS tc \r\n\t\t\t\t\tJOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name\r\n\t\t\t\t\tJOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name\r\n\t\t\t\t\tJOIN information_schema.referential_constraints AS rc ON ccu.constraint_name = rc.constraint_name\r\n\t\t\t\t\tWHERE constraint_type = 'FOREIGN KEY' AND tc.table_catalog=current_database()\r\n\t\t\t\t\tAND tc.table_name = '$tableNoQ' \r\n\t\t\t\t\tAND ccu.table_name = '$targetTableNoQ'\r\n\t\t\t\t\tAND kcu.column_name = '$columnNoQ'\r\n\t\t\t\t\tAND ccu.column_name = '$targetColumnNoQ'\r\n\t\t\t\t\t\";\r\n\r\n\r\n\t\t\t$row = $this->adapter->getRow($sql);\r\n\r\n\t\t\t$flagAddKey = false;\r\n\r\n\t\t\tif (!$row) $flagAddKey = true;\r\n\r\n\t\t\tif ($row) { \r\n\t\t\t\tif (($row['delete_rule']=='SET NULL' && $isDep) || \r\n\t\t\t\t\t($row['delete_rule']!='SET NULL' && !$isDep)) {\r\n\t\t\t\t\t//delete old key\r\n\t\t\t\t\t$flagAddKey = true; //and order a new one\r\n\t\t\t\t\t$cName = $row['constraint_name'];\r\n\t\t\t\t\t$sql = \"ALTER TABLE $table DROP CONSTRAINT $cName \";\r\n\t\t\t\t\t$this->adapter->exec($sql);\r\n\t\t\t\t} \r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ($flagAddKey) {\r\n\t\t\t$delRule = ($isDep ? 'CASCADE' : 'SET NULL');\t\r\n\t\t\t$this->adapter->exec(\"ALTER TABLE  $table\r\n\t\t\t\t\tADD FOREIGN KEY (  $column ) REFERENCES  $targetTable (\r\n\t\t\t\t\t$targetColumn) ON DELETE $delRule ON UPDATE SET NULL DEFERRABLE ;\");\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tcatch(Exception $e){ return false; }\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Add the constraints for a specific database driver: PostgreSQL.\r\n\t * @todo Too many arguments; find a way to solve this in a neater way.\r\n\t *\r\n\t * @param string\t\t\t  $table     table\r\n\t * @param string\t\t\t  $table1    table1\r\n\t * @param string\t\t\t  $table2    table2\r\n\t * @param string\t\t\t  $property1 property1\r\n\t * @param string\t\t\t  $property2 property2\r\n\t *\r\n\t * @return boolean $succes whether the constraint has been applied\r\n\t */\r\n\tprotected function constrain($table, $table1, $table2, $property1, $property2) {\r\n\t\ttry{\r\n\t\t\t$writer = $this;\r\n\t\t\t$adapter = $this->adapter;\r\n\t\t\t$fkCode = 'fk'.md5($table.$property1.$property2);\r\n\t\t\t$sql = \"\r\n\t\t\t\t\t\tSELECT\r\n\t\t\t\t\t\t\t\tc.oid,\r\n\t\t\t\t\t\t\t\tn.nspname,\r\n\t\t\t\t\t\t\t\tc.relname,\r\n\t\t\t\t\t\t\t\tn2.nspname,\r\n\t\t\t\t\t\t\t\tc2.relname,\r\n\t\t\t\t\t\t\t\tcons.conname\r\n\t\t\t\t\t\tFROM pg_class c\r\n\t\t\t\t\t\tJOIN pg_namespace n ON n.oid = c.relnamespace\r\n\t\t\t\t\t\tLEFT OUTER JOIN pg_constraint cons ON cons.conrelid = c.oid\r\n\t\t\t\t\t\tLEFT OUTER JOIN pg_class c2 ON cons.confrelid = c2.oid\r\n\t\t\t\t\t\tLEFT OUTER JOIN pg_namespace n2 ON n2.oid = c2.relnamespace\r\n\t\t\t\t\t\tWHERE c.relkind = 'r'\r\n\t\t\t\t\t\tAND n.nspname IN ('public')\r\n\t\t\t\t\t\tAND (cons.contype = 'f' OR cons.contype IS NULL)\r\n\t\t\t\t\t\tAND\r\n\t\t\t\t\t\t(  cons.conname = '{$fkCode}a'\tOR  cons.conname = '{$fkCode}b' )\r\n\r\n\t\t\t\t\t  \";\r\n\r\n\t\t\t$rows = $adapter->get( $sql );\r\n\t\t\tif (!count($rows)) {\r\n\t\t\t\t$sql1 = \"ALTER TABLE \\\"$table\\\" ADD CONSTRAINT\r\n\t\t\t\t\t\t  {$fkCode}a FOREIGN KEY ($property1)\r\n\t\t\t\t\t\t\tREFERENCES \\\"$table1\\\" (id) ON DELETE CASCADE \";\r\n\t\t\t\t$sql2 = \"ALTER TABLE \\\"$table\\\" ADD CONSTRAINT\r\n\t\t\t\t\t\t  {$fkCode}b FOREIGN KEY ($property2)\r\n\t\t\t\t\t\t\tREFERENCES \\\"$table2\\\" (id) ON DELETE CASCADE \";\r\n\t\t\t\t$adapter->exec($sql1);\r\n\t\t\t\t$adapter->exec($sql2);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(Exception $e){ return false; }\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all tables and views from the database.\r\n\t */\r\n\tpublic function wipeAll() {\r\n      \t$this->adapter->exec('SET CONSTRAINTS ALL DEFERRED');\r\n      \tforeach($this->getTables() as $t) {\r\n      \t\t$t = $this->noKW($t);\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop table if exists $t CASCADE \");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){  }\r\n\t \t\ttry{\r\n\t \t\t\t$this->adapter->exec(\"drop view if exists $t CASCADE \");\r\n\t \t\t}\r\n\t \t\tcatch(Exception $e){  throw $e; }\r\n\t\t}\r\n\t\t$this->adapter->exec('SET CONSTRAINTS ALL IMMEDIATE');\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * This method removes all beans of a certain type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  string $type bean type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function wipe($type) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$sql = \"TRUNCATE $table CASCADE\";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean CUBRID Writer \r\n *\r\n * @file\t\t\t\tRedBean/QueryWriter/CUBRID.php\r\n * @description\t\t\tRepresents a CUBRID Database to RedBean\r\n *\t\t\t\t\t\tTo write a driver for a different database for RedBean\r\n *\t\t\t\t\t\tyou should only have to change this file.\r\n * @author\t\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\t\tBSD/GPLv2\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n \r\n */\r\nclass RedBean_QueryWriter_CUBRID extends RedBean_QueryWriter_AQueryWriter implements RedBean_QueryWriter {\r\n\r\n\r\n\t/**\r\n\t * Here we describe the datatypes that RedBean\r\n\t * Uses internally. If you write a QueryWriter for\r\n\t * RedBean you should provide a list of types like this.\r\n\t */\r\n\r\n\t/**\r\n\t *\r\n\t * DATA TYPE\r\n\t * Signed 4 byte Integer\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_INTEGER = 0;\r\n\r\n\t/**\r\n\t * DATA TYPE\r\n\t * Double precision floating point number\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_DOUBLE = 1;\r\n\r\n\t/**\r\n\t *\r\n\t * DATA TYPE\r\n\t * Variable length text\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_STRING = 2;\r\n\r\n\r\n\t/**\r\n\t * Special type date for storing date values: YYYY-MM-DD\r\n\t * @var integer\r\n\t */\t\r\n\tconst C_DATATYPE_SPECIAL_DATE = 80;\r\n\r\n\t/**\r\n\t * Special type datetime for store date-time values: YYYY-MM-DD HH:II:SS\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIAL_DATETIME = 81;\r\n\r\n\r\n\t/**\r\n\t * \r\n\t * DATA TYPE\r\n\t * Specified. This means the developer or DBA\r\n\t * has altered the column to a different type not\r\n\t * recognized by RedBean. This high number makes sure\r\n\t * it will not be converted back to another type by accident.\r\n\t * @var integer\r\n\t */\r\n\tconst C_DATATYPE_SPECIFIED = 99;\r\n\r\n\r\n\r\n\t/**\r\n\t * Holds the RedBean Database Adapter.\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * character to escape keyword table/column names\r\n\t * @var string\r\n\t */\r\n  \tprotected $quoteCharacter = '`';\r\n\r\n\t/**\r\n\t * Do everything that needs to be done to format a table name.\r\n\t *\r\n\t * @param string $name of table\r\n\t *\r\n\t * @return string table name\r\n\t */\r\n\tpublic function safeTable($name, $noQuotes = false) {\r\n\t\t$name = strtolower($name);\r\n\t\t$name = $this->check($name);\r\n\t\tif (!$noQuotes) $name = $this->noKW($name);\r\n\t\treturn $name;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Do everything that needs to be done to format a column name.\r\n\t *\r\n\t * @param string $name of column\r\n\t *\r\n\t * @return string $column name\r\n\t */\r\n\tpublic function safeColumn($name, $noQuotes = false) {\r\n\t\t$name = strtolower($name);\r\n\t\t$name = $this->check($name);\r\n\t\tif (!$noQuotes) $name = $this->noKW($name);\r\n\t\treturn $name;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * The Query Writer Constructor also sets up the database.\r\n\t *\r\n\t * @param RedBean_Adapter_DBAdapter $adapter adapter\r\n\t *\r\n\t */\r\n\tpublic function __construct( RedBean_Adapter $adapter ) {\r\n\r\n\t\t$this->typeno_sqltype = array(\r\n\t\t\tRedBean_QueryWriter_CUBRID::C_DATATYPE_INTEGER => ' INTEGER ',\r\n\t\t\tRedBean_QueryWriter_CUBRID::C_DATATYPE_DOUBLE => ' DOUBLE ',\r\n\t\t\tRedBean_QueryWriter_CUBRID::C_DATATYPE_STRING => ' STRING ',\r\n\t\t\tRedBean_QueryWriter_CUBRID::C_DATATYPE_SPECIAL_DATE => ' DATE ',\r\n\t\t\tRedBean_QueryWriter_CUBRID::C_DATATYPE_SPECIAL_DATETIME => ' DATETIME ',\r\n\t\t);\r\n\r\n\t\t$this->sqltype_typeno = array();\r\n\t\tforeach($this->typeno_sqltype as $k=>$v)\r\n\t\t$this->sqltype_typeno[trim(($v))]=$k;\r\n\t\t$this->sqltype_typeno['STRING(1073741823)'] = self::C_DATATYPE_STRING;\r\n\r\n\t\t$this->adapter = $adapter;\r\n\t\tparent::__construct();\r\n\t}\r\n\r\n\t/**\r\n\t * This method returns the datatype to be used for primary key IDS and\r\n\t * foreign keys. Returns one if the data type constants.\r\n\t *\r\n\t * @return integer $const data type to be used for IDS.\r\n\t */\r\n\tpublic function getTypeForID() {\r\n\t\treturn self::C_DATATYPE_INTEGER;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all tables in the database.\r\n\t *\r\n\t * @return array $tables tables\r\n\t */\r\n\tpublic function getTables() { \r\n\t\t$rows = $this->adapter->getCol( \"SELECT class_name FROM db_class WHERE is_system_class = 'NO';\" );\r\n\t\treturn $rows;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an empty, column-less table for a bean based on it's type.\r\n\t * This function creates an empty table for a bean. It uses the\r\n\t * safeTable() function to convert the type name to a table name.\r\n\t *\r\n\t * @param string $table type of bean you want to create a table for\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function createTable( $table ) {\r\n\t\t$rawTable = $this->safeTable($table,true);\r\n\t\t$table = $this->safeTable($table);\r\n\r\n\t\t$sql = '     CREATE TABLE '.$table.' (\r\n                     \"id\" integer AUTO_INCREMENT,\r\n\t\t\t\t\t CONSTRAINT \"pk_'.$rawTable.'_id\" PRIMARY KEY(\"id\")\r\n\t\t             )';\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Returns an array containing the column names of the specified table.\r\n\t *\r\n\t * @param string $table table\r\n\t *\r\n\t * @return array $columns columns\r\n\t */\r\n\tpublic function getColumns( $table ) {\r\n\t\t$columns = array();\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$columnsRaw = $this->adapter->get(\"SHOW COLUMNS FROM $table\");\r\n\t\tforeach($columnsRaw as $r) {\r\n\t\t\t$columns[$r['Field']]=$r['Type'];\r\n\t\t}\r\n\t\treturn $columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Column Type Code (integer) that corresponds\r\n\t * to the given value type.\r\n\t *\r\n\t * @param string $value value\r\n\t *\r\n\t * @return integer $type type\r\n\t */\r\n\tpublic function scanType( $value, $flagSpecial=false ) {\r\n\t\t$this->svalue = $value;\r\n\r\n\t\tif (is_null($value)) {\r\n\t\t\treturn self::C_DATATYPE_INTEGER;\r\n\t\t}\r\n\r\n\t\tif ($flagSpecial) {\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d$/',$value)) {\r\n\t\t\t\treturn self::C_DATATYPE_SPECIAL_DATE;\r\n\t\t\t}\r\n\t\t\tif (preg_match('/^\\d{4}\\-\\d\\d-\\d\\d\\s\\d\\d:\\d\\d:\\d\\d$/',$value)) {\r\n\t\t\t\treturn self::C_DATATYPE_SPECIAL_DATETIME;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$value = strval($value);\r\n\t\tif (!$this->startsWithZeros($value)) {\r\n\r\n\t\t\tif (is_numeric($value) && (floor($value)==$value) && $value >= -2147483647  && $value <= 2147483647 ) {\r\n\t\t\t\treturn self::C_DATATYPE_INTEGER;\r\n\t\t\t}\r\n\t\t\tif (is_numeric($value)) {\r\n\t\t\t\treturn self::C_DATATYPE_DOUBLE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn self::C_DATATYPE_STRING;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Type Code for a Column Description.\r\n\t * Given an SQL column description this method will return the corresponding\r\n\t * code for the writer. If the include specials flag is set it will also\r\n\t * return codes for special columns. Otherwise special columns will be identified\r\n\t * as specified columns.\r\n\t *\r\n\t * @param string  $typedescription description\r\n\t * @param boolean $includeSpecials whether you want to get codes for special columns as well\r\n\t *\r\n\t * @return integer $typecode code\r\n\t */\r\n\tpublic function code( $typedescription, $includeSpecials = false ) {\r\n\r\n\r\n\t\t$r = ((isset($this->sqltype_typeno[$typedescription])) ? $this->sqltype_typeno[$typedescription] : self::C_DATATYPE_SPECIFIED);\r\n\r\n\t\tif ($includeSpecials) return $r;\r\n\t\tif ($r > self::C_DATATYPE_SPECIFIED) return self::C_DATATYPE_SPECIFIED;\r\n\t\treturn $r;\r\n\t}\r\n\r\n\t/**\r\n\t * This method adds a column to a table.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type   name of the table\r\n\t * @param string  $column name of the column\r\n\t * @param integer $field  data type for field\r\n\t *\r\n\t * @return void\r\n\t *\r\n\t */\r\n\tpublic function addColumn( $type, $column, $field ) {\r\n\t\t$table = $type;\r\n\t\t$type = $field;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$type = array_key_exists($type, $this->typeno_sqltype) ? $this->typeno_sqltype[$type] : '';\r\n\t\t$sql = \"ALTER TABLE $table ADD COLUMN $column $type \";\r\n\t\t$this->adapter->exec( $sql );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This method upgrades the column to the specified data type.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param string  $type       type / table that needs to be adjusted\r\n\t * @param string  $column     column that needs to be altered\r\n\t * @param integer $datatype   target data type\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function widenColumn( $type, $column, $datatype ) {\r\n\t\t$table = $type;\r\n\t\t$type = $datatype;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$newtype = array_key_exists($type, $this->typeno_sqltype) ? $this->typeno_sqltype[$type] : '';\r\n\t\t$changecolumnSQL = \"ALTER TABLE $table CHANGE $column $column $newtype \";\r\n\t\t$this->adapter->exec( $changecolumnSQL );\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a Unique index constrain to the table.\r\n\t *\r\n\t * @param string $table table\r\n\t * @param string $col1  column\r\n\t * @param string $col2  column\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addUniqueIndex( $table,$columns ) {\r\n\t\t$table = $this->safeTable($table);\r\n\t\tsort($columns); //else we get multiple indexes due to order-effects\r\n\t\tforeach($columns as $k=>$v) {\r\n\t\t\t$columns[$k]= $this->safeColumn($v);\r\n\t\t}\r\n\t\t$r = $this->adapter->get(\"SHOW INDEX FROM $table\");\r\n\t\t$name = 'UQ_'.sha1(implode(',',$columns));\r\n\t\tif ($r) {\r\n\t\t\tforeach($r as $i) { \r\n\t\t\t\tif (strtoupper($i['Key_name'])== strtoupper($name)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$sql = \"ALTER TABLE $table\r\n                ADD CONSTRAINT UNIQUE $name (\".implode(',',$columns).\")\";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\r\n\r\n\t/**\r\n\t * Tests whether a given SQL state is in the list of states.\r\n\t *\r\n\t * @param string $state code\r\n\t * @param array  $list  array of sql states\r\n\t *\r\n\t * @return boolean $yesno occurs in list\r\n\t */\r\n\tpublic function sqlStateIn($state, $list) {\r\n\t\tif ($state=='HY000') {\r\n\t\t\tif (in_array(RedBean_QueryWriter::C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION,$list)) return true;\r\n\t\t\tif (in_array(RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,$list)) return true;\r\n\t\t\tif (in_array(RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE,$list)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Adds a constraint. If one of the beans gets trashed\r\n\t * the other, related bean should be removed as well.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1      first bean\r\n\t * @param RedBean_OODBBean $bean2      second bean\r\n\t * @param bool \t\t\t   $dontCache  by default we use a cache, TRUE = NO CACHING (optional)\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addConstraint( RedBean_OODBBean $bean1, RedBean_OODBBean $bean2) {\r\n\t\t$table1 = $bean1->getMeta('type');\r\n\t\t$table2 = $bean2->getMeta('type');\r\n\t\t$writer = $this;\r\n\t\t$adapter = $this->adapter;\r\n\t\t$table = RedBean_QueryWriter_AQueryWriter::getAssocTableFormat( array( $table1,$table2) );\r\n\t\t$property1 = $bean1->getMeta('type') . '_id';\r\n\t\t$property2 = $bean2->getMeta('type') . '_id';\r\n\t\tif ($property1==$property2) $property2 = $bean2->getMeta('type').'2_id';\r\n\t\t//Dispatch to right method\r\n\t\treturn $this->constrain($table, $table1, $table2, $property1, $property2);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add the constraints for a specific database driver: CUBRID\r\n\t * @todo Too many arguments; find a way to solve this in a neater way.\r\n\t *\r\n\t * @param string\t\t\t  $table     table\r\n\t * @param string\t\t\t  $table1    table1\r\n\t * @param string\t\t\t  $table2    table2\r\n\t * @param string\t\t\t  $property1 property1\r\n\t * @param string\t\t\t  $property2 property2\r\n\t *\r\n\t * @return boolean $succes whether the constraint has been applied\r\n\t */\r\n\tprotected function constrain($table, $table1, $table2, $property1, $property2) {\r\n\t\t$writer = $this;\r\n\t\t$adapter = $this->adapter;\r\n\t\t$firstState = $this->buildFK($table,$table1,$property1,'id',true);\r\n\t\t$secondState = $this->buildFK($table,$table2,$property2,'id',true);\r\n\t\treturn ($firstState && $secondState);\r\n\t}\r\n\r\n\t/**\r\n\t * This method should add an index to a type and field with name\r\n\t * $name.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t * @param  $type   type to add index to\r\n\t * @param  $name   name of the new index\r\n\t * @param  $column field to index\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addIndex($type, $name, $column) {\r\n\t\t$table = $type;\r\n\t\t$table = $this->safeTable($table);\r\n\t\t$name = preg_replace('/\\W/','',$name);\r\n\t\t$column = $this->safeColumn($column);\r\n\t\t$index = $this->adapter->getRow(\"SELECT 1 as `exists` FROM db_index WHERE index_name = ? \",array($name));\r\n\t\tif ($index && $index['exists']) return;   // positive number will return, 0 will continue.\r\n\t\ttry{ $this->adapter->exec(\"CREATE INDEX $name ON $table ($column) \"); }catch(Exception $e){}\r\n\t}\r\n\r\n\t/**\r\n\t * This method adds a foreign key from type and field to\r\n\t * target type and target field.\r\n\t * The foreign key is created without an action. On delete/update\r\n\t * no action will be triggered. The FK is only used to allow database\r\n\t * tools to generate pretty diagrams and to make it easy to add actions\r\n\t * later on.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t *\r\n\t * @param  string $type\t       type that will have a foreign key field\r\n\t * @param  string $targetType  points to this type\r\n\t * @param  string $field       field that contains the foreign key value\r\n\t * @param  string $targetField field where the fk points to\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addFK( $type, $targetType, $field, $targetField, $isDependent = false) {\r\n\t\treturn $this->buildFK($type, $targetType, $field, $targetField, $isDependent);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This method adds a foreign key from type and field to\r\n\t * target type and target field.\r\n\t * The foreign key is created without an action. On delete/update\r\n\t * no action will be triggered. The FK is only used to allow database\r\n\t * tools to generate pretty diagrams and to make it easy to add actions\r\n\t * later on.\r\n\t * This methods accepts a type and infers the corresponding table name.\r\n\t *\r\n\t *\r\n\t * @param  string $type\t       type that will have a foreign key field\r\n\t * @param  string $targetType  points to this type\r\n\t * @param  string $field       field that contains the foreign key value\r\n\t * @param  string $targetField field where the fk points to\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tprotected function buildFK($type, $targetType, $field, $targetField,$isDep=false) {\r\n\t\t$table = $this->safeTable($type);\r\n\t\t$tableNoQ = $this->safeTable($type,true);\r\n\t\t$targetTable = $this->safeTable($targetType);\r\n\t\t$targetTableNoQ = $this->safeTable($targetType,true);\r\n\t\t$column = $this->safeColumn($field);\r\n\t\t$columnNoQ = $this->safeColumn($field,true);\r\n\t\t$targetColumn  = $this->safeColumn($targetField);\r\n\t\t$targetColumnNoQ  = $this->safeColumn($targetField,true);\r\n\t\t$keys = $this->getKeys($targetTableNoQ,$tableNoQ);\r\n\t\t$needsToAddFK = true;\r\n\t\t$needsToDropFK = false;\r\n\t\tforeach($keys as $key) {\r\n\t\t\tif ($key['FKTABLE_NAME']==$tableNoQ && $key['FKCOLUMN_NAME']==$columnNoQ) { \r\n\t\t\t\t//already has an FK\r\n\t\t\t\t$needsToDropFK = true;\r\n\t\t\t\tif ((($isDep && $key['DELETE_RULE']==0) || (!$isDep && $key['DELETE_RULE']==3))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ($needsToDropFK) {\r\n\t\t\t$sql = \"ALTER TABLE $table DROP FOREIGN KEY {$key['FK_NAME']} \";\r\n\t\t\t$this->adapter->exec($sql);\r\n\t\t}\r\n\t\t$casc = ($isDep ? 'CASCADE' : 'SET NULL');\r\n\t\t$sql = \"ALTER TABLE $table ADD CONSTRAINT FOREIGN KEY($column) REFERENCES $targetTable($targetColumn) ON DELETE $casc \";\r\n\t\t$this->adapter->exec($sql);\r\n\t}\t\r\n\r\n\r\n\t/**\r\n\t * Drops all tables in database\r\n\t */\r\n\tpublic function wipeAll() {\r\n\t\tforeach($this->getTables() as $t) {\r\n\t\t\tforeach($this->getKeys($t) as $k) {\r\n\t\t\t\t$this->adapter->exec(\"ALTER TABLE \\\"{$k['FKTABLE_NAME']}\\\" DROP FOREIGN KEY \\\"{$k['FK_NAME']}\\\"\");\r\n\t\t\t}\r\n\t\t\t$this->adapter->exec(\"DROP TABLE \\\"$t\\\"\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Obtains the keys of a table using the PDO schema function.\r\n\t * \r\n\t * @param type $table\r\n\t * @return type \r\n\t */\r\n\tprotected function getKeys($table,$table2=null) {\r\n\t\t$pdo = $this->adapter->getDatabase()->getPDO();\r\n\t\t$keys = $pdo->cubrid_schema(PDO::CUBRID_SCH_EXPORTED_KEYS,$table);//print_r($keys);\r\n\t\tif ($table2) $keys = array_merge($keys, $pdo->cubrid_schema(PDO::CUBRID_SCH_IMPORTED_KEYS,$table2) );//print_r($keys);\r\n\r\n\t\treturn $keys;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks table name or column name.\r\n\t *\r\n\t * @param string $table table string\r\n\t *\r\n\t * @return string $table escaped string\r\n\t */\r\n\tprotected function check($table) {\r\n\t\tif ($this->quoteCharacter && strpos($table, $this->quoteCharacter)!==false) {\r\n\t\t  throw new Redbean_Exception_Security('Illegal chars in table name');\r\n\t    }\r\n\t\treturn $table;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean Exception Base\r\n *\r\n * @file\t\t\tRedBean/Exception.php\r\n * @description\t\tRepresents the base class\r\n * \t\t\t\t\tfor RedBean Exceptions\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Exception extends LogicException {}\r\n\r\n/**\r\n * RedBean Exception SQL\r\n *\r\n * @file\t\t\tRedBean/Exception/SQL.php\r\n * @description\t\tRepresents a generic database exception independent of the\r\n *\t\t\t\t\tunderlying driver.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Exception_SQL extends RuntimeException {\r\n\r\n\t/**\r\n\t * Holds the current SQL Strate code.\r\n\t * @var string\r\n\t */\r\n\tprivate $sqlState;\r\n\r\n\t/**\r\n\t * Returns an ANSI-92 compliant SQL state.\r\n\t *\r\n\t * @return string $state ANSI state code\r\n\t */\r\n\tpublic function getSQLState() {\r\n\t\treturn $this->sqlState;\r\n\t}\r\n\r\n\t/**\r\n\t * @todo parse state to verify valid ANSI92!\r\n\t * Stores ANSI-92 compliant SQL state.\r\n\t *\r\n\t * @param string $sqlState code\r\n\t * \r\n\t * @return void\r\n\t */\r\n\tpublic function setSQLState( $sqlState ) {\r\n\t\t$this->sqlState = $sqlState;\r\n\t}\r\n\r\n\t/**\r\n\t * To String prints both code and SQL state.\r\n\t *\r\n\t * @return string $message prints this exception instance as a string\r\n\t */\r\n\tpublic function __toString() {\r\n\t\treturn '['.$this->getSQLState().'] - '.$this->getMessage();\r\n\t}\r\n}\r\n\r\n/**\r\n * Exception Security.\r\n * Part of the RedBean Exceptions Mechanism.\r\n *\r\n * @file\t\t\tRedBean/Exception\r\n * @description\t\tRepresents a subtype in the RedBean Exception System.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Exception_Security extends RedBean_Exception {}\r\n\r\n/**\r\n * RedBean Object Oriented DataBase\r\n * \r\n * @file\t\t\tRedBean/OODB.php\r\n * @description \tRedBean OODB\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * The RedBean OODB Class is the main class of RedBeanPHP.\r\n * It takes RedBean_OODBBean objects and stores them to and loads them from the\r\n * database as well as providing other CRUD functions. This class acts as a\r\n * object database.\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_OODB extends RedBean_Observable {\r\n\r\n\t/**\r\n\t * Chill mode, for fluid mode but with a list of beans / types that\r\n\t * are considered to be stable and don't need to be modified.\r\n\t * @var array \r\n\t */\r\n\tprotected $chillList = array();\r\n\r\n\t/**\r\n\t * List of dependencies. Format: $type => array($depensOnMe, $andMe)\r\n\t * @var array\r\n\t */\r\n\tprotected $dep = array();\r\n\r\n\t/**\r\n\t * Secret stash. Used for batch loading.\r\n\t * @var array\r\n\t */\r\n\tprotected $stash = NULL;\r\n\r\n\t/**\r\n\t * Contains the writer for OODB.\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $writer;\r\n\r\n\t/**\r\n\t * Whether this instance of OODB is frozen or not.\r\n\t * In frozen mode the schema will not de modified, in fluid mode\r\n\t * the schema can be adjusted to meet the needs of the developer.\r\n\t * @var boolean\r\n\t */\r\n\tprotected $isFrozen = false;\r\n\r\n\t/**\r\n\t * Bean Helper. The bean helper to give to the beans. Bean Helpers\r\n\t * assist beans in getting hold of a toolbox.\r\n\t * @var null|\\RedBean_BeanHelperFacade\r\n\t */\r\n\tprotected $beanhelper = null;\r\n\r\n\t/**\r\n\t * Association Manager.\r\n\t * Reference to the Association Manager. The OODB class uses\r\n\t * the association manager to store many-to-many relations.\r\n\t * \r\n\t * @var RedBean_AssociationManager\r\n\t */\r\n\tprotected $assocManager = null;\r\n\r\n\t/**\r\n\t * The RedBean OODB Class is the main class of RedBean.\r\n\t * It takes RedBean_OODBBean objects and stores them to and loads them from the\r\n\t * database as well as providing other CRUD functions. This class acts as a\r\n\t * object database.\r\n\t * Constructor, requires a DBAadapter (dependency inversion)\r\n\t * @param RedBean_Adapter_DBAdapter $adapter\r\n\t */\r\n\tpublic function __construct( $writer ) {\r\n\t\tif ($writer instanceof RedBean_QueryWriter) {\r\n\t\t\t$this->writer = $writer;\r\n\t\t}\r\n\t\t$this->beanhelper = new RedBean_BeanHelper_Facade();\r\n\t}\r\n\r\n\t/**\r\n\t * Toggles fluid or frozen mode. In fluid mode the database\r\n\t * structure is adjusted to accomodate your objects. In frozen mode\r\n\t * this is not the case.\r\n\t * \r\n\t * You can also pass an array containing a selection of frozen types.\r\n\t * Let's call this chilly mode, it's just like fluid mode except that\r\n\t * certain types (i.e. tables) aren't touched.\r\n\t * \r\n\t * @param boolean|array $trueFalse\r\n\t */\r\n\tpublic function freeze( $tf ) {\r\n\t\tif (is_array($tf)) {\r\n\t\t\t$this->chillList = $tf;\r\n\t\t\t$this->isFrozen = false;\r\n\t\t}\r\n\t\telse\r\n\t\t$this->isFrozen = (boolean) $tf;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the current mode of operation of RedBean.\r\n\t * In fluid mode the database\r\n\t * structure is adjusted to accomodate your objects.\r\n\t * In frozen mode\r\n\t * this is not the case.\r\n\t * \r\n\t * @return boolean $yesNo TRUE if frozen, FALSE otherwise\r\n\t */\r\n\tpublic function isFrozen() {\r\n\t\treturn (bool) $this->isFrozen;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispenses a new bean (a RedBean_OODBBean Bean Object)\r\n\t * of the specified type. Always\r\n\t * use this function to get an empty bean object. Never\r\n\t * instantiate a RedBean_OODBBean yourself because it needs\r\n\t * to be configured before you can use it with RedBean. This\r\n\t * function applies the appropriate initialization /\r\n\t * configuration for you.\r\n\t * \r\n\t * @param string $type type of bean you want to dispense\r\n\t * \r\n\t * @return RedBean_OODBBean $bean the new bean instance\r\n\t */\r\n\tpublic function dispense($type ) {\r\n\t\t$bean = new RedBean_OODBBean();\r\n\t\t$bean->setBeanHelper($this->beanhelper);\r\n\t\t$bean->setMeta('type',$type );\r\n\t\t$bean->setMeta('sys.id','id');\r\n\t\t$bean->id = 0;\r\n\t\tif (!$this->isFrozen) $this->check( $bean );\r\n\t\t$bean->setMeta('tainted',true);\r\n\t\t$this->signal('dispense',$bean );\r\n\t\treturn $bean;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets bean helper to be given to beans.\r\n\t * Bean helpers assist beans in getting a reference to a toolbox.\r\n\t *\r\n\t * @param RedBean_IBeanHelper $beanhelper helper\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function setBeanHelper( RedBean_BeanHelper $beanhelper) {\r\n\t\t$this->beanhelper = $beanhelper;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Checks whether a RedBean_OODBBean bean is valid.\r\n\t * If the type is not valid or the ID is not valid it will\r\n\t * throw an exception: RedBean_Exception_Security.\r\n\t * @throws RedBean_Exception_Security $exception\r\n\t * \r\n\t * @param RedBean_OODBBean $bean the bean that needs to be checked\r\n\t * \r\n\t * @return void\r\n\t */\r\n\tpublic function check( RedBean_OODBBean $bean ) {\r\n\t\t//Is all meta information present?\r\n\t\tif (!isset($bean->id) ) {\r\n\t\t\tthrow new RedBean_Exception_Security('Bean has incomplete Meta Information id ');\r\n\t\t}\r\n\t\tif (!($bean->getMeta('type'))) {\r\n\t\t\tthrow new RedBean_Exception_Security('Bean has incomplete Meta Information II');\r\n\t\t}\r\n\t\t//Pattern of allowed characters\r\n\t\t$pattern = '/[^a-z0-9_]/i';\r\n\t\t//Does the type contain invalid characters?\r\n\t\tif (preg_match($pattern,$bean->getMeta('type'))) {\r\n\t\t\tthrow new RedBean_Exception_Security('Bean Type is invalid');\r\n\t\t}\r\n\t\t//Are the properties and values valid?\r\n\t\tforeach($bean as $prop=>$value) {\r\n\t\t\tif (\r\n\t\t\t\t\t  is_array($value) ||\r\n\t\t\t\t\t  (is_object($value)) ||\r\n\t\t\t\t\t  strlen($prop)<1 ||\r\n\t\t\t\t\t  preg_match($pattern,$prop)\r\n\t\t\t) {\r\n\t\t\t\tthrow new RedBean_Exception_Security(\"Invalid Bean: property $prop  \");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Searches the database for a bean that matches conditions $conditions and sql $addSQL\r\n\t * and returns an array containing all the beans that have been found.\r\n\t * \r\n\t * Conditions need to take form:\r\n\t * \r\n\t * array(\r\n\t * \t\t'PROPERTY' => array( POSSIBLE VALUES... 'John','Steve' )\r\n\t * \t\t'PROPERTY' => array( POSSIBLE VALUES... )\r\n\t * );\r\n\t * \r\n\t * All conditions are glued together using the AND-operator, while all value lists\r\n\t * are glued using IN-operators thus acting as OR-conditions.\r\n\t * \r\n\t * Note that you can use property names; the columns will be extracted using the\r\n\t * appropriate bean formatter.\r\n\t * \r\n\t * @throws RedBean_Exception_SQL \r\n\t * \r\n\t * @param string  $type       type of beans you are looking for\r\n\t * @param array   $conditions list of conditions\r\n\t * @param string  $addSQL\t  SQL to be used in query\r\n\t * @param boolean $all        whether you prefer to use a WHERE clause or not (TRUE = not)\r\n\t * \r\n\t * @return array $beans\t\t  resulting beans\r\n\t */\r\n\tpublic function find($type,$conditions=array(),$addSQL=null,$all=false) {\r\n\t\ttry {\r\n\t\t\t$beans = $this->convertToBeans($type,$this->writer->selectRecord($type,$conditions,$addSQL,false,false,$all));\r\n\t\t\treturn $beans;\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE,\r\n\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN)\r\n\t\t\t)) throw $e;\r\n\t\t}\r\n\t\treturn array();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Checks whether the specified table already exists in the database.\r\n\t * Not part of the Object Database interface!\r\n\t * \r\n\t * @param string $table table name (not type!)\r\n\t * \r\n\t * @return boolean $exists whether the given table exists within this database.\r\n\t */\r\n\tpublic function tableExists($table) {\r\n\t\t//does this table exist?\r\n\t\t$tables = $this->writer->getTables();\r\n\t\treturn in_array(($table), $tables);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Processes all column based build commands.\r\n\t * A build command is an additional instruction for the Query Writer. It is processed only when\r\n\t * a column gets created. The build command is often used to instruct the writer to write some\r\n\t * extra SQL to create indexes or constraints. Build commands are stored in meta data of the bean.\r\n\t * They are only for internal use, try to refrain from using them in your code directly.\r\n\t *\r\n\t * @param  string           $table    name of the table to process build commands for\r\n\t * @param  string           $property name of the property to process build commands for\r\n\t * @param  RedBean_OODBBean $bean     bean that contains the build commands\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tprotected function processBuildCommands($table, $property, RedBean_OODBBean $bean) {\r\n\t\tif ($inx = ($bean->getMeta('buildcommand.indexes'))) {\r\n\t\t\tif (isset($inx[$property])) $this->writer->addIndex($table,$inx[$property],$property);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Process groups. Internal function. Processes different kind of groups for\r\n\t * storage function. Given a list of original beans and a list of current beans,\r\n\t * this function calculates which beans remain in the list (residue), which\r\n\t * have been deleted (are in the trashcan) and which beans have been added\r\n\t * (additions). \r\n\t *\r\n\t * @param  array $originals originals\r\n\t * @param  array $current   the current beans\r\n\t * @param  array $additions beans that have been added\r\n\t * @param  array $trashcan  beans that have been deleted\r\n\t * @param  array $residue   beans that have been left untouched\r\n\t *\r\n\t * @return array $result \tnew relational state\r\n\t */\r\n\tprivate function processGroups( $originals, $current, $additions, $trashcan, $residue ) {\r\n\t\treturn array(\r\n\t\t\tarray_merge($additions,array_diff($current,$originals)),\r\n\t\t\tarray_merge($trashcan,array_diff($originals,$current)),\r\n\t\t\tarray_merge($residue,array_intersect($current,$originals))\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Figures out the desired type given the cast string ID.\r\n\t * \r\n\t * @param string $cast cast identifier\r\n\t * \r\n\t * @return integer $typeno \r\n\t */\r\n\tprivate function getTypeFromCast($cast) {\r\n\t\tif ($cast=='string') {\r\n\t\t\t$typeno = $this->writer->scanType('STRING');\r\n\t\t}\r\n\t\telseif ($cast=='id') {\r\n\t\t\t$typeno = $this->writer->getTypeForID();\r\n\t\t}\r\n\t\telseif(isset($this->writer->sqltype_typeno[$cast])) {\r\n\t\t\t$typeno = $this->writer->sqltype_typeno[$cast];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new RedBean_Exception('Invalid Cast');\r\n\t\t}\r\n\t\treturn $typeno;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes an embedded bean. First the bean gets unboxed if possible.\r\n\t * Then, the bean is stored if needed and finally the ID of the bean\r\n\t * will be returned.\r\n\t * \r\n\t * @param RedBean_OODBBean|Model $v the bean or model\r\n\t * \r\n\t * @return  integer $id\r\n\t */\r\n\tprivate function prepareEmbeddedBean($v) {\r\n\t\tif (!$v->id || $v->getMeta('tainted')) {\r\n\t\t\t$this->store($v);\r\n\t\t}\r\n\t\treturn $v->id;\r\n\t}\r\n\r\n\t/**\r\n\t * Stores a bean in the database. This function takes a\r\n\t * RedBean_OODBBean Bean Object $bean and stores it\r\n\t * in the database. If the database schema is not compatible\r\n\t * with this bean and RedBean runs in fluid mode the schema\r\n\t * will be altered to store the bean correctly.\r\n\t * If the database schema is not compatible with this bean and\r\n\t * RedBean runs in frozen mode it will throw an exception.\r\n\t * This function returns the primary key ID of the inserted\r\n\t * bean.\r\n\t *\r\n\t * @throws RedBean_Exception_Security $exception\r\n\t * \r\n\t * @param RedBean_OODBBean | RedBean_SimpleModel $bean bean to store\r\n\t *\r\n\t * @return integer $newid resulting ID of the new bean\r\n\t */\r\n\tpublic function store( $bean ) { \r\n\t\tif ($bean instanceof RedBean_SimpleModel) $bean = $bean->unbox();\r\n\t\tif (!($bean instanceof RedBean_OODBBean)) throw new RedBean_Exception_Security('OODB Store requires a bean, got: '.gettype($bean));\r\n\t\t$processLists = false;\r\n\t\tforeach($bean as $k=>$v) if (is_array($v) || is_object($v)) { $processLists = true; break; }\r\n\t\tif (!$processLists && !$bean->getMeta('tainted')) return $bean->getID();\r\n\t\t$this->signal('update', $bean );\r\n\t\tforeach($bean as $k=>$v) if (is_array($v) || is_object($v)) { $processLists = true; break; }\r\n\t\tif ($processLists) {\r\n\t\t\t//Define groups\r\n\t\t\t$sharedAdditions = $sharedTrashcan = $sharedresidue = $sharedItems = array();\r\n\t\t\t$ownAdditions = $ownTrashcan = $ownresidue = array();\r\n\t\t\t$tmpCollectionStore = array();\r\n\t\t\t$embeddedBeans = array();\r\n\t\t\tforeach($bean as $p=>$v) {\r\n\t\t\t\tif ($v instanceof RedBean_SimpleModel) $v = $v->unbox(); \r\n\t\t\t\tif ($v instanceof RedBean_OODBBean) {\r\n\t\t\t\t\t$linkField = $p.'_id';\r\n\t\t\t\t\t$bean->$linkField = $this->prepareEmbeddedBean($v);\r\n\t\t\t\t\t$bean->setMeta('cast.'.$linkField,'id');\r\n\t\t\t\t\t$embeddedBeans[$linkField] = $v;\r\n\t\t\t\t\t$tmpCollectionStore[$p]=$bean->$p;\r\n\t\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t\t}\r\n\t\t\t\tif (is_array($v)) {\r\n\t\t\t\t\t$originals = $bean->getMeta('sys.shadow.'.$p);\r\n\t\t\t\t\tif (!$originals) $originals = array();\r\n\t\t\t\t\tif (strpos($p,'own')===0) {\r\n\t\t\t\t\t\tlist($ownAdditions,$ownTrashcan,$ownresidue)=$this->processGroups($originals,$v,$ownAdditions,$ownTrashcan,$ownresidue);\r\n\t\t\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telseif (strpos($p,'shared')===0) {\r\n\t\t\t\t\t\tlist($sharedAdditions,$sharedTrashcan,$sharedresidue)=$this->processGroups($originals,$v,$sharedAdditions,$sharedTrashcan,$sharedresidue);\r\n\t\t\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->storeBean($bean);\r\n\r\n\t\tif ($processLists) {\r\n\t\t\t$this->processEmbeddedBeans($bean,$embeddedBeans);\r\n\t\t\t$myFieldLink = $bean->getMeta('type').'_id';\r\n\t\t\t//Handle related beans\r\n\t\t\t$this->processTrashcan($bean,$ownTrashcan);\r\n\t\t\t$this->processAdditions($bean,$ownAdditions);\r\n\t\t\t$this->processResidue($ownresidue);\r\n\t\t\tforeach($sharedTrashcan as $trash) $this->assocManager->unassociate($trash,$bean);\r\n\t\t\t$this->processSharedAdditions($bean,$sharedAdditions);\r\n\t\t\tforeach($sharedresidue as $residue) $this->store($residue);\r\n\t\t}\r\n\t\t$this->signal('after_update',$bean);\r\n\t\treturn (int) $bean->id;\r\n\t}\r\n\r\n\t/**\r\n\t * Stores a cleaned bean; i.e. only scalar values. This is the core of the store()\r\n\t * method. When all lists and embedded beans (parent objects) have been processed and\r\n\t * removed from the original bean the bean is passed to this method to be stored\r\n\t * in the database.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean the clean bean \r\n\t */\r\n\tprivate function storeBean(RedBean_OODBBean $bean) {\r\n\t\tif (!$this->isFrozen) $this->check($bean);\r\n\t\t//what table does it want\r\n\t\t$table = $bean->getMeta('type');\r\n\t\tif ($bean->getMeta('tainted')) {\r\n\t\t\t//Does table exist? If not, create\r\n\t\t\tif (!$this->isFrozen && !$this->tableExists($this->writer->safeTable($table,true))) {\r\n\t\t\t\t$this->writer->createTable( $table );\r\n\t\t\t\t$bean->setMeta('buildreport.flags.created',true);\r\n\t\t\t}\r\n\t\t\tif (!$this->isFrozen) {\r\n\t\t\t\t$columns = $this->writer->getColumns($table) ;\r\n\t\t\t}\r\n\t\t\t//does the table fit?\r\n\t\t\t$insertvalues = array();\r\n\t\t\t$insertcolumns = array();\r\n\t\t\t$updatevalues = array();\r\n\t\t\tforeach( $bean as $p=>$v ) {\r\n\t\t\t\t$origV = $v;\r\n\t\t\t\tif ($p!='id') {\r\n\t\t\t\t\tif (!$this->isFrozen) {\r\n\t\t\t\t\t\t//Not in the chill list?\r\n\t\t\t\t\t\tif (!in_array($bean->getMeta('type'),$this->chillList)) {\r\n\t\t\t\t\t\t\t//Does the user want to specify the type?\r\n\t\t\t\t\t\t\tif ($bean->getMeta(\"cast.$p\",-1)!==-1) {\r\n\t\t\t\t\t\t\t\t$cast = $bean->getMeta(\"cast.$p\");\r\n\t\t\t\t\t\t\t\t$typeno = $this->getTypeFromCast($cast);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t$cast = false;\t\t\r\n\t\t\t\t\t\t\t\t//What kind of property are we dealing with?\r\n\t\t\t\t\t\t\t\t$typeno = $this->writer->scanType($v,true);\r\n\t\t\t\t\t\t\t\t$v = $this->writer->getValue();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//Is this property represented in the table?\r\n\t\t\t\t\t\t\tif (isset($columns[$this->writer->safeColumn($p,true)])) {\r\n\t\t\t\t\t\t\t\t//rescan\r\n\t\t\t\t\t\t\t\t$v = $origV;\r\n\t\t\t\t\t\t\t\tif (!$cast) $typeno = $this->writer->scanType($v,false);\r\n\t\t\t\t\t\t\t\t//yes it is, does it still fit?\r\n\t\t\t\t\t\t\t\t$sqlt = $this->writer->code($columns[$this->writer->safeColumn($p,true)]);\r\n\t\t\t\t\t\t\t\tif ($typeno > $sqlt) {\r\n\t\t\t\t\t\t\t\t\t//no, we have to widen the database column type\r\n\t\t\t\t\t\t\t\t\t$this->writer->widenColumn( $table, $p, $typeno );\r\n\t\t\t\t\t\t\t\t\t$bean->setMeta('buildreport.flags.widen',true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t//no it is not\r\n\t\t\t\t\t\t\t\t$this->writer->addColumn($table, $p, $typeno);\r\n\t\t\t\t\t\t\t\t$bean->setMeta('buildreport.flags.addcolumn',true);\r\n\t\t\t\t\t\t\t\t//@todo: move build commands here... more practical\r\n\t\t\t\t\t\t\t\t$this->processBuildCommands($table,$p,$bean);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Okay, now we are sure that the property value will fit\r\n\t\t\t\t\t$insertvalues[] = $v;\r\n\t\t\t\t\t$insertcolumns[] = $p;\r\n\t\t\t\t\t$updatevalues[] = array( 'property'=>$p, 'value'=>$v );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!$this->isFrozen && ($uniques = $bean->getMeta('buildcommand.unique'))) {\r\n\t\t\t\tforeach($uniques as $unique) $this->writer->addUniqueIndex( $table, $unique );\r\n\t\t\t}\r\n\t\t\t$rs = $this->writer->updateRecord( $table, $updatevalues, $bean->id );\r\n\t\t\t$bean->id = $rs;\r\n\t\t\t$bean->setMeta('tainted',false);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a list of beans from a bean. A bean may contain lists. This\r\n\t * method handles shared addition lists; i.e. the $bean->sharedObject properties.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean             the bean\r\n\t * @param array            $sharedAdditions  list with shared additions\r\n\t */\r\n\tprivate function processSharedAdditions($bean,$sharedAdditions) {\r\n\t\tforeach($sharedAdditions as $addition) {\r\n\t\t\tif ($addition instanceof RedBean_OODBBean) {\r\n\t\t\t\t$this->assocManager->associate($addition,$bean);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow new RedBean_Exception_Security('Array may only contain RedBean_OODBBeans');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a list of beans from a bean. A bean may contain lists. This\r\n\t * method handles own lists; i.e. the $bean->ownObject properties.\r\n\t * A residue is a bean in an own-list that stays where it is. This method\r\n\t * checks if there have been any modification to this bean, in that case\r\n\t * the bean is stored once again, otherwise the bean will be left untouched.\r\n\t *  \r\n\t * @param RedBean_OODBBean $bean       the bean\r\n\t * @param array            $ownresidue list \r\n\t */\r\n\tprivate function processResidue($ownresidue) {\r\n\t\tforeach($ownresidue as $residue) {\r\n\t\t\tif ($residue->getMeta('tainted')) {\r\n\t\t\t\t$this->store($residue);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a list of beans from a bean. A bean may contain lists. This\r\n\t * method handles own lists; i.e. the $bean->ownObject properties.\r\n\t * A trash can bean is a bean in an own-list that has been removed \r\n\t * (when checked with the shadow). This method\r\n\t * checks if the bean is also in the dependency list. If it is the bean will be removed.\r\n\t * If not, the connection between the bean and the owner bean will be broken by\r\n\t * setting the ID to NULL.\r\n\t *  \r\n\t * @param RedBean_OODBBean $bean        the bean\r\n\t * @param array            $ownTrashcan list \r\n\t */\r\n\tprivate function processTrashcan($bean,$ownTrashcan) {\r\n\t\t$myFieldLink = $bean->getMeta('type').'_id';\r\n\t\tif (count($ownTrashcan)>0) {\r\n\t\t\t$first = reset($ownTrashcan);\r\n\t\t\tif ($first instanceof RedBean_OODBBean) {\r\n\t\t\t\t$alias = $bean->getMeta('sys.alias.'.$first->getMeta('type'));\r\n\t\t\t\tif ($alias) $myFieldLink = $alias.'_id';\r\n\t\t\t}\r\n\t\t}\r\n\t\tforeach($ownTrashcan as $trash) {\r\n\t\t\tif (isset($this->dep[$trash->getMeta('type')]) && in_array($bean->getMeta('type'),$this->dep[$trash->getMeta('type')])) {\r\n\t\t\t\t$this->trash($trash);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$trash->$myFieldLink = null;\r\n\t\t\t\t$this->store($trash);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes embedded beans.\r\n\t * Each embedded bean will be indexed and foreign keys will\r\n\t * be created if the bean is in the dependency list.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean          bean\r\n\t * @param array            $embeddedBeans embedded beans\r\n\t */\r\n\tprivate function processEmbeddedBeans($bean, $embeddedBeans) {\r\n\t\tforeach($embeddedBeans as $linkField=>$embeddedBean) {\r\n\t\t\tif (!$this->isFrozen) {\r\n\t\t\t\t$this->writer->addIndex($bean->getMeta('type'),\r\n\t\t\t\t\t\t\t'index_foreignkey_'.$bean->getMeta('type').'_'.$embeddedBean->getMeta('type'),\r\n\t\t\t\t\t\t\t $linkField);\r\n\t\t\t\t$isDep = $this->isDependentOn($bean->getMeta('type'),$embeddedBean->getMeta('type'));\r\n\t\t\t\t$this->writer->addFK($bean->getMeta('type'),$embeddedBean->getMeta('type'),$linkField,'id',$isDep);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Part of the store() functionality.\r\n\t * Handles all new additions after the bean has been saved.\r\n\t * Stores addition bean in own-list, extracts the id and\r\n\t * adds a foreign key. Also adds a constraint in case the type is\r\n\t * in the dependent list.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean         bean\r\n\t * @param array            $ownAdditions list of addition beans in own-list \r\n\t */\r\n\tprivate function processAdditions($bean,$ownAdditions) {\r\n\t\t$myFieldLink = $bean->getMeta('type').'_id';\r\n\t\tif ($bean && count($ownAdditions)>0) {\r\n\t\t\t$first = reset($ownAdditions);\r\n\t\t\tif ($first instanceof RedBean_OODBBean) {\r\n\t\t\t\t$alias = $bean->getMeta('sys.alias.'.$first->getMeta('type'));\r\n\t\t\t\tif ($alias) $myFieldLink = $alias.'_id';\r\n\t\t\t}\r\n\t\t}\r\n\t\tforeach($ownAdditions as $addition) {\r\n\t\t\tif ($addition instanceof RedBean_OODBBean) {  \r\n\t\t\t\t$addition->$myFieldLink = $bean->id;\r\n\t\t\t\t$addition->setMeta('cast.'.$myFieldLink,'id');\r\n\t\t\t\t$this->store($addition);\r\n\r\n\t\t\t\tif (!$this->isFrozen) {\r\n\t\t\t\t\t$this->writer->addIndex($addition->getMeta('type'),\r\n\t\t\t\t\t\t'index_foreignkey_'.$addition->getMeta('type').'_'.$bean->getMeta('type'),\r\n\t\t\t\t\t\t $myFieldLink);\r\n\t\t\t\t\t$isDep = $this->isDependentOn($addition->getMeta('type'),$bean->getMeta('type'));\r\n\t\t\t\t\t$this->writer->addFK($addition->getMeta('type'),$bean->getMeta('type'),$myFieldLink,'id',$isDep);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow new RedBean_Exception_Security('Array may only contain RedBean_OODBBeans');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether reference type has been marked as dependent on target type.\r\n\t * This is the result of setting reference type as a key in R::dependencies() and\r\n\t * putting target type in its array. \r\n\t * \r\n\t * @param string $refType   reference type\r\n\t * @param string $otherType other type / target type\r\n\t * \r\n\t * @return boolean \r\n\t */\r\n\tprotected function isDependentOn($refType,$otherType) {\r\n\t\treturn (boolean) (isset($this->dep[$refType]) && in_array($otherType,$this->dep[$refType]));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Loads a bean from the object database.\r\n\t * It searches for a RedBean_OODBBean Bean Object in the\r\n\t * database. It does not matter how this bean has been stored.\r\n\t * RedBean uses the primary key ID $id and the string $type\r\n\t * to find the bean. The $type specifies what kind of bean you\r\n\t * are looking for; this is the same type as used with the\r\n\t * dispense() function. If RedBean finds the bean it will return\r\n\t * the RedBean_OODB Bean object; if it cannot find the bean\r\n\t * RedBean will return a new bean of type $type and with\r\n\t * primary key ID 0. In the latter case it acts basically the\r\n\t * same as dispense().\r\n\t * \r\n\t * Important note:\r\n\t * If the bean cannot be found in the database a new bean of\r\n\t * the specified type will be generated and returned.\r\n\t * \r\n\t * @param string  $type type of bean you want to load\r\n\t * @param integer $id   ID of the bean you want to load\r\n\t * \r\n\t * @return RedBean_OODBBean $bean loaded bean\r\n\t */\r\n\tpublic function load($type,$id) {\r\n\t\t$bean = $this->dispense( $type );\r\n\t\tif ($this->stash && isset($this->stash[$id])) {\r\n\t\t\t$row = $this->stash[$id];\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttry {\r\n\t\t\t\t$rows = $this->writer->selectRecord($type,array('id'=>array($id)));\r\n\t\t\t}catch(RedBean_Exception_SQL $e ) {\r\n\t\t\t\tif (\r\n\t\t\t\t$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\t\tarray(\r\n\t\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\t$rows = 0;\r\n\t\t\t\t\tif ($this->isFrozen) throw $e; //only throw if frozen;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (empty($rows)) return $bean; // $this->dispense($type); -- no need...\r\n\t\t\t$row = array_pop($rows);\r\n\t\t}\r\n\t\tforeach($row as $p=>$v) {\r\n\t\t\t//populate the bean with the database row\r\n\t\t\t$bean->$p = $v;\r\n\t\t}\r\n\t\t$this->signal('open',$bean );\r\n\t\t$bean->setMeta('tainted',false);\r\n\t\treturn $bean;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a bean from the database.\r\n\t * This function will remove the specified RedBean_OODBBean\r\n\t * Bean Object from the database.\r\n\t * \r\n\t * @throws RedBean_Exception_Security $exception\r\n\t * \r\n\t * @param RedBean_OODBBean|RedBean_SimpleModel $bean bean you want to remove from database\r\n\t */\r\n\tpublic function trash( $bean ) {\r\n\t\tif ($bean instanceof RedBean_SimpleModel) $bean = $bean->unbox();\r\n\t\tif (!($bean instanceof RedBean_OODBBean)) throw new RedBean_Exception_Security('OODB Store requires a bean, got: '.gettype($bean));\r\n\t\t$this->signal('delete',$bean);\r\n\t\tforeach($bean as $p=>$v) {\r\n\t\t\tif ($v instanceof RedBean_OODBBean) {\r\n\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t}\r\n\t\t\tif (is_array($v)) {\r\n\t\t\t\tif (strpos($p,'own')===0) {\r\n\t\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t\t}\r\n\t\t\t\telseif (strpos($p,'shared')===0) {\r\n\t\t\t\t\t$bean->removeProperty($p);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!$this->isFrozen) $this->check( $bean );\r\n\t\ttry {\r\n\t\t\t$this->writer->selectRecord($bean->getMeta('type'),\r\n\t\t\t\tarray('id' => array( $bean->id) ),null,true );\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t}\r\n\t\t$bean->id = 0;\r\n\t\t$this->signal('after_delete', $bean );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array of beans. Pass a type and a series of ids and\r\n\t * this method will bring you the correspondig beans.\r\n\t * \r\n\t * important note: Because this method loads beans using the load()\r\n\t * function (but faster) it will return empty beans with ID 0 for \r\n\t * every bean that could not be located. The resulting beans will have the\r\n\t * passed IDs as their keys.\r\n\t *\r\n\t * @param string $type type of beans \r\n\t * @param array  $ids  ids to load\r\n\t *\r\n\t * @return array $beans resulting beans (may include empty ones)\r\n\t */\r\n\tpublic function batch( $type, $ids ) {\r\n\t\tif (!$ids) return array();\r\n\t\t$collection = array();\r\n\t\ttry {\r\n\t\t\t$rows = $this->writer->selectRecord($type,array('id'=>$ids));\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\r\n\t\t\t$rows = false;\r\n\t\t}\r\n\t\t$this->stash = array();\r\n\t\tif (!$rows) return array();\r\n\t\tforeach($rows as $row) {\r\n\t\t\t$this->stash[$row['id']] = $row;\r\n\t\t}\r\n\t\tforeach($ids as $id) {\r\n\t\t\t$collection[ $id ] = $this->load( $type, $id );\r\n\t\t}\r\n\t\t$this->stash = NULL;\r\n\t\treturn $collection;\r\n\t}\r\n\r\n\t/**\r\n\t * This is a convenience method; it converts database rows\r\n\t * (arrays) into beans. Given a type and a set of rows this method\r\n\t * will return an array of beans of the specified type loaded with\r\n\t * the data fields provided by the result set from the database.\r\n\t * \r\n\t * @param string $type type of beans you would like to have\r\n\t * @param array  $rows rows from the database result\r\n\t * \r\n\t * @return array $collectionOfBeans collection of beans\r\n\t */\r\n\tpublic function convertToBeans($type, $rows) {\r\n\t\t$collection = array();\r\n\t\t$this->stash = array();\r\n\t\tforeach($rows as $row) {\r\n\t\t\t$id = $row['id'];\r\n\t\t\t$this->stash[$id] = $row;\r\n\t\t\t$collection[ $id ] = $this->load( $type, $id );\r\n\t\t}\r\n\t\t$this->stash = NULL;\r\n\t\treturn $collection;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of beans we have in DB of a given type.\r\n\t *\r\n\t * @param string $type   type of bean we are looking for\r\n\t * @param string $addSQL additional SQL snippet\r\n\t * @param array  $params parameters to bind to SQL\r\n\t *\r\n\t * @return integer $num number of beans found\r\n\t */\r\n\tpublic function count($type,$addSQL='',$params=array()) {\r\n\t\ttry {\r\n\t\t\treturn (int) $this->writer->count($type,$addSQL,$params);\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Trash all beans of a given type.\r\n\t *\r\n\t * @param string $type type\r\n\t *\r\n\t * @return boolean $yesNo whether we actually did some work or not..\r\n\t */\r\n\tpublic function wipe($type) {\r\n\t\ttry {\r\n\t\t\t$this->writer->wipe($type);\r\n\t\t\treturn true;\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(RedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an Association Manager for use with OODB.\r\n\t * A simple getter function to obtain a reference to the association manager used for\r\n\t * storage and more.\r\n\t *\r\n\t * @throws Exception\r\n\t * @return RedBean_AssociationManager $assoc Association Manager\r\n\t */\r\n\tpublic function getAssociationManager() {\r\n\t\tif (!isset($this->assocManager)) throw new Exception('No association manager available.');\r\n\t\treturn $this->assocManager;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the association manager instance to be used by this OODB.\r\n\t * A simple setter function to set the association manager to be used for storage and\r\n\t * more.\r\n\t * \r\n\t * @param RedBean_AssociationManager $assoc sets the association manager to be used\r\n\t * \r\n\t * @return void\r\n\t */\r\n\tpublic function setAssociationManager(RedBean_AssociationManager $assoc) {\r\n\t\t$this->assocManager = $assoc;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets a dependency list. Dependencies can be used to make\r\n\t * certain beans depend on others. This causes dependent beans to get removed\r\n\t * once the bean they depend on has been removed as well.\r\n\t * A dependency takes the form:\r\n\t * \r\n\t * $me => depends on array( $bean1, $bean2 )\r\n\t * \r\n\t * For instance a to inform RedBeanPHP about the fact that a page\r\n\t * depends on a book:\r\n\t * \r\n\t * 'page' => array('book')\r\n\t * \r\n\t * A bean can depend on multiple other beans.\r\n\t * \r\n\t * A dependency does two things:\r\n\t * \r\n\t * 1. Adds a ON CASCADE DELETE \r\n\t * 2. trashes the depending bean if the entry in the ownList is removed \r\n\t * \r\n\t * @param array $dep \r\n\t */\r\n\tpublic function setDepList($dep) {\r\n\t\t$this->dep = $dep;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * ToolBox\r\n * Contains most important redbean tools\r\n * \r\n * @file\t\t\tRedBean/ToolBox.php\r\n * @description\t\tThe ToolBox acts as a resource locator for RedBean but can\r\n *\t\t\t\t\tbe integrated in larger resource locators (nested).\r\n *\t\t\t\t\tIt does not do anything more than just store the three most\r\n *\t\t\t\t\timportant RedBean resources (tools): the database adapter,\r\n *\t\t\t\t\tthe redbean core class (oodb) and the query writer.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_ToolBox {\r\n\r\n\t/**\r\n\t * Reference to the RedBeanPHP OODB Object Database instance\r\n\t * @var RedBean_OODB\r\n\t */\r\n\tprotected $oodb;\r\n\r\n\t/**\r\n\t * Reference to the Query Writer\r\n\t * @var RedBean_QueryWriter\r\n\t */\r\n\tprotected $writer;\r\n\r\n\t/**\r\n\t * Reference to the database adapter\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * The Constructor of the ToolBox takes three arguments: a RedBean_OODB $redbean\r\n\t * object database, a RedBean_Adapter $databaseAdapter and a\r\n\t * RedBean_QueryWriter $writer. It stores these objects inside and acts as\r\n\t * a micro service locator. You can pass the toolbox to any object that needs\r\n\t * one of the RedBean core objects to interact with.\r\n\t *\r\n\t * @param RedBean_OODB              $oodb    Object Database\r\n\t * @param RedBean_Adapter_DBAdapter $adapter Adapter\r\n\t * @param RedBean_QueryWriter       $writer  Writer\r\n\t *\r\n\t * return RedBean_ToolBox $toolbox Toolbox\r\n\t */\r\n\tpublic function __construct(RedBean_OODB $oodb,RedBean_Adapter $adapter,RedBean_QueryWriter $writer) {\r\n\t\t$this->oodb = $oodb;\r\n\t\t$this->adapter = $adapter;\r\n\t\t$this->writer = $writer;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * The Toolbox acts as a kind of micro service locator, providing just the\r\n\t * most important objects that make up RedBean. You can pass the toolkit to\r\n\t * any object that needs one of these objects to function properly.\r\n\t * Returns the QueryWriter; normally you do not use this object but other\r\n\t * object might want to use the default RedBean query writer to be\r\n\t * database independent.\r\n\t *\r\n\t * @return RedBean_QueryWriter $writer writer\r\n\t */\r\n\tpublic function getWriter() {\r\n\t\treturn $this->writer;\r\n\t}\r\n\r\n\t/**\r\n\t * The Toolbox acts as a kind of micro service locator, providing just the\r\n\t * most important objects that make up RedBean. You can pass the toolkit to\r\n\t * any object that needs one of these objects to function properly.\r\n\t * Retruns the RedBean OODB Core object. The RedBean OODB object is\r\n\t * the ultimate core of Redbean. It provides the means to store and load\r\n\t * beans. Extract this object immediately after invoking a kickstart method.\r\n\t *\r\n\t * @return RedBean_OODB $oodb Object Database\r\n\t */\r\n\tpublic function getRedBean() {\r\n\t\treturn $this->oodb;\r\n\t}\r\n\r\n\t/**\r\n\t * The Toolbox acts as a kind of micro service locator, providing just the\r\n\t * most important objects that make up RedBean. You can pass the toolkit to\r\n\t * any object that needs one of these objects to function properly.\r\n\t * Returns the adapter. The Adapter can be used to perform queries\r\n\t * on the database directly.\r\n\t *\r\n\t * @return RedBean_Adapter_DBAdapter $adapter Adapter\r\n\t */\r\n\tpublic function getDatabaseAdapter() {\r\n\t\treturn $this->adapter;\r\n\t}\r\n}\r\n\r\n/**\r\n * RedBean Association\r\n * \r\n * @file\t\t\tRedBean/AssociationManager.php\r\n * @description\t\tManages simple bean associations.\r\n *\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_AssociationManager extends RedBean_Observable {\r\n\t/**\r\n\t * Contains a reference to the Object Database OODB\r\n\t * @var RedBean_OODB\r\n\t */\r\n\tprotected $oodb;\r\n\r\n\t/**\r\n\t * Contains a reference to the Database Adapter\r\n\t * @var RedBean_Adapter_DBAdapter\r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * Contains a reference to the Query Writer\r\n\t * @var RedBean_QueryWriter\r\n\t */\r\n\tprotected $writer;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param RedBean_ToolBox $tools toolbox\r\n\t */\r\n\tpublic function __construct( RedBean_ToolBox $tools ) {\r\n\t\t$this->oodb = $tools->getRedBean();\r\n\t\t$this->adapter = $tools->getDatabaseAdapter();\r\n\t\t$this->writer = $tools->getWriter();\r\n\t\t$this->toolbox = $tools;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a table name based on a types array.\r\n\t * Manages the get the correct name for the linking table for the\r\n\t * types provided.\r\n\t *\r\n\t * @todo find a nice way to decouple this class from QueryWriter?\r\n\t * \r\n\t * @param array $types 2 types as strings\r\n\t *\r\n\t * @return string $table table\r\n\t */\r\n\tpublic function getTable( $types ) {\r\n\t\treturn RedBean_QueryWriter_AQueryWriter::getAssocTableFormat($types);\r\n\t}\r\n\t/**\r\n\t * Associates two beans with eachother using a many-to-many relation.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 bean1\r\n\t * @param RedBean_OODBBean $bean2 bean2\r\n\t */\r\n\tpublic function associate($beans1, $beans2) {\r\n\t\t$results = array();\r\n\t\tif (!is_array($beans1)) $beans1 = array($beans1);\r\n\t\tif (!is_array($beans2)) $beans2 = array($beans2);\r\n\t\tforeach($beans1 as $bean1) {\r\n\t\t\tforeach($beans2 as $bean2) {\r\n\t\t\t\t$table = $this->getTable( array($bean1->getMeta('type') , $bean2->getMeta('type')) );\r\n\t\t\t\t$bean = $this->oodb->dispense($table);\r\n\t\t\t\t$results[] = $this->associateBeans( $bean1, $bean2, $bean );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (count($results)>1) ? $results : reset($results);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Associates a pair of beans. This method associates two beans, no matter\r\n\t * what types.Accepts a base bean that contains data for the linking record.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 first bean\r\n\t * @param RedBean_OODBBean $bean2 second bean\r\n\t * @param RedBean_OODBBean $bean  base bean\r\n\t *\r\n\t * @return mixed $id either the link ID or null\r\n\t */\r\n\tprotected function associateBeans(RedBean_OODBBean $bean1, RedBean_OODBBean $bean2, RedBean_OODBBean $bean) {\r\n\r\n\t\t$property1 = $bean1->getMeta('type') . '_id';\r\n\t\t$property2 = $bean2->getMeta('type') . '_id';\r\n\t\tif ($property1==$property2) $property2 = $bean2->getMeta('type').'2_id';\r\n\t\t//add a build command for Unique Indexes\r\n\t\t$bean->setMeta('buildcommand.unique' , array(array($property1, $property2)));\r\n\t\t//add a build command for Single Column Index (to improve performance in case unqiue cant be used)\r\n\t\t$indexName1 = 'index_for_'.$bean->getMeta('type').'_'.$property1;\r\n\t\t$indexName2 = 'index_for_'.$bean->getMeta('type').'_'.$property2;\r\n\t\t$bean->setMeta('buildcommand.indexes', array($property1=>$indexName1,$property2=>$indexName2));\r\n\t\t$this->oodb->store($bean1);\r\n\t\t$this->oodb->store($bean2);\r\n\t\t$bean->setMeta(\"cast.$property1\",\"id\");\r\n\t\t$bean->setMeta(\"cast.$property2\",\"id\");\r\n\t\t$bean->$property1 = $bean1->id;\r\n\t\t$bean->$property2 = $bean2->id;\r\n\t\ttry {\r\n\t\t\t$id = $this->oodb->store( $bean );\r\n\t\t\t//On creation, add constraints....\r\n\t\t\tif (!$this->oodb->isFrozen() &&\r\n\t\t\t\t$bean->getMeta('buildreport.flags.created')){\r\n\t\t\t\t$bean->setMeta('buildreport.flags.created',0);\r\n\t\t\t\tif (!$this->oodb->isFrozen())\r\n\t\t\t\t$this->writer->addConstraint( $bean1, $bean2 );\r\n\t\t\t}\r\n\t\t\t$results[] = $id;\r\n\t\t}\r\n\t\tcatch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_INTEGRITY_CONSTRAINT_VIOLATION\r\n\t\t\t))) throw $e;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all ids of beans of type $type that are related to $bean. If the\r\n\t * $getLinks parameter is set to boolean TRUE this method will return the ids\r\n\t * of the association beans instead. You can also add additional SQL. This SQL\r\n\t * will be appended to the original query string used by this method. Note that this\r\n\t * method will not return beans, just keys. For a more convenient method see the R-facade\r\n\t * method related(), that is in fact a wrapper for this method that offers a more\r\n\t * convenient solution. If you want to make use of this method, consider the\r\n\t * OODB batch() method to convert the ids to beans.\r\n\t * \r\n\t * Since 3.2, you can now also pass an array of beans instead just one\r\n\t * bean as the first parameter.\r\n\t *\r\n\t * @throws RedBean_Exception_SQL\r\n\t *\r\n\t * @param RedBean_OODBBean|array $bean     reference bean\r\n\t * @param string\t\t\t\t $type     target type\r\n\t * @param bool\t\t\t\t\t $getLinks whether you are interested in the assoc records\r\n\t * @param bool\t\t\t\t\t $sql      room for additional SQL\r\n\t *\r\n\t * @return array $ids\r\n\t */\r\n\tpublic function related( $bean, $type, $getLinks=false, $sql=false) {\r\n\t\tif (!is_array($bean) && !($bean instanceof RedBean_OODBBean)) throw new RedBean_Exception_Security('Expected array or RedBean_OODBBean but got:'.gettype($bean));\r\n\t\t$ids = array();\r\n\t\tif (is_array($bean)) {\r\n\t\t\t$beans = $bean;\r\n\t\t\tforeach($beans as $b) {\r\n\t\t\t\tif (!($b instanceof RedBean_OODBBean)) throw new RedBean_Exception_Security('Expected RedBean_OODBBean in array but got:'.gettype($b));\r\n\t\t\t\t$ids[] = $b->id;\r\n\t\t\t}\r\n\t\t\t$bean = reset($beans);\r\n\t\t}\r\n\t\telse $ids[] = $bean->id;\r\n\t\t$table = $this->getTable( array($bean->getMeta('type') , $type) );\r\n\t\tif ($type==$bean->getMeta('type')) {\r\n\t\t\t$type .= '2';\r\n\t\t\t$cross = 1;\r\n\t\t}\r\n\t\telse $cross=0;\r\n\t\tif (!$getLinks) $targetproperty = $type.'_id'; else $targetproperty='id';\r\n\r\n\t\t$property = $bean->getMeta('type').'_id';\r\n\t\ttry {\r\n\t\t\t\t$sqlFetchKeys = $this->writer->selectRecord(\r\n\t\t\t\t\t  $table,\r\n\t\t\t\t\t  array( $property => $ids ),\r\n\t\t\t\t\t  $sql,\r\n\t\t\t\t\t  false\r\n\t\t\t\t);\r\n\t\t\t\t$sqlResult = array();\r\n\t\t\t\tforeach( $sqlFetchKeys as $row ) {\r\n\t\t\t\t\tif (isset($row[$targetproperty])) {\r\n\t\t\t\t\t\t$sqlResult[] = $row[$targetproperty];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ($cross) {\r\n\t\t\t\t\t$sqlFetchKeys2 = $this->writer->selectRecord(\r\n\t\t\t\t\t\t\t  $table,\r\n\t\t\t\t\t\t\t  array( $targetproperty => $ids),\r\n\t\t\t\t\t\t\t  $sql,\r\n\t\t\t\t\t\t\t  false\r\n\t\t\t\t\t);\r\n\t\t\t\t\tforeach( $sqlFetchKeys2 as $row ) {\r\n\t\t\t\t\t\tif (isset($row[$property])) {\r\n\t\t\t\t\t\t\t$sqlResult[] = $row[$property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\treturn $sqlResult; //or returns rows in case of $sql != empty\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t\treturn array();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Breaks the association between two beans. This method unassociates two beans. If the\r\n\t * method succeeds the beans will no longer form an association. In the database\r\n\t * this means that the association record will be removed. This method uses the\r\n\t * OODB trash() method to remove the association links, thus giving FUSE models the\r\n\t * opportunity to hook-in additional business logic. If the $fast parameter is\r\n\t * set to boolean TRUE this method will remove the beans without their consent,\r\n\t * bypassing FUSE. This can be used to improve performance.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 first bean\r\n\t * @param RedBean_OODBBean $bean2 second bean\r\n\t * @param boolean          $fast  If TRUE, removes the entries by query without FUSE\r\n\t */\r\n\tpublic function unassociate($beans1, $beans2, $fast=null) {\r\n\t\tif (!is_array($beans1)) $beans1 = array($beans1);\r\n\t\tif (!is_array($beans2)) $beans2 = array($beans2);\r\n\t\tforeach($beans1 as $bean1) {\r\n\t\t\tforeach($beans2 as $bean2) {\r\n\r\n\t\t\t\t$this->oodb->store($bean1);\r\n\t\t\t\t$this->oodb->store($bean2);\r\n\t\t\t\t$table = $this->getTable( array($bean1->getMeta('type') , $bean2->getMeta('type')) );\r\n\t\t\t\t$type = $bean1->getMeta('type');\r\n\t\t\t\tif ($type==$bean2->getMeta('type')) {\r\n\t\t\t\t\t$type .= '2';\r\n\t\t\t\t\t$cross = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse $cross = 0;\r\n\t\t\t\t$property1 = $type.'_id';\r\n\t\t\t\t$property2 = $bean2->getMeta('type').'_id';\r\n\t\t\t\t$value1 = (int) $bean1->id;\r\n\t\t\t\t$value2 = (int) $bean2->id;\r\n\t\t\t\ttry {\r\n\t\t\t\t\t$rows = $this->writer->selectRecord($table,array(\r\n\t\t\t\t\t\t$property1 => array($value1), $property2=>array($value2)),null,$fast\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif ($cross) {\r\n\t\t\t\t\t\t$rows2 = $this->writer->selectRecord($table,array(\r\n\t\t\t\t\t\t$property2 => array($value1), $property1=>array($value2)),null,$fast\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tif ($fast) continue;\r\n\t\t\t\t\t\t$rows = array_merge($rows,$rows2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($fast) continue;\r\n\t\t\t\t\t$beans = $this->oodb->convertToBeans($table,$rows);\r\n\t\t\t\t\tforeach($beans as $link) {\r\n\t\t\t\t\t\t$this->oodb->trash($link);\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\t\t\tarray(\r\n\t\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t\t\t)) throw $e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all relations for a bean. This method breaks every connection between\r\n\t * a certain bean $bean and every other bean of type $type. Warning: this method\r\n\t * is really fast because it uses a direct SQL query however it does not inform the\r\n\t * models about this. If you want to notify FUSE models about deletion use a foreach-loop\r\n\t * with unassociate() instead. (that might be slower though)\r\n\t *\r\n\t * @param RedBean_OODBBean $bean reference bean\r\n\t * @param string           $type type of beans that need to be unassociated\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function clearRelations(RedBean_OODBBean $bean, $type) {\r\n\t\t$this->oodb->store($bean);\r\n\t\t$table = $this->getTable( array($bean->getMeta('type') , $type) );\r\n\t\tif ($type==$bean->getMeta('type')) {\r\n\t\t\t$property2 = $type.'2_id';\r\n\t\t\t$cross = 1;\r\n\t\t}\r\n\t\telse $cross = 0;\r\n\t\t$property = $bean->getMeta('type').'_id';\r\n\t\ttry {\r\n\t\t\t$this->writer->selectRecord( $table, array($property=>array($bean->id)),null,true);\r\n\t\t\tif ($cross) {\r\n\t\t\t\t$this->writer->selectRecord( $table, array($property2=>array($bean->id)),null,true);\r\n\t\t\t}\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Given two beans this function returns TRUE if they are associated using a\r\n\t * many-to-many association, FALSE otherwise.\r\n\t *\r\n\t * @throws RedBean_Exception_SQL\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 bean\r\n\t * @param RedBean_OODBBean $bean2 bean\r\n\t *\r\n\t * @return bool $related whether they are associated N-M\r\n\t */\r\n\tpublic function areRelated(RedBean_OODBBean $bean1, RedBean_OODBBean $bean2) {\r\n\t\tif (!$bean1->getID() || !$bean2->getID()) return false;\r\n\t\t$table = $this->getTable( array($bean1->getMeta('type') , $bean2->getMeta('type')) );\r\n\t\t$type = $bean1->getMeta('type');\r\n\t\tif ($type==$bean2->getMeta('type')) {\r\n\t\t\t$type .= '2';\r\n\t\t\t$cross = 1;\r\n\t\t}\r\n\t\telse $cross = 0;\r\n\t\t$property1 = $type.'_id';\r\n\t\t$property2 = $bean2->getMeta('type').'_id';\r\n\t\t$value1 = (int) $bean1->id;\r\n\t\t$value2 = (int) $bean2->id;\r\n\t\ttry {\r\n\t\t\t$rows = $this->writer->selectRecord($table,array(\r\n\t\t\t\t$property1 => array($value1), $property2=>array($value2)),null\r\n\t\t\t);\r\n\t\t\tif ($cross) {\r\n\t\t\t\t$rows2 = $this->writer->selectRecord($table,array(\r\n\t\t\t\t$property2 => array($value1), $property1=>array($value2)),null\r\n\t\t\t\t);\r\n\t\t\t\t$rows = array_merge($rows,$rows2);\r\n\t\t\t}\r\n\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\tif (!$this->writer->sqlStateIn($e->getSQLState(),\r\n\t\t\tarray(\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t)) throw $e;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (count($rows)>0);\r\n\t}\r\n}\r\n\r\n/**\r\n * RedBean Extended Association\r\n * \r\n * @file\t\t\tRedBean/ExtAssociationManager.php\r\n * @description\t\tManages complex bean associations.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_AssociationManager_ExtAssociationManager extends RedBean_AssociationManager {\r\n\r\n\t/**\r\n\t * Associates two beans with eachother. This method connects two beans with eachother, just\r\n\t * like the other associate() method in the Association Manager. The difference is however\r\n\t * that this method accepts a base bean, this bean will be used as the basis of the\r\n\t * association record in the link table. You can thus add additional properties and\r\n\t * even foreign keys.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 bean 1\r\n\t * @param RedBean_OODBBean $bean2 bean 2\r\n\t * @param RedBean_OODBBean $bbean base bean for association record\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function extAssociate(RedBean_OODBBean $bean1, RedBean_OODBBean $bean2, RedBean_OODBBean $baseBean ) {\r\n\t\t$table = $this->getTable( array($bean1->getMeta('type') , $bean2->getMeta('type')) );\r\n\t\t$baseBean->setMeta('type', $table );\r\n\t\treturn $this->associateBeans( $bean1, $bean2, $baseBean );\r\n\t}\r\n}\r\n\r\n/**\r\n * RedBean Setup\r\n * Helper class to quickly setup RedBean for you.\r\n * \r\n * @file \t\t\tRedBean/Setup.php\r\n * @description\t\tHelper class to quickly setup RedBean for you\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Setup {\r\n\r\n\t/**\r\n\t * This method checks the DSN string. If the DSN string contains a\r\n\t * database name that is not supported by RedBean yet then it will\r\n\t * throw an exception RedBean_Exception_NotImplemented. In any other\r\n\t * case this method will just return boolean TRUE.\r\n\t * @throws RedBean_Exception_NotImplemented\r\n\t * @param string $dsn\r\n\t * @return boolean $true\r\n\t */\r\n\tprivate static function checkDSN($dsn) {\r\n\t\t$dsn = trim($dsn);\r\n\t\t$dsn = strtolower($dsn);\r\n\t\tif (\r\n\t\t\t\t\t strpos($dsn, 'mysql:')!==0\r\n\t\t\t\t  && strpos($dsn,'sqlite:')!==0\r\n\t\t\t\t  && strpos($dsn,'pgsql:')!==0\r\n\t\t\t\t  && strpos($dsn,'cubrid:')!==0\r\n\t\t\t\t  && strpos($dsn,'oracle:')!==0\r\n\t\t) {\r\n\t\t\ttrigger_error('Unsupported DSN');\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Generic Kickstart method.\r\n\t * This is the generic kickstarter. It will prepare a database connection\r\n\t * using the $dsn, the $username and the $password you provide.\r\n\t * If $frozen is boolean TRUE it will start RedBean in frozen mode, meaning\r\n\t * that the database cannot be altered. If RedBean is started in fluid mode\r\n\t * it will adjust the schema of the database if it detects an\r\n\t * incompatible bean.\r\n\t * This method returns a RedBean_Toolbox $toolbox filled with a\r\n\t * RedBean_Adapter, a RedBean_QueryWriter and most importantly a\r\n\t * RedBean_OODB; the object database. To start storing beans in the database\r\n\t * simply say: $redbean = $toolbox->getRedBean(); Now you have a reference\r\n\t * to the RedBean object.\r\n\t * Optionally instead of using $dsn you may use an existing PDO connection.\r\n\t * Example: RedBean_Setup::kickstart($existingConnection, true);\r\n\t *\r\n\t * @param  string|PDO $dsn      Database Connection String (or PDO instance)\r\n\t * @param  string     $username Username for database\r\n\t * @param  string     $password Password for database\r\n\t * @param  boolean    $frozen   Start in frozen mode?\r\n\t *\r\n\t * @return RedBean_ToolBox $toolbox\r\n\t */\r\n\tpublic static function kickstart($dsn,$username=NULL,$password=NULL,$frozen=false ) {\r\n\t\tif ($dsn instanceof PDO) {\r\n\t\t\t$db = new RedBean_Driver_PDO($dsn);\r\n\t\t\t$dsn = $db->getDatabaseType();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tself::checkDSN($dsn);\r\n\t\t\tif (strpos($dsn, 'oracle') === 0) \r\n\t\t\t\t$db = new RedBean_Driver_OCI($dsn,$username,$password);\t\r\n\t\t\telse\r\n\t\t\t\t$db = new RedBean_Driver_PDO($dsn,$username,$password);\r\n\r\n\t\t}\r\n\t\t$adapter = new RedBean_Adapter_DBAdapter($db);\r\n\t\tif (strpos($dsn,'pgsql')===0) {\r\n\t\t\t$writer = new RedBean_QueryWriter_PostgreSQL($adapter);\r\n\t\t}\r\n\t\telse if (strpos($dsn,'sqlite')===0) {\r\n\t\t\t$writer = new RedBean_QueryWriter_SQLiteT($adapter);\r\n\t\t}\r\n\t\telse if (strpos($dsn,'cubrid')===0) {\r\n\t\t\t$writer = new RedBean_QueryWriter_CUBRID($adapter);\r\n\t\t}\r\n\t\telse if (strpos($dsn,'oracle')===0) { $writer = new RedBean_QueryWriter_Oracle($adapter); }\t//layout important for unit test - this line cannot always be tested. \t\r\n\t\telse {\r\n\t\t\t$writer = new RedBean_QueryWriter_MySQL($adapter);\r\n\t\t}\r\n\t\t$redbean = new RedBean_OODB($writer);\r\n\t\tif ($frozen) $redbean->freeze(true);\r\n\t\t$toolbox = new RedBean_ToolBox($redbean,$adapter,$writer);\r\n\t\t//deliver everything back in a neat toolbox\r\n\t\treturn $toolbox;\r\n\t}\r\n}\r\n\r\n/**\r\n * RedBean interface for Model Formatting - Part of FUSE\r\n * \r\n * @file\t\t\tRedBean/ModelFormatter.php\r\n * @description \tRedBean IModelFormatter\r\n *\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\ninterface RedBean_IModelFormatter {\r\n\r\n\t/**\r\n\t * ModelHelper will call this method of the class\r\n\t * you provide to discover the model\r\n\t *\r\n\t * @param string $model\r\n\t *\r\n\t * @return string $formattedModel\r\n\t */\r\n\tpublic function formatModel( $model );\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean Logging\r\n * \r\n * @file\t\t\tRedBean/Logging.php\r\n * @description\t\tLogging interface for RedBeanPHP ORM,\r\n *\t\t\t\t\tprovides a uniform and convenient logging \r\n *\t\t\t\t\tinterface throughout RedBeanPHP.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\ninterface RedBean_Logger {\r\n\r\n  /**\r\n   * Method used to log messages.\r\n   * Writes the specified message to the log document whatever\r\n   * that may be (files, database etc). Provides a uniform\r\n   * interface for logging throughout RedBeanPHP.\r\n   *\r\n   * @param string $message the message to log. (optional)\r\n   */\r\n  public function log();\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean class for Logging\r\n * \r\n * @name    RedBean Logger\r\n * @file    RedBean/Logger.php\r\n * @author    Gabor de Mooij\r\n * @license   BSD\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Logger_Default implements RedBean_Logger {\r\n\r\n  /**\r\n   * Default logger method logging to STDOUT.\r\n   * This is the default/reference implementation of a logger.\r\n   * This method will write the message value to STDOUT (screen).\r\n   *\r\n   * @param $message (optional)\r\n   */\r\n  public function log() {\r\n    if (func_num_args() > 0) {\r\n      foreach (func_get_args() as $argument) {\r\n        if (is_array($argument)) echo print_r($argument,true); else echo $argument;\r\n\t\techo \"<br>\\n\";\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * RedBean Bean Helper Interface\r\n * \r\n * @file\t\t\tRedBean/IBeanHelper.php\r\n * @description\t\tInterface for Bean Helper.\r\n *\t\t\t\t\tA little bolt that glues the whole machinery together.\r\n * \t\t\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\ninterface RedBean_BeanHelper {\r\n\r\n\t/**\r\n\t * @abstract\r\n\t * @return RedBean_Toolbox $toolbox toolbox\r\n\t */\r\n\tpublic function getToolbox();\r\n\r\n\tpublic function getModelForBean(RedBean_OODBBean $bean);\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBean Bean Helper\r\n * @file\t\t\tRedBean/BeanHelperFacade.php\r\n * @description\t\tFinds the toolbox for the bean.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_BeanHelper_Facade implements RedBean_BeanHelper {\r\n\r\n\t/**\r\n\t * Returns a reference to the toolbox. This method returns a toolbox\r\n\t * for beans that need to use toolbox functions. Since beans can contain\r\n\t * lists they need a toolbox to lazy-load their relationships.\r\n\t *  \r\n\t * @return RedBean_ToolBox $toolbox toolbox containing all kinds of goodies\r\n\t */\r\n\tpublic function getToolbox() {\r\n\t\treturn RedBean_Facade::$toolbox;\r\n\t}\r\n\r\n\t/**\r\n\t * Fuse connector.\r\n\t * Gets the model for a bean $bean.\r\n\t * Allows you to implement your own way to find the\r\n\t * right model for a bean and to do dependency injection\r\n\t * etc.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean bean\r\n\t *  \r\n\t * @return type \r\n\t */\r\n\tpublic function getModelForBean(RedBean_OODBBean $bean) {\r\n\t\t$modelName = RedBean_ModelHelper::getModelName( $bean->getMeta('type'), $bean );\r\n\t\tif (!class_exists($modelName)) return null;\r\n\t\t$obj = RedBean_ModelHelper::factory($modelName);\r\n\t\t$obj->loadBean($bean);\r\n\t\treturn $obj;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * SimpleModel\r\n * \r\n * @file \t\tRedBean/SimpleModel.php\r\n * @description\tPart of FUSE\r\n * @author      Gabor de Mooij and the RedBeanPHP Team\r\n * @license\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_SimpleModel {\r\n\r\n\t/**\r\n\t * Contains the inner bean.\r\n\t * @var RedBean_OODBBean\r\n\t */\r\n\tprotected $bean;\r\n\r\n\t/**\r\n\t * Used by FUSE: the ModelHelper class to connect a bean to a model.\r\n\t * This method loads a bean in the model.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean bean\r\n\t */\r\n\tpublic function loadBean( RedBean_OODBBean $bean ) {\r\n\t\t$this->bean = $bean;\r\n\t}\r\n\r\n\t/**\r\n\t * Magic Getter to make the bean properties available from\r\n\t * the $this-scope.\r\n\t *\r\n\t * @param string $prop property\r\n\t *\r\n\t * @return mixed $propertyValue value\r\n\t */\r\n\tpublic function __get( $prop ) {\r\n\t\treturn $this->bean->$prop;\r\n\t}\r\n\r\n\t/**\r\n\t * Magic Setter\r\n\t *\r\n\t * @param string $prop  property\r\n\t * @param mixed  $value value\r\n\t */\r\n\tpublic function __set( $prop, $value ) {\r\n\t\t$this->bean->$prop = $value;\r\n\t}\r\n\r\n\t/**\r\n\t * Isset implementation\r\n\t *\r\n\t * @param  string $key key\r\n\t *\r\n\t * @return\r\n\t */\r\n\tpublic function __isset($key) {\r\n\t\treturn (isset($this->bean->$key));\r\n\t}\r\n\r\n\t/**\r\n\t * Box the bean using the current model.\r\n\t * \r\n\t * @return RedBean_SimpleModel $box a bean in a box\r\n\t */\r\n\tpublic function box() {\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Unbox the bean from the model.\r\n\t * \r\n\t * @return RedBean_OODBBean $bean bean \r\n\t */\r\n\tpublic function unbox(){\r\n\t\treturn $this->bean;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean Model Helper\r\n * \r\n * @file\t\t\tRedBean/ModelHelper.php\r\n * @description\t\tConnects beans to models, in essence \r\n *\t\t\t\t\tthis is the core of so-called FUSE.\r\n * \t\t\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\nclass RedBean_ModelHelper implements RedBean_Observer {\r\n\r\n\t/**\r\n\t * Holds a model formatter\r\n\t * @var RedBean_IModelFormatter\r\n\t */\r\n\tprivate static $modelFormatter;\r\n\r\n\r\n\t/**\r\n\t * Holds a dependency injector\r\n\t * @var type \r\n\t */\r\n\tprivate static $dependencyInjector;\r\n\r\n\t/**\r\n\t * Cache for model names to avoid unnecessary\r\n\t * reflections.\r\n\t * \r\n\t * @var array \r\n\t */\r\n\tprivate static $modelCache = array();\r\n\r\n\r\n\t/**\r\n\t * Connects OODB to a model if a model exists for that\r\n\t * type of bean. This connector is used in the facade.\r\n\t *\r\n\t * @param string $eventName\r\n\t * @param RedBean_OODBBean $bean\r\n\t */\r\n\tpublic function onEvent( $eventName, $bean ) {\r\n\t\t$bean->$eventName();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Given a model ID (model identifier) this method returns the\r\n\t * full model name.\r\n\t *\r\n\t * @param string $model\r\n\t * @param RedBean_OODBBean $bean\r\n\t * \r\n\t * @return string $fullname\r\n\t */\r\n\tpublic static function getModelName( $model, $bean = null ) {\r\n\t\tif (isset(self::$modelCache[$model])) return self::$modelCache[$model];\r\n\t\tif (self::$modelFormatter){\r\n\t\t\t$modelID = self::$modelFormatter->formatModel($model,$bean);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$modelID = 'Model_'.ucfirst($model);\r\n\t\t}\r\n\t\tself::$modelCache[$model] = $modelID;\r\n\t\treturn self::$modelCache[$model];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the model formatter to be used to discover a model\r\n\t * for Fuse.\r\n\t *\r\n\t * @param string $modelFormatter\r\n\t */\r\n\tpublic static function setModelFormatter( $modelFormatter ) {\r\n\t\tself::$modelFormatter = $modelFormatter;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Obtains a new instance of $modelClassName, using a dependency injection\r\n\t * container if possible.\r\n\t * \r\n\t * @param string $modelClassName name of the model\r\n\t */\r\n\tpublic static function factory( $modelClassName ) {\r\n\t\tif (self::$dependencyInjector) {\r\n\t\t\treturn self::$dependencyInjector->getInstance($modelClassName);\r\n\t\t}\r\n\t\treturn new $modelClassName();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the dependency injector to be used.\r\n\t * \r\n\t * @param RedBean_DependencyInjector $di injecto to be used\r\n\t */\r\n\tpublic static function setDependencyInjector( RedBean_DependencyInjector $di ) {\r\n\t\tself::$dependencyInjector = $di;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops the dependency injector from resolving dependencies. Removes the\r\n\t * reference to the dependency injector.\r\n\t */\r\n\tpublic static function clearDependencyInjector() {\r\n\t\tself::$dependencyInjector = null;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean SQL Helper\r\n *\r\n * @file\t\t\t\tRedBean/SQLHelper.php\r\n * @description\t\t\tAllows you to mix PHP and SQL as if they were\r\n * \t\t\t\t\t\ta unified language\r\n *\t\t\t\t\t\r\n *\t\t\t\t\t\tSimplest case:\r\n *\r\n *\t\t\t\t\t\t$r->now(); //returns SQL time\r\n *\r\n *\r\n *\t\t\t\t\t\tAnother Example:\r\n *\r\n *\t\t\t\t\t\t$f->begin()\r\n * \t\t\t\t\t\t->select('*')\r\n * \t\t\t\t\t\t->from('island')->where('id = ? ')->put(1)->get();\r\n *\r\n *\t\t\t\t\t\tAnother example:\r\n *\t\t\t\r\n *\t\t\t\t\t\t$f->begin()->show('tables')->get('col');\r\n *\r\n *\t\r\n * @author\t\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\n class RedBean_SQLHelper {\r\n\r\n\t/**\r\n\t * Holds the database adapter for executing SQL queries.\r\n\t * @var RedBean_Adapter \r\n\t */\r\n\tprotected $adapter;\r\n\r\n\t/**\r\n\t * Holds current mode\r\n\t * @var boolean\r\n\t */\r\n\tprotected $capture = false;\r\n\r\n\t/**\r\n\t * Holds SQL until now\r\n\t * @var string\r\n\t */\r\n\tprotected $sql = '';\r\n\r\n\t/**\r\n\t * Holds list of parameters for SQL Query\r\n\t * @var array\r\n\t */\r\n\tprotected $params = array();\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * \r\n\t * @param RedBean_DBAdapter $adapter database adapter for querying\r\n\t */\r\n\tpublic function __construct(RedBean_Adapter $adapter) {\r\n\t\t$this->adapter = $adapter;\r\n\t}\r\n\r\n\t/**\r\n\t * Magic method to construct SQL query\r\n\t * \r\n\t * @param string $funcName name of the next SQL statement/keyword\r\n\t * @param array  $args     list of statements to be seperated by commas\r\n\t * \r\n\t * @return mixed $result   either self or result depending on mode \r\n\t */\r\n\tpublic function __call($funcName,$args=array()) {\r\n\t\t$funcName = str_replace('_',' ',$funcName);\r\n\t\tif ($this->capture) {\r\n\t\t\t$this->sql .= ' '.$funcName . ' '.implode(',', $args);\r\n\t\t\treturn $this;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn $this->adapter->getCell('SELECT '.$funcName.'('.implode(',',$args).')');\t\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Begins SQL query\r\n\t * \r\n\t * @return RedBean_SQLHelper $this chainable\r\n\t */\r\n\tpublic function begin() {\r\n\t\t$this->capture = true;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a value to the parameter list\r\n\t * \r\n\t * @param mixed $param parameter to be added\r\n\t * \r\n\t * @return RedBean_SQLHelper $this chainable\r\n\t */\r\n\tpublic function put($param) {\r\n\t\t$this->params[] = $param;\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Executes query and returns result\r\n\t * \r\n\t * @return mixed $result\r\n\t */\r\n\tpublic function get($what='') {\r\n\t\t$what = 'get'.ucfirst($what);\r\n\t\t$rs = $this->adapter->$what($this->sql,$this->params);\r\n\t\t$this->clear();\r\n\t\treturn $rs;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the parameter list as well as the SQL query string.\r\n\t * \r\n\t * @return RedBean_SQLHelper $this chainable\r\n\t */\r\n\tpublic function clear() {\r\n\t\t$this->sql = '';\r\n\t\t$this->params = array();\r\n\t\t$this->capture = false; //turn off capture mode (issue #142)\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * To explicitly add a piece of SQL.\r\n\t * \r\n\t * @param string $sql sql\r\n\t * \r\n\t * @return RedBean_SQLHelper \r\n\t */\r\n\tpublic function addSQL($sql) {\r\n\t\tif ($this->capture) {\r\n\t\t\t$this->sql .= ' '.$sql . ' ';\r\n\t\t\treturn $this;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns query parts.\r\n\t * \r\n\t * @return array $queryParts query parts. \r\n\t */\r\n\tpublic function getQuery() {\r\n\t\t$list = array($this->sql,$this->params);\r\n\t\t$this->clear();\r\n\t\treturn $list;\r\n\t}\r\n\r\n\t/**\r\n\t * Writes a '(' to the sql query.\r\n\t */\r\n\tpublic function open() {\r\n\t\tif ($this->capture) {\r\n\t\t\t$this->sql .= ' ( ';\r\n\t\t\treturn $this;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Writes a ')' to the sql query.\r\n\t */\r\n\tpublic function close() {\r\n\t\tif ($this->capture) {\r\n\t\t\t$this->sql .= ' ) ';\r\n\t\t\treturn $this;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean Tag Manager\r\n * \r\n * @file\t\t\tRedBean/TagManager.php\r\n * @description \tRedBean Tag Manager\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * Provides methods to tag beans and perform tag-based searches in the\r\n * bean database.\r\n * \r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_TagManager {\r\n\r\n\t/**\r\n\t * The Tag Manager requires a toolbox\r\n\t * @var RedBean_Toolbox \r\n\t */\r\n\tprotected $toolbox;\r\n\r\n\t/**\r\n\t * Association Manager to manage tag-bean relations\r\n\t * @var RedBean_AssociationManager\r\n\t */\r\n\tprotected $associationManager;\r\n\r\n\t/**\r\n\t * RedBeanPHP OODB instance\r\n\t * @var RedBean_OODBBean \r\n\t */\r\n\tprotected $redbean;\r\n\r\n\t/**\r\n\t * Constructor,\r\n\t * creates a new instance of TagManager.\r\n\t * @param RedBean_Toolbox $toolbox \r\n\t */\r\n\tpublic function __construct( RedBean_Toolbox $toolbox ) {\r\n\t\t$this->toolbox = $toolbox;\r\n\t\t$this->redbean = $toolbox->getRedBean();\r\n\t\t$this->associationManager = $this->redbean->getAssociationManager();\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a tag bean by it's title.\r\n\t * \r\n\t * @param string $title title\r\n\t * \r\n\t * @return RedBean_OODBBean $bean | null\r\n\t */\r\n\tpublic function findTagByTitle($title) {\r\n\t\t$beans = $this->redbean->find('tag',array('title'=>array($title)));\r\n\t\tif ($beans) {\r\n\t\t\t$bean = reset($beans);\r\n\t\t\treturn $bean;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Tests whether a bean has been associated with one ore more\r\n\t * of the listed tags. If the third parameter is TRUE this method\r\n\t * will return TRUE only if all tags that have been specified are indeed\r\n\t * associated with the given bean, otherwise FALSE.\r\n\t * If the third parameter is FALSE this\r\n\t * method will return TRUE if one of the tags matches, FALSE if none\r\n\t * match.\r\n\t *\r\n\t * @param  RedBean_OODBBean $bean bean to check for tags\r\n\t * @param  array            $tags list of tags\r\n\t * @param  boolean          $all  whether they must all match or just some\r\n\t *\r\n\t * @return boolean $didMatch whether the bean has been assoc. with the tags\r\n\t */\r\n\tpublic function hasTag($bean, $tags, $all=false) {\r\n\t\t$foundtags = $this->tag($bean);\r\n\t\tif (is_string($foundtags)) $foundtags = explode(\",\",$tags);\r\n\t\t$same = array_intersect($tags,$foundtags);\r\n\t\tif ($all) {\r\n\t\t\treturn (implode(\",\",$same)===implode(\",\",$tags));\r\n\t\t}\r\n\t\treturn (bool) (count($same)>0);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Removes all sepcified tags from the bean. The tags specified in\r\n\t * the second parameter will no longer be associated with the bean.\r\n\t *\r\n\t * @param  RedBean_OODBBean $bean    tagged bean\r\n\t * @param  array            $tagList list of tags (names)\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function untag($bean,$tagList) {\r\n\t\tif ($tagList!==false && !is_array($tagList)) $tags = explode( \",\", (string)$tagList); else $tags=$tagList;\r\n\t\tforeach($tags as $tag) {\r\n\t\t\tif ($t = $this->findTagByTitle($tag)) {\r\n\t\t\t\t$this->associationManager->unassociate( $bean, $t );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Tags a bean or returns tags associated with a bean.\r\n\t * If $tagList is null or omitted this method will return a\r\n\t * comma separated list of tags associated with the bean provided.\r\n\t * If $tagList is a comma separated list (string) of tags all tags will\r\n\t * be associated with the bean.\r\n\t * You may also pass an array instead of a string.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean    bean\r\n\t * @param mixed\t\t\t\t$tagList tags\r\n\t *\r\n\t * @return string $commaSepListTags\r\n\t */\r\n\tpublic function tag( RedBean_OODBBean $bean, $tagList = null ) {\r\n\t\tif (is_null($tagList)) {\r\n\t\t\t$tags = array();\r\n\t\t\t$keys = $this->associationManager->related($bean, 'tag'); \r\n\t\t\tif ($keys) {\r\n\t\t\t\t$tags = $this->redbean->batch('tag',$keys);\r\n\t\t\t}\r\n\t\t\t$foundTags = array();\r\n\t\t\tforeach($tags as $tag) {\r\n\t\t\t\t$foundTags[] = $tag->title;\r\n\t\t\t}\r\n\t\t\treturn $foundTags;\r\n\t\t}\r\n\t\t$this->associationManager->clearRelations( $bean, 'tag' );\r\n\t\t$this->addTags( $bean, $tagList );\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Adds tags to a bean.\r\n\t * If $tagList is a comma separated list of tags all tags will\r\n\t * be associated with the bean.\r\n\t * You may also pass an array instead of a string.\r\n\t *\r\n\t * @param RedBean_OODBBean  $bean    bean\r\n\t * @param array\t\t\t\t$tagList list of tags to add to bean\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function addTags( RedBean_OODBBean $bean, $tagList ) {\r\n\t\tif ($tagList!==false && !is_array($tagList)) $tags = explode( \",\", (string)$tagList); else $tags=$tagList;\r\n\t\tif ($tagList===false) return;\r\n\t\tforeach($tags as $tag) {\r\n\t\t\tif (!$t = $this->findTagByTitle($tag)) {\r\n\t\t\t\t$t = $this->redbean->dispense('tag');\r\n\t\t\t\t$t->title = $tag;\r\n\t\t\t\t$this->redbean->store($t);\r\n\t\t\t}\r\n\t\t\t$this->associationManager->associate( $bean, $t );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Returns all beans that have been tagged with one of the tags given.\r\n\t *\r\n\t * @param  $beanType type of bean you are looking for\r\n\t * @param  $tagList  list of tags to match\r\n\t *\r\n\t * @return array\r\n\t */\r\n\tpublic function tagged( $beanType, $tagList ) {\r\n\t\tif ($tagList!==false && !is_array($tagList)) $tags = explode( \",\", (string)$tagList); else $tags=$tagList;\r\n\t\t$collection = array();\r\n\t\t$tags = $this->redbean->find('tag',array('title'=>$tags));\r\n\t\tif (count($tags)>0) {\r\n\t\t\t$collectionKeys = $this->associationManager->related($tags,$beanType);\r\n\t\t\tif ($collectionKeys) {\r\n\t\t\t\t$collection = $this->redbean->batch($beanType,$collectionKeys);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $collection;\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Returns all beans that have been tagged with ALL of the tags given.\r\n\t *\r\n\t * @param  $beanType type of bean you are looking for\r\n\t * @param  $tagList  list of tags to match\r\n\t *\r\n\t * @return array\r\n\t */\r\n\tpublic function taggedAll( $beanType, $tagList ) {\r\n\t\tif ($tagList!==false && !is_array($tagList)) $tags = explode( \",\", (string)$tagList); else $tags=$tagList;\r\n\t\t$beans = array();\r\n\t\tforeach($tags as $tag) {\r\n\t\t\t$beans = $this->tagged($beanType,$tag);\r\n\t\t\tif (isset($oldBeans)) $beans = array_intersect_assoc($beans,$oldBeans);\r\n\t\t\t$oldBeans = $beans;\r\n\t\t}\r\n\t\treturn $beans;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean Facade\r\n * @file\t\t\tRedBean/Facade.php\r\n * @description\t\tConvenience class for RedBeanPHP.\r\n *\t\t\t\t\tThis class hides the object landscape of\r\n *\t\t\t\t\tRedBeanPHP behind a single letter class providing\r\n *\t\t\t\t\talmost all functionality with simple static calls.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\nclass RedBean_Facade {\r\n\r\n\t/**\r\n\t * Collection of toolboxes\r\n\t * @var array\r\n\t */\r\n\tpublic static $toolboxes = array();\r\n\t/**\r\n\t *\r\n\t * Constains an instance of the RedBean Toolbox\r\n\t * @var RedBean_ToolBox\r\n\t *\r\n\t */\r\n\tpublic static $toolbox;\r\n\r\n\t/**\r\n\t * Constains an instance of RedBean OODB\r\n\t * @var RedBean_OODB\r\n\t */\r\n\tpublic static $redbean;\r\n\r\n\t/**\r\n\t * Contains an instance of the Query Writer\r\n\t * @var RedBean_QueryWriter\r\n\t */\r\n\tpublic static $writer;\r\n\r\n\t/**\r\n\t * Contains an instance of the Database\r\n\t * Adapter.\r\n\t * @var RedBean_DBAdapter\r\n\t */\r\n\tpublic static $adapter;\r\n\r\n\r\n\t/**\r\n\t * Contains an instance of the Association Manager\r\n\t * @var RedBean_AssociationManager\r\n\t */\r\n\tpublic static $associationManager;\r\n\r\n\r\n\t/**\r\n\t * Contains an instance of the Extended Association Manager\r\n\t * @var RedBean_ExtAssociationManager\r\n\t */\r\n\tpublic static $extAssocManager;\r\n\r\n\t/**\r\n\t * Holds the tag manager\r\n\t * @var RedBean_TagManager\r\n\t */\r\n\tpublic static $tagManager;\r\n\r\n\t/**\r\n\t * holds the duplication manager\r\n\t * @var RedBean_DuplicationManager \r\n\t */\r\n\tpublic static $duplicationManager;\r\n\r\n\t/**\r\n\t * Holds the Key of the current database.\r\n\t * @var string\r\n\t */\r\n\tpublic static $currentDB = '';\r\n\r\n\t/**\r\n\t * Holds reference to SQL Helper\r\n\t */\r\n\tpublic static $f;\r\n\r\n\r\n\tprivate static $strictType = true;\r\n\r\n\r\n\t/**\r\n\t * Get version\r\n\t * @return string\r\n\t */\r\n\tpublic static function getVersion() {\r\n\t\treturn '3.3';\r\n\t}\r\n\r\n\t/**\r\n\t * Kickstarts redbean for you. This method should be called before you start using\r\n\t * RedBean. The Setup() method can be called without any arguments, in this case it will\r\n\t * try to create a SQLite database in /tmp called red.db (this only works on UNIX-like systems).\r\n\t *\r\n\t * @param string $dsn      Database connection string\r\n\t * @param string $username Username for database\r\n\t * @param string $password Password for database\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function setup( $dsn=NULL, $username=NULL, $password=NULL ) {\r\n\t\tif (function_exists('sys_get_temp_dir')) $tmp = sys_get_temp_dir(); else $tmp = 'tmp';\r\n\t\tif (is_null($dsn)) $dsn = 'sqlite:/'.$tmp.'/red.db';\r\n\t\tself::addDatabase('default',$dsn,$username,$password);\r\n\t\tself::selectDatabase('default');\r\n\t\treturn self::$toolbox;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Adds a database to the facade, afterwards you can select the database using\r\n\t * selectDatabase($key).\r\n\t *\r\n\t * @param string      $key    ID for the database\r\n\t * @param string      $dsn    DSN for the database\r\n\t * @param string      $user   User for connection\r\n\t * @param null|string $pass   Password for connection\r\n\t * @param bool        $frozen Whether this database is frozen or not\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function addDatabase( $key, $dsn, $user=null, $pass=null, $frozen=false ) {\r\n\t\tself::$toolboxes[$key] = RedBean_Setup::kickstart($dsn,$user,$pass,$frozen);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Selects a different database for the Facade to work with.\r\n\t *\r\n\t * @param  string $key Key of the database to select\r\n\t * @return int 1\r\n\t */\r\n\tpublic static function selectDatabase($key) {\r\n\t\tif (self::$currentDB===$key) return false;\r\n\t\tself::configureFacadeWithToolbox(self::$toolboxes[$key]);\r\n\t\tself::$currentDB = $key;\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Toggles DEBUG mode.\r\n\t * In Debug mode all SQL that happens under the hood will\r\n\t * be printed to the screen or logged by provided logger.\r\n\t *\r\n\t * @param boolean $tf\r\n\t * @param RedBean_Logger $logger\r\n\t */\r\n\tpublic static function debug( $tf = true, $logger = NULL ) {\r\n\t\tif (!$logger) $logger = new RedBean_Logger_Default;\r\n\t\tself::$adapter->getDatabase()->setDebugMode( $tf, $logger );\r\n\t}\r\n\r\n\t/**\r\n\t * Stores a RedBean OODB Bean and returns the ID.\r\n\t *\r\n\t * @param  RedBean_OODBBean|RedBean_SimpleModel $bean bean\r\n\t *\r\n\t * @return integer $id id\r\n\t */\r\n\tpublic static function store( $bean ) {\r\n\t\treturn self::$redbean->store( $bean );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Toggles fluid or frozen mode. In fluid mode the database\r\n\t * structure is adjusted to accomodate your objects. In frozen mode\r\n\t * this is not the case.\r\n\t *\r\n\t * You can also pass an array containing a selection of frozen types.\r\n\t * Let's call this chilly mode, it's just like fluid mode except that\r\n\t * certain types (i.e. tables) aren't touched.\r\n\t *\r\n\t * @param boolean|array $trueFalse\r\n\t */\r\n\tpublic static function freeze( $tf = true ) {\r\n\t\tself::$redbean->freeze( $tf );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Loads the bean with the given type and id and returns it.\r\n\t *\r\n\t * @param string  $type type\r\n\t * @param integer $id   id of the bean you want to load\r\n\t *\r\n\t * @return RedBean_OODBBean $bean\r\n\t */\r\n\tpublic static function load( $type, $id ) {\r\n\t\treturn self::$redbean->load( $type, $id );\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the specified bean.\r\n\t *\r\n\t * @param RedBean_OODBBean|RedBean_SimpleModel $bean bean to be deleted\r\n\t *\r\n\t * @return mixed\r\n\t */\r\n\tpublic static function trash( $bean ) {\r\n\t\treturn self::$redbean->trash( $bean );\r\n\t}\r\n\r\n\t/**\r\n\t * Dispenses a new RedBean OODB Bean for use with\r\n\t * the rest of the methods.\r\n\t *\r\n\t * @param string $type type\r\n\t *\r\n\t *\r\n\t */\r\n\tpublic static function dispense( $type, $num = 1 ) {\r\n\t\tif (!preg_match('/^[a-z0-9_]+$/',$type) && self::$strictType) throw new RedBean_Exception_Security('Invalid type: '.$type);\r\n\t\tif ($num==1) {\r\n\t\t\treturn self::$redbean->dispense( $type );\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$beans = array();\r\n\t\t\tfor($v=0; $v<$num; $v++) $beans[] = self::$redbean->dispense( $type );\r\n\t\t\treturn $beans;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tpublic static function setStrictTyping($trueFalse) {\r\n\t\tself::$strictType = (boolean) $trueFalse;\r\n\t}\r\n\r\n\t/**\r\n\t * Convience method. Tries to find beans of a certain type,\r\n\t * if no beans are found, it dispenses a bean of that type.\r\n\t *\r\n\t * @param  string $type   type of bean you are looking for\r\n\t * @param  string $sql    SQL code for finding the bean\r\n\t * @param  array  $values parameters to bind to SQL\r\n\t *\r\n\t * @return array $beans Contains RedBean_OODBBean instances\r\n\t */\r\n\tpublic static function findOrDispense( $type, $sql, $values ) {\r\n\t\t$foundBeans = self::find($type,$sql,$values);\r\n\t\tif (count($foundBeans)==0) return array(self::dispense($type)); else return $foundBeans;\r\n\t}\r\n\r\n\t/**\r\n\t * Associates two Beans. This method will associate two beans with eachother.\r\n\t * You can then get one of the beans by using the related() function and\r\n\t * providing the other bean. You can also provide a base bean in the extra\r\n\t * parameter. This base bean allows you to add extra information to the association\r\n\t * record. Note that this is for advanced use only and the information will not\r\n\t * be added to one of the beans, just to the association record.\r\n\t * It's also possible to provide an array or JSON string as base bean. If you\r\n\t * pass a scalar this function will interpret the base bean as having one\r\n\t * property called 'extra' with the value of the scalar.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 bean that will be part of the association\r\n\t * @param RedBean_OODBBean $bean2 bean that will be part of the association\r\n\t * @param mixed $extra            bean, scalar, array or JSON providing extra data.\r\n\t *\r\n\t * @return mixed\r\n\t */\r\n\tpublic static function associate( $beans1, $beans2, $extra = null ) {\r\n\t\t//No extra? Just associate like always (default)\r\n\t\tif (!$extra) {\r\n\t\t\treturn self::$associationManager->associate( $beans1, $beans2 );\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif (!is_array($extra)) {\r\n\t\t\t\t$info = json_decode($extra,true);\r\n\t\t\t\tif (!$info) $info = array('extra'=>$extra);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$info = $extra;\r\n\t\t\t}\r\n\t\t\t$bean = RedBean_Facade::dispense('xtypeless');\r\n\t\t\t$bean->import($info);\r\n\t\t\treturn self::$extAssocManager->extAssociate($beans1, $beans2, $bean);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Breaks the association between two beans.\r\n\t * This functions breaks the association between a pair of beans. After\r\n\t * calling this functions the beans will no longer be associated with\r\n\t * eachother. Calling related() with either one of the beans will no longer\r\n\t * return the other bean.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 bean\r\n\t * @param RedBean_OODBBean $bean2 bean\r\n\t *\r\n\t * @return mixed\r\n\t */\r\n\tpublic static function unassociate( $beans1,  $beans2 , $fast=false) {\r\n\t\treturn self::$associationManager->unassociate( $beans1, $beans2, $fast );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all the beans associated with $bean.\r\n\t * This method will return an array containing all the beans that have\r\n\t * been associated once with the associate() function and are still\r\n\t * associated with the bean specified. The type parameter indicates the\r\n\t * type of beans you are looking for. You can also pass some extra SQL and\r\n\t * values for that SQL to filter your results after fetching the\r\n\t * related beans.\r\n\t *\r\n\t * Dont try to make use of subqueries, a subquery using IN() seems to\r\n\t * be slower than two queries!\r\n\t *\r\n\t * Since 3.2, you can now also pass an array of beans instead just one\r\n\t * bean as the first parameter.\r\n\t *\r\n\t * @param RedBean_OODBBean|array $bean the bean you have\r\n\t * @param string\t\t\t\t $type the type of beans you want\r\n\t * @param string\t\t\t\t $sql  SQL snippet for extra filtering\r\n\t * @param array\t\t\t\t\t $val  values to be inserted in SQL slots\r\n\t *\r\n\t * @return array $beans\tbeans yielded by your query.\r\n\t */\r\n\tpublic static function related( $bean, $type, $sql=null, $values=array()) {\r\n\t\t$keys = self::$associationManager->related( $bean, $type );\r\n\t\tif (count($keys)==0) return array();\r\n\t\tif (!$sql) return self::batch($type, $keys);\r\n\t\t$rows = self::$writer->selectRecord( $type, array('id'=>$keys),array($sql,$values),false );\r\n\t\treturn self::$redbean->convertToBeans($type,$rows);\r\n\t}\r\n\r\n\t/**\r\n\t* Returns only single associated bean.\r\n\t*\r\n\t* @param RedBean_OODBBean $bean bean provided\r\n\t* @param string $type type of bean you are searching for\r\n\t* @param string $sql SQL for extra filtering\r\n\t* @param array $values values to be inserted in SQL slots\r\n\t*\r\n\t*\r\n\t* @return RedBean_OODBBean $bean\r\n\t*/\r\n\tpublic static function relatedOne( RedBean_OODBBean $bean, $type, $sql=null, $values=array() ) {\r\n\t\t$beans = self::related($bean, $type, $sql, $values);\r\n\t\tif (count($beans)==0) return null;\r\n\t\treturn reset( $beans );\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a pair of beans is related N-M. This function does not\r\n\t * check whether the beans are related in N:1 way.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean1 first bean\r\n\t * @param RedBean_OODBBean $bean2 second bean\r\n\t *\r\n\t * @return bool $yesNo whether they are related\r\n\t */\r\n\tpublic static function areRelated( RedBean_OODBBean $bean1, RedBean_OODBBean $bean2) {\r\n\t\treturn self::$associationManager->areRelated($bean1,$bean2);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * The opposite of related(). Returns all the beans that are not\r\n\t * associated with the bean provided.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean   bean provided\r\n\t * @param string           $type   type of bean you are searching for\r\n\t * @param string           $sql    SQL for extra filtering\r\n\t * @param array            $values values to be inserted in SQL slots\r\n\t *\r\n\t * @return array $beans beans\r\n\t */\r\n\tpublic static function unrelated(RedBean_OODBBean $bean, $type, $sql=null, $values=array()) {\r\n\t\t$keys = self::$associationManager->related( $bean, $type );\r\n\t\t$rows = self::$writer->selectRecord( $type, array('id'=>$keys), array($sql,$values), false, true );\r\n\t\treturn self::$redbean->convertToBeans($type,$rows);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Clears all associated beans.\r\n\t * Breaks all many-to-many associations of a bean and a specified type.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean bean you wish to clear many-to-many relations for\r\n\t * @param string           $type type of bean you wish to break associatons with\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function clearRelations( RedBean_OODBBean $bean, $type ) {\r\n\t\tself::$associationManager->clearRelations( $bean, $type );\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a bean using a type and a where clause (SQL).\r\n\t * As with most Query tools in RedBean you can provide values to\r\n\t * be inserted in the SQL statement by populating the value\r\n\t * array parameter; you can either use the question mark notation\r\n\t * or the slot-notation (:keyname).\r\n\t *\r\n\t * @param string $type   type   the type of bean you are looking for\r\n\t * @param string $sql    sql    SQL query to find the desired bean, starting right after WHERE clause\r\n\t * @param array  $values values array of values to be bound to parameters in query\r\n\t *\r\n\t * @return array $beans  beans\r\n\t */\r\n\tpublic static function find( $type, $sql=null, $values=array() ) {\r\n\t\tif ($sql instanceof RedBean_SQLHelper) list($sql,$values) = $sql->getQuery();\r\n\t\tif (!is_array($values)) throw new InvalidArgumentException('Expected array, ' . gettype($values) . ' given.');\r\n\t\treturn self::$redbean->find($type,array(),array($sql,$values));\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a bean using a type and a where clause (SQL).\r\n\t * As with most Query tools in RedBean you can provide values to\r\n\t * be inserted in the SQL statement by populating the value\r\n\t * array parameter; you can either use the question mark notation\r\n\t * or the slot-notation (:keyname).\r\n\t * The findAll() method differs from the find() method in that it does\r\n\t * not assume a WHERE-clause, so this is valid:\r\n\t *\r\n\t * R::findAll('person',' ORDER BY name DESC ');\r\n\t *\r\n\t * Your SQL does not have to start with a valid WHERE-clause condition.\r\n\t *\r\n\t * @param string $type   type   the type of bean you are looking for\r\n\t * @param string $sql    sql    SQL query to find the desired bean, starting right after WHERE clause\r\n\t * @param array  $values values array of values to be bound to parameters in query\r\n\t *\r\n\t * @return array $beans  beans\r\n\t */\r\n\tpublic static function findAll( $type, $sql=null, $values=array() ) {\r\n\t\tif (!is_array($values)) throw new InvalidArgumentException('Expected array, ' . gettype($values) . ' given.');\r\n\t\treturn self::$redbean->find($type,array(),array($sql,$values),true);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a bean using a type and a where clause (SQL).\r\n\t * As with most Query tools in RedBean you can provide values to\r\n\t * be inserted in the SQL statement by populating the value\r\n\t * array parameter; you can either use the question mark notation\r\n\t * or the slot-notation (:keyname).\r\n\t * The variation also exports the beans (i.e. it returns arrays).\r\n\t *\r\n\t * @param string $type   type   the type of bean you are looking for\r\n\t * @param string $sql    sql    SQL query to find the desired bean, starting right after WHERE clause\r\n\t * @param array  $values values array of values to be bound to parameters in query\r\n\t *\r\n\t * @return array $arrays arrays\r\n\t */\r\n\tpublic static function findAndExport($type, $sql=null, $values=array()) {\r\n\t\t$items = self::find( $type, $sql, $values );\r\n\t\t$arr = array();\r\n\t\tforeach($items as $key=>$item) {\r\n\t\t\t$arr[$key]=$item->export();\r\n\t\t}\r\n\t\treturn $arr;\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a bean using a type and a where clause (SQL).\r\n\t * As with most Query tools in RedBean you can provide values to\r\n\t * be inserted in the SQL statement by populating the value\r\n\t * array parameter; you can either use the question mark notation\r\n\t * or the slot-notation (:keyname).\r\n\t * This variation returns the first bean only.\r\n\t *\r\n\t * @param string $type   type   the type of bean you are looking for\r\n\t * @param string $sql    sql    SQL query to find the desired bean, starting right after WHERE clause\r\n\t * @param array  $values values array of values to be bound to parameters in query\r\n\t *\r\n\t * @return RedBean_OODBBean $bean\r\n\t */\r\n\tpublic static function findOne( $type, $sql=null, $values=array()) {\r\n\t\t$items = self::find($type,$sql,$values);\r\n\t\t$found = reset($items);\r\n\t\tif (!$found) return null;\r\n\t\treturn $found;\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a bean using a type and a where clause (SQL).\r\n\t * As with most Query tools in RedBean you can provide values to\r\n\t * be inserted in the SQL statement by populating the value\r\n\t * array parameter; you can either use the question mark notation\r\n\t * or the slot-notation (:keyname).\r\n\t * This variation returns the last bean only.\r\n\t *\r\n\t * @param string $type   type   the type of bean you are looking for\r\n\t * @param string $sql    sql    SQL query to find the desired bean, starting right after WHERE clause\r\n\t * @param array  $values values array of values to be bound to parameters in query\r\n\t *\r\n\t * @return RedBean_OODBBean $bean\r\n\t */\r\n\tpublic static function findLast( $type, $sql=null, $values=array() ) {\r\n\t\t$items = self::find( $type, $sql, $values );\r\n\t\t$found = end( $items );\r\n\t\tif (!$found) return null;\r\n\t\treturn $found;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array of beans. Pass a type and a series of ids and\r\n\t * this method will bring you the correspondig beans.\r\n\t *\r\n\t * important note: Because this method loads beans using the load()\r\n\t * function (but faster) it will return empty beans with ID 0 for\r\n\t * every bean that could not be located. The resulting beans will have the\r\n\t * passed IDs as their keys.\r\n\t *\r\n\t * @param string $type type of beans\r\n\t * @param array  $ids  ids to load\r\n\t *\r\n\t * @return array $beans resulting beans (may include empty ones)\r\n\t */\r\n\tpublic static function batch( $type, $ids ) {\r\n\t\treturn self::$redbean->batch($type, $ids);\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return integer $affected  number of affected rows\r\n\t */\r\n\tpublic static function exec( $sql, $values=array() ) {\r\n\t\treturn self::query('exec',$sql,$values);\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return array $results\r\n\t */\r\n\tpublic static function getAll( $sql, $values=array() ) {\r\n\t\treturn self::query('get',$sql,$values);\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return string $result scalar\r\n\t */\r\n\tpublic static function getCell( $sql, $values=array() ) {\r\n\t\treturn self::query('getCell',$sql,$values);\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return array $results\r\n\t */\r\n\tpublic static function getRow( $sql, $values=array() ) {\r\n\t\treturn self::query('getRow',$sql,$values);\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return array $results\r\n\t */\r\n\tpublic static function getCol( $sql, $values=array() ) {\r\n\t\treturn self::query('getCol',$sql,$values);\r\n\t}\r\n\r\n\t/**\r\n\t * Internal Query function, executes the desired query. Used by\r\n\t * all facade query functions. This keeps things DRY.\r\n\t *\r\n\t * @throws RedBean_Exception_SQL\r\n\t *\r\n\t * @param string $method desired query method (i.e. 'cell','col','exec' etc..)\r\n\t * @param string $sql    the sql you want to execute\r\n\t * @param array  $values array of values to be bound to query statement\r\n\t *\r\n\t * @return array $results results of query\r\n\t */\r\n\tprivate static function query($method,$sql,$values) {\r\n\t\tif (!self::$redbean->isFrozen()) {\r\n\t\t\ttry {\r\n\t\t\t\t$rs = RedBean_Facade::$adapter->$method( $sql, $values );\r\n\t\t\t}catch(RedBean_Exception_SQL $e) {\r\n\t\t\t\tif(self::$writer->sqlStateIn($e->getSQLState(),\r\n\t\t\t\tarray(\r\n\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_COLUMN,\r\n\t\t\t\tRedBean_QueryWriter::C_SQLSTATE_NO_SUCH_TABLE)\r\n\t\t\t\t)) {\r\n\t\t\t\t\treturn array();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow $e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $rs;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn RedBean_Facade::$adapter->$method( $sql, $values );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Convenience function to execute Queries directly.\r\n\t * Executes SQL.\r\n\t * Results will be returned as an associative array. The first\r\n\t * column in the select clause will be used for the keys in this array and\r\n\t * the second column will be used for the values. If only one column is\r\n\t * selected in the query, both key and value of the array will have the\r\n\t * value of this field for each row.\r\n\t *\r\n\t * @param string $sql\t sql    SQL query to execute\r\n\t * @param array  $values values a list of values to be bound to query parameters\r\n\t *\r\n\t * @return array $results\r\n\t */\r\n\tpublic static function getAssoc($sql,$values=array()) {\r\n\t\treturn self::query('getAssoc',$sql,$values);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Makes a copy of a bean. This method makes a deep copy\r\n\t * of the bean.The copy will have the following features.\r\n\t * - All beans in own-lists will be duplicated as well\r\n\t * - All references to shared beans will be copied but not the shared beans themselves\r\n\t * - All references to parent objects (_id fields) will be copied but not the parents themselves\r\n\t * In most cases this is the desired scenario for copying beans.\r\n\t * This function uses a trail-array to prevent infinite recursion, if a recursive bean is found\r\n\t * (i.e. one that already has been processed) the ID of the bean will be returned.\r\n\t * This should not happen though.\r\n\t *\r\n\t * Note:\r\n\t * This function does a reflectional database query so it may be slow.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean  bean to be copied\r\n\t * @param array            $trail for internal usage, pass array()\r\n\t * @param boolean          $pid   for internal usage\r\n\t *\r\n\t * @return array $copiedBean the duplicated bean\r\n\t */\r\n\tpublic static function dup($bean,$trail=array(),$pid=false,$filters=array()) {\r\n\t\tself::$duplicationManager->setFilters($filters);\r\n\t\treturn self::$duplicationManager->dup($bean, $trail,$pid);\r\n\t}\r\n\r\n\t/**\r\n\t * Exports a collection of beans. Handy for XML/JSON exports with a\r\n\t * Javascript framework like Dojo or ExtJS.\r\n\t * What will be exported:\r\n\t * - contents of the bean\r\n\t * - all own bean lists (recursively)\r\n\t * - all shared beans (not THEIR own lists)\r\n\t *\r\n\t * @param\tarray|RedBean_OODBBean $beans beans to be exported\r\n\t *\r\n\t * @return\tarray $array exported structure\r\n\t */\r\n\tpublic static function exportAll($beans,$parents=false,$filters=array()) {\r\n\t\t$array = array();\r\n\t\tif (!is_array($beans)) $beans = array($beans);\r\n\t\tforeach($beans as $bean) {\r\n\t\t\t$f = self::dup($bean,array(),true,$filters);\r\n\t\t\t$array[] = $f->export(false,$parents,false,$filters);\r\n\t\t}\r\n\t\treturn $array;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Given an array of two beans and a property, this method\r\n\t * swaps the value of the property.\r\n\t * This is handy if you need to swap the priority or orderNo\r\n\t * of an item (i.e. bug-tracking, page order).\r\n\t *\r\n\t * @param array  $beans    beans\r\n\t * @param string $property property\r\n\t */\r\n\tpublic static function swap( $beans, $property ) {\r\n\t\t$bean1 = array_shift($beans);\r\n\t\t$bean2 = array_shift($beans);\r\n\t\t$tmp = $bean1->$property;\r\n\t\t$bean1->$property = $bean2->$property;\r\n\t\t$bean2->$property = $tmp;\r\n\t\tRedBean_Facade::store($bean1);\r\n\t\tRedBean_Facade::store($bean2);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a series of rows to beans.\r\n\t *\r\n\t * @param string $type type\r\n\t * @param array  $rows must contain an array of arrays.\r\n\t *\r\n\t * @return array $beans\r\n\t */\r\n\tpublic static function convertToBeans($type,$rows) {\r\n\t\treturn self::$redbean->convertToBeans($type,$rows);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Tests whether a bean has been associated with one ore more\r\n\t * of the listed tags. If the third parameter is TRUE this method\r\n\t * will return TRUE only if all tags that have been specified are indeed\r\n\t * associated with the given bean, otherwise FALSE.\r\n\t * If the third parameter is FALSE this\r\n\t * method will return TRUE if one of the tags matches, FALSE if none\r\n\t * match.\r\n\t *\r\n\t * @param  RedBean_OODBBean $bean bean to check for tags\r\n\t * @param  array            $tags list of tags\r\n\t * @param  boolean          $all  whether they must all match or just some\r\n\t *\r\n\t * @return boolean $didMatch whether the bean has been assoc. with the tags\r\n\t */\r\n\tpublic static function hasTag($bean, $tags, $all=false) {\r\n\t\treturn self::$tagManager->hasTag($bean,$tags,$all);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Removes all sepcified tags from the bean. The tags specified in\r\n\t * the second parameter will no longer be associated with the bean.\r\n\t *\r\n\t * @param  RedBean_OODBBean $bean    tagged bean\r\n\t * @param  array            $tagList list of tags (names)\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function untag($bean,$tagList) {\r\n\t\treturn self::$tagManager->untag($bean,$tagList);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Tags a bean or returns tags associated with a bean.\r\n\t * If $tagList is null or omitted this method will return a\r\n\t * comma separated list of tags associated with the bean provided.\r\n\t * If $tagList is a comma separated list (string) of tags all tags will\r\n\t * be associated with the bean.\r\n\t * You may also pass an array instead of a string.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean    bean\r\n\t * @param mixed\t\t\t\t$tagList tags\r\n\t *\r\n\t * @return string $commaSepListTags\r\n\t */\r\n\tpublic static function tag( RedBean_OODBBean $bean, $tagList = null ) {\r\n\t\treturn self::$tagManager->tag($bean,$tagList);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Adds tags to a bean.\r\n\t * If $tagList is a comma separated list of tags all tags will\r\n\t * be associated with the bean.\r\n\t * You may also pass an array instead of a string.\r\n\t *\r\n\t * @param RedBean_OODBBean  $bean    bean\r\n\t * @param array\t\t\t\t$tagList list of tags to add to bean\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function addTags( RedBean_OODBBean $bean, $tagList ) {\r\n\t\treturn self::$tagManager->addTags($bean,$tagList);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Returns all beans that have been tagged with one of the tags given.\r\n\t *\r\n\t * @param  $beanType type of bean you are looking for\r\n\t * @param  $tagList  list of tags to match\r\n\t *\r\n\t * @return array\r\n\t */\r\n\tpublic static function tagged( $beanType, $tagList ) {\r\n\t\treturn self::$tagManager->tagged($beanType,$tagList);\r\n\t}\r\n\r\n\t/**\r\n\t * Part of RedBeanPHP Tagging API.\r\n\t * Returns all beans that have been tagged with ALL of the tags given.\r\n\t *\r\n\t * @param  $beanType type of bean you are looking for\r\n\t * @param  $tagList  list of tags to match\r\n\t *\r\n\t * @return array\r\n\t */\r\n\tpublic static function taggedAll( $beanType, $tagList ) {\r\n\t\treturn self::$tagManager->taggedAll($beanType,$tagList);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Wipes all beans of type $beanType.\r\n\t *\r\n\t * @param string $beanType type of bean you want to destroy entirely.\r\n\t */\r\n\tpublic static function wipe( $beanType ) {\r\n\t\treturn RedBean_Facade::$redbean->wipe($beanType);\r\n\t}\r\n\r\n\t/**\r\n\t * Counts beans\r\n\t *\r\n\t * @param string $beanType type of bean\r\n\t * @param string $addSQL   additional SQL snippet (for filtering, limiting)\r\n\t * @param array  $params   parameters to bind to SQL\r\n\t *\r\n\t * @return integer $numOfBeans\r\n\t */\r\n\r\n\tpublic static function count( $beanType, $addSQL = '', $params = array() ) {\r\n\t\treturn RedBean_Facade::$redbean->count($beanType,$addSQL,$params);\r\n\t}\r\n\r\n\t/**\r\n\t * Configures the facade, want to have a new Writer? A new Object Database or a new\r\n\t * Adapter and you want it on-the-fly? Use this method to hot-swap your facade with a new\r\n\t * toolbox.\r\n\t *\r\n\t * @param RedBean_ToolBox $tb toolbox\r\n\t *\r\n\t * @return RedBean_ToolBox $tb old, rusty, previously used toolbox\r\n\t */\r\n\tpublic static function configureFacadeWithToolbox( RedBean_ToolBox $tb ) {\r\n\t\t$oldTools = self::$toolbox;\r\n\t\tself::$toolbox = $tb;\r\n\t\tself::$writer = self::$toolbox->getWriter();\r\n\t\tself::$adapter = self::$toolbox->getDatabaseAdapter();\r\n\t\tself::$redbean = self::$toolbox->getRedBean();\r\n\t\tself::$associationManager = new RedBean_AssociationManager( self::$toolbox );\r\n\t\tself::$redbean->setAssociationManager(self::$associationManager);\r\n\t\tself::$extAssocManager = new RedBean_AssociationManager_ExtAssociationManager( self::$toolbox );\r\n\t\t$helper = new RedBean_ModelHelper();\r\n\t\tself::$redbean->addEventListener('update', $helper );\r\n\t\tself::$redbean->addEventListener('open', $helper );\r\n\t\tself::$redbean->addEventListener('delete', $helper );\r\n\t\tself::$associationManager->addEventListener('delete', $helper );\r\n\t\tself::$duplicationManager = new RedBean_DuplicationManager(self::$toolbox);\r\n\t\tself::$redbean->addEventListener('after_delete', $helper );\r\n\t\tself::$redbean->addEventListener('after_update', $helper );\r\n\t\tself::$redbean->addEventListener('dispense', $helper );\r\n\t\tself::$tagManager = new RedBean_TagManager( self::$toolbox );\r\n\t\tself::$f = new RedBean_SQLHelper(self::$adapter);\r\n\t\treturn $oldTools;\r\n\t}\r\n\r\n\t/**\r\n\t * Facade Convience method for adapter transaction system.\r\n\t * Begins a transaction.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function begin() {\r\n\t\tself::$adapter->startTransaction();\r\n\t}\r\n\r\n\t/**\r\n\t * Facade Convience method for adapter transaction system.\r\n\t * Commits a transaction.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function commit() {\r\n\t\tself::$adapter->commit();\r\n\t}\r\n\r\n\t/**\r\n\t * Facade Convience method for adapter transaction system.\r\n\t * Rolls back a transaction.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic static function rollback() {\r\n\t\tself::$adapter->rollback();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of columns. Format of this array:\r\n\t * array( fieldname => type )\r\n\t * Note that this method only works in fluid mode because it might be\r\n\t * quite heavy on production servers!\r\n\t *\r\n\t * @param  string $table   name of the table (not type) you want to get columns of\r\n\t *\r\n\t * @return array  $columns list of columns and their types\r\n\t */\r\n\tpublic static function getColumns($table) {\r\n\t\treturn self::$writer->getColumns($table);\r\n\t}\r\n\r\n\t/**\r\n\t * Generates question mark slots for an array of values.\r\n\t *\r\n\t * @param array $array\r\n\t * @return string $slots\r\n\t */\r\n\tpublic static function genSlots($array) {\r\n\t\tif (count($array)>0) {\r\n\t\t\t$filler = array_fill(0,count($array),'?');\r\n\t\t\treturn implode(',',$filler);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Nukes the entire database.\r\n\t */\r\n\tpublic static function nuke() {\r\n\t\tif (!self::$redbean->isFrozen()) {\r\n\t\t\tself::$writer->wipeAll();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a list of dependencies.\r\n\t * A dependency list contains an entry for each dependent bean.\r\n\t * A dependent bean will be removed if the relation with one of the\r\n\t * dependencies gets broken.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * array(\r\n\t *\t'page' => array('book','magazine')\r\n\t * )\r\n\t *\r\n\t * A page will be removed if:\r\n\t *\r\n\t * unset($book->ownPage[$pageID]);\r\n\t *\r\n\t * or:\r\n\t *\r\n\t * unset($magazine->ownPage[$pageID]);\r\n\t *\r\n\t * but not if:\r\n\t *\r\n\t * unset($paper->ownPage[$pageID]);\r\n\t *\r\n\t *\r\n\t * @param array $dep list of dependencies\r\n\t */\r\n\tpublic static function dependencies($dep) {\r\n\t\tself::$redbean->setDepList($dep);\r\n    }\r\n\r\n\t/**\r\n\t * Short hand function to store a set of beans at once, IDs will be\r\n\t * returned as an array. For information please consult the R::store()\r\n\t * function.\r\n\t * A loop saver.\r\n\t *\r\n\t * @param array $beans list of beans to be stored\r\n\t *\r\n\t * @return array $ids list of resulting IDs\r\n\t */\r\n\tpublic static function storeAll($beans) {\r\n\t\t$ids = array();\r\n\t\tforeach($beans as $bean) $ids[] = self::store($bean);\r\n\t\treturn $ids;\r\n\t}\r\n\r\n\t/**\r\n\t * Short hand function to trash a set of beans at once.\r\n\t * For information please consult the R::trash() function.\r\n\t * A loop saver.\r\n\t *\r\n\t * @param array $beans list of beans to be trashed\r\n\t */\r\n\tpublic static function trashAll($beans) {\r\n\t\tforeach($beans as $bean) self::trash($bean);\r\n\t}\r\n\r\n\t/**\r\n\t * A label is a bean with only an id, type and name property.\r\n\t * This function will dispense beans for all entries in the array. The\r\n\t * values of the array will be assigned to the name property of each\r\n\t * individual bean.\r\n\t *\r\n\t * @param string $type   type of beans you would like to have\r\n\t * @param array  $labels list of labels, names for each bean\r\n\t *\r\n\t * @return array $bean a list of beans with type and name property\r\n\t */\r\n\tpublic static function dispenseLabels($type,$labels) {\r\n\t\t$labelBeans = array();\r\n\t\tforeach($labels as $label) {\r\n\t\t\t$labelBean = self::dispense($type);\r\n\t\t\t$labelBean->name = $label;\r\n\t\t\t$labelBeans[] = $labelBean;\r\n\t\t}\r\n\t\treturn $labelBeans;\r\n\t}\r\n\r\n\t/**\r\n\t * Gathers labels from beans. This function loops through the beans,\r\n\t * collects the values of the name properties of each individual bean\r\n\t * and stores the names in a new array. The array then gets sorted using the\r\n\t * default sort function of PHP (sort).\r\n\t *\r\n\t * @param array $beans list of beans to loop\r\n\t *\r\n\t * @return array $array list of names of beans\r\n\t */\r\n\tpublic static function gatherLabels($beans) {\r\n\t\t$labels = array();\r\n\t\tforeach($beans as $bean) $labels[] = $bean->name;\r\n\t\tsort($labels);\r\n\t\treturn $labels;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Closes the database connection.\r\n\t */\r\n\tpublic static function close() {\r\n\t\tif (isset(self::$adapter)){\r\n\t\t\tself::$adapter->close();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n\t/**\r\n\t * Simple convenience function, returns ISO date formatted representation\r\n\t * of $time.\r\n\t *\r\n\t * @param mixed $time UNIX timestamp\r\n\t *\r\n\t * @return type\r\n\t */\r\n\tpublic static function isoDate( $time = null ) {\r\n\t\tif (!$time) $time = time();\r\n\t\treturn @date('Y-m-d',$time);\r\n\t}\r\n\r\n\t/**\r\n\t * Simple convenience function, returns ISO date time\r\n\t * formatted representation\r\n\t * of $time.\r\n\t *\r\n\t * @param mixed $time UNIX timestamp\r\n\t *\r\n\t * @return type\r\n\t */\r\n\tpublic static function isoDateTime( $time = null) {\r\n\t\tif (!$time) $time = time();\r\n\t\treturn @date('Y-m-d H:i:s',$time);\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t * \r\n\t * @param RedBean_Adapter $adapter \r\n\t */\r\n\tpublic static function setDatabaseAdapter(RedBean_Adapter $adapter) {\r\n\t\tself::$adapter = $adapter;\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t *\r\n\t * @param RedBean_QueryWriter $writer \r\n\t */\r\n\tpublic static function setWriter(RedBean_QueryWriter $writer) {\r\n\t\tself::$writer = $writer;\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t *\r\n\t * @param RedBean_OODB $redbean \r\n\t */\r\n\tpublic static function setRedBean(RedBean_OODB $redbean) {\r\n\t\tself::$redbean = $redbean;\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t *\r\n\t * @return RedBean_DatabaseAdapter $adapter\r\n\t */\r\n\tpublic static function getDatabaseAdapter() {\r\n\t\treturn self::$adapter;\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t *\r\n\t * @return RedBean_QueryWriter $writer\r\n\t */\r\n\tpublic static function getWriter() {\r\n\t\treturn self::$writer;\r\n\t}\r\n\r\n\t/**\r\n\t * Optional accessor for neat code.\r\n\t * Sets the database adapter you want to use.\r\n\t *\r\n\t * @return RedBean_RedBean $redbean\r\n\t */\r\n\tpublic static function getRedBean() {\r\n\t\treturn self::$redbean;\r\n\t}\r\n\r\n\t/**\r\n\t * Preloads certain properties for beans.\r\n\t * Understands aliases.\r\n\t * \r\n\t * Usage: R::preload($books,array('coauthor'=>'author'));\r\n\t * \r\n\t * @param array $beans beans\r\n\t * @param array $types types to load\r\n\t */\r\n\tpublic static function preload($beans,$types) {\r\n\t\tforeach($types as $key => $type) {\r\n\t\t\t$field = (is_numeric($key)) ? $type : $key;\r\n\t\t\t$ids = array();\r\n\t\t\tforeach($beans as $bean) {\r\n\t\t\t\t$id = $bean->{$field.'_id'};\r\n                if(!is_numeric($id)) continue;\r\n\t\t\t\t$ids[] = $id;\r\n\t\t\t\t$map[$id] = $bean;\r\n\t\t\t}\t\r\n\t\t\t$parents = R::batch($type,$ids);\r\n\t\t\tforeach($parents as $parent) {\r\n\t\t\t\t$map[$parent->id]->setProperty($field,$parent);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n//Compatibility with PHP 5.2 and earlier\r\nfunction __lcfirst( $str ){\treturn (string)(strtolower(substr($str,0,1)).substr($str,1)); }\r\n\r\n\r\n/**\r\n * RedBean Plugin\r\n * \r\n * @file\t\t\tRedBean/Plugin.php\r\n * @description\t\tMarker interface for plugins.\r\n * \t\t\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\ninterface RedBean_Plugin { }; \r\n\r\n/**\r\n * Sync\r\n *\r\n * @file                       RedBean/Plugin/Sync.php\r\n * @description                Plugin for Synchronizing databases.\r\n * \r\n * @plugin\t\t\t\t\t   public static function syncSchema($from,$to) { return RedBean_Plugin_Sync::syncSchema($from,$to); }\r\n *\r\n * @author                     Gabor de Mooij\r\n * @license                    BSD\r\n *\r\n *\r\n * (c) G.J.G.T. (Gabor) de Mooij\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Plugin_Sync implements RedBean_Plugin {\r\n\r\n\t/**\r\n\t * Captures the SQL required to adjust source database to match\r\n\t * schema of target database and feeds this sql code to the\r\n\t * adapter of the target database.\r\n\t *\r\n\t * @param RedBean_Toolbox $source toolbox of source database\r\n\t * @param RedBean_Toolbox $target toolbox of target database\r\n\t */\r\n\tpublic function doSync(RedBean_Toolbox $source, RedBean_Toolbox $target) {\r\n\r\n\t\t$sourceWriter = $source->getWriter();\r\n\t\t$targetWriter = $target->getWriter();\r\n\r\n\t\t$longText = str_repeat('lorem ipsum', 9000);\r\n\t\t$testmap = array(\r\n\t\t\tfalse, 1, 2.5, -10, 1000, 'abc', $longText, '2010-10-10', '2010-10-10 10:00:00', '10:00:00', 'POINT(1 2)'\r\n\t\t);\r\n\t\t$translations = array();\r\n\t\t$defaultCode = $targetWriter->scanType('string');\r\n\t\tforeach ($testmap as $v) {\r\n\t\t\t$code = $sourceWriter->scanType($v, true);\r\n\t\t\t$translation = $targetWriter->scanType($v, true);\r\n\t\t\tif (!isset($translations[$code]))\r\n\t\t\t\t$translations[$code] = $translation;\r\n\t\t\tif ($translation > $translations[$code] && $translation < 50)\r\n\t\t\t\t$translations[$code] = $translation;\r\n\t\t}\r\n\r\n\r\n\t\t//Fix narrow translations SQLiteT stores date as double. (double != really double)\r\n\t\tif (get_class($sourceWriter)==='RedBean_QueryWriter_SQLiteT') {\r\n\t\t\t$translations[1] = $defaultCode;  //use magic number in case writer not loaded.\r\n\t\t}\r\n\r\n\t\t$sourceTables = $sourceWriter->getTables();\r\n\t\t$targetTables = $targetWriter->getTables();\r\n\t\t$missingTables = array_diff($sourceTables, $targetTables);\r\n\t\tforeach ($missingTables as $missingTable) {\r\n\t\t\t$targetWriter->createTable($missingTable);\r\n\t\t}\r\n\t\t//First run, create tables and columns\r\n\t\tforeach ($sourceTables as $sourceTable) {\r\n\t\t\t$sourceColumns = $sourceWriter->getColumns($sourceTable);\r\n\t\t\tif (in_array($sourceTable, $missingTables)) {\r\n\t\t\t\t$targetColumns = array();\r\n\t\t\t} else {\r\n\t\t\t\t$targetColumns = $targetWriter->getColumns($sourceTable);\r\n\t\t\t}\r\n\t\t\tunset($sourceColumns['id']);\r\n\t\t\tforeach ($sourceColumns as $sourceColumn => $sourceType) {\r\n\t\t\t\tif (substr($sourceColumn, -3) === '_id') {\r\n\t\t\t\t\t$targetCode = $targetWriter->getTypeForID();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$sourceCode = $sourceWriter->code($sourceType, true);\r\n\t\t\t\t\t$targetCode = (isset($translations[$sourceCode])) ? $translations[$sourceCode] : $defaultCode;\r\n\t\t\t\t}\r\n\t\t\t\tif (!isset($targetColumns[$sourceColumn])) {\r\n\t\t\t\t\t$targetWriter->addColumn($sourceTable, $sourceColumn, $targetCode);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tforeach ($sourceTables as $sourceTable) {\r\n\t\t\t$sourceColumns = $sourceWriter->getColumns($sourceTable);\r\n\t\t\tforeach ($sourceColumns as $sourceColumn => $sourceType) {\r\n\t\t\t\tif (substr($sourceColumn, -3) === '_id') {\r\n\t\t\t\t\t$fkTargetType = substr($sourceColumn, 0, strlen($sourceColumn) - 3);\r\n\t\t\t\t\t$fkType = $sourceTable;\r\n\t\t\t\t\t$fkField = $sourceColumn;\r\n\t\t\t\t\t$fkTargetField = 'id';\r\n\t\t\t\t\t$targetWriter->addFK($fkType, $fkTargetType, $fkField, $fkTargetField);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//Is it a link table? -- Add Unique constraint and FK constraint\r\n\t\t\tif (strpos($sourceTable, '_') !== false) {\r\n\t\t\t\t$targetWriter->addUniqueIndex($sourceTable, array_keys($sourceColumns));\r\n\t\t\t\t$types = explode('_', $sourceTable);\r\n\t\t\t\t$targetWriter->addConstraint(R::dispense($types[0]), R::dispense($types[1]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Performs a database schema sync. For use with facade.\r\n\t * Instead of toolboxes this method accepts simply string keys and is static.\r\n\t * \r\n\t * @param string $database1 the source database\r\n\t * @param string $database2 the target database\r\n\t */\r\n\tpublic static function syncSchema($database1,$database2) {\r\n\t\tif (!isset(RedBean_Facade::$toolboxes[$database1])) throw new RedBean_Exception_Security('No database for this key: '.$database1);\r\n\t\tif (!isset(RedBean_Facade::$toolboxes[$database2])) throw new RedBean_Exception_Security('No database for this key: '.$database2);\r\n\t\t$db1 = RedBean_Facade::$toolboxes[$database1];\r\n\t\t$db2 = RedBean_Facade::$toolboxes[$database2];\r\n\t\t$sync = new self;\r\n\t\t$sync->doSync($db1, $db2);\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * BeanCan\r\n *  \r\n * @file\t\t\tRedBean/BeanCan.php\r\n * @description\t\tA Server Interface for RedBean and Fuse.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n * \r\n * The BeanCan Server is a lightweight, minimalistic server interface for\r\n * RedBean that can perfectly act as an ORM middleware solution or a backend\r\n * for an AJAX application.\r\n * \r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Plugin_BeanCan implements RedBean_Plugin {\r\n\r\n\t/**\r\n\t * Holds a FUSE instance.\r\n\t * @var RedBean_ModelHelper\r\n\t */\r\n\tprivate $modelHelper;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tpublic function __construct() {\r\n\t\t$this->modelHelper = new RedBean_ModelHelper;\r\n\t}\r\n\r\n\t/**\r\n\t * Writes a response object for the client (JSON encoded). Internal method.\r\n\t *\r\n\t * @param mixed   $result       result\r\n\t * @param integer $id           request ID\r\n\t * @param integer $errorCode    error code from server\r\n\t * @param string  $errorMessage error message from server\r\n\t *\r\n\t * @return string $json JSON encoded response.\r\n\t */\r\n\tprivate function resp($result=null, $id=null, $errorCode='-32603',$errorMessage='Internal Error') {\r\n\t\t$response = array('jsonrpc'=>'2.0');\r\n\t\t if (!is_null($id)) { $response['id'] = $id; }\r\n\t\tif ($result) {\r\n\t\t\t$response['result']=$result;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$response['error'] = array('code'=>$errorCode,'message'=>$errorMessage);\r\n\t\t}\r\n\t\treturn (json_encode($response));\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a JSON object request.\r\n\t *\r\n\t * @param array $jsonObject JSON request object\r\n\t *\r\n\t * @return mixed $result result\r\n\t */\r\n\tpublic function handleJSONRequest( $jsonString ) {\r\n\t\t//Decode JSON string\r\n\t\t$jsonArray = json_decode($jsonString,true);\r\n\t\tif (!$jsonArray) return $this->resp(null,null,-32700,'Cannot Parse JSON');\r\n\t\tif (!isset($jsonArray['jsonrpc'])) return $this->resp(null,null,-32600,'No RPC version');\r\n\t\tif (($jsonArray['jsonrpc']!='2.0')) return $this->resp(null,null,-32600,'Incompatible RPC Version');\r\n\t\t//DO we have an ID to identify this request?\r\n\t\tif (!isset($jsonArray['id'])) return $this->resp(null,null,-32600,'No ID');\r\n\t\t//Fetch the request Identification String.\r\n\t\t$id = $jsonArray['id'];\r\n\t\t//Do we have a method?\r\n\t\tif (!isset($jsonArray['method'])) return $this->resp(null,$id,-32600,'No method');\r\n\t\t//Do we have params?\r\n\t\tif (!isset($jsonArray['params'])) {\r\n\t\t\t$data = array();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$data = $jsonArray['params'];\r\n\t\t}\r\n\t\t//Check method signature\r\n\t\t$method = explode(':',trim($jsonArray['method']));\r\n\t\tif (count($method)!=2) {\r\n\t\t\treturn $this->resp(null, $id, -32600,'Invalid method signature. Use: BEAN:ACTION');\r\n\t\t}\r\n\t\t//Collect Bean and Action\r\n\t\t$beanType = $method[0];\r\n\t\t$action = $method[1];\r\n\t\t//May not contain anything other than ALPHA NUMERIC chars and _\r\n\t\tif (preg_match('/\\W/',$beanType)) return $this->resp(null, $id, -32600,'Invalid Bean Type String');\r\n\t\tif (preg_match('/\\W/',$action)) return $this->resp(null, $id, -32600,'Invalid Action String');\r\n\r\n\t\ttry {\r\n\t\t\tswitch($action) {\r\n\t\t\t\tcase 'store':\r\n\t\t\t\t\tif (!isset($data[0])) return $this->resp(null, $id, -32602,'First param needs to be Bean Object');\r\n\t\t\t\t\t$data = $data[0];\r\n\t\t\t\t\tif (!isset($data['id'])) $bean = RedBean_Facade::dispense($beanType); else\r\n\t\t\t\t\t\t$bean = RedBean_Facade::load($beanType,$data['id']);\r\n\t\t\t\t\t$bean->import( $data );\r\n\t\t\t\t\t$rid = RedBean_Facade::store($bean);\r\n\t\t\t\t\treturn $this->resp($rid, $id);\r\n\t\t\t\tcase 'load':\r\n\t\t\t\t\tif (!isset($data[0])) return $this->resp(null, $id, -32602,'First param needs to be Bean ID');\r\n\t\t\t\t\t$bean = RedBean_Facade::load($beanType,$data[0]);\r\n\t\t\t\t\treturn $this->resp($bean->export(),$id);\r\n\t\t\t\tcase 'trash':\r\n\t\t\t\t\tif (!isset($data[0])) return $this->resp(null, $id, -32602,'First param needs to be Bean ID');\r\n\t\t\t\t\t$bean = RedBean_Facade::load($beanType,$data[0]);\r\n\t\t\t\t\tRedBean_Facade::trash($bean);\r\n\t\t\t\t\treturn $this->resp('OK',$id);\r\n\t\t\t\tcase 'export':\r\n\t\t\t\t\tif (!isset($data[0])) return $this->resp(null, $id, -32602,'First param needs to be Bean ID');\r\n\t\t\t\t\t$bean = RedBean_Facade::load($beanType,$data[0]);\r\n\t\t\t\t\t$array = RedBean_Facade::exportAll(array($bean),true);\r\n\t\t\t\t\treturn $this->resp($array,$id);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t$modelName = $this->modelHelper->getModelName( $beanType );\r\n\t\t\t\t\tif (!class_exists($modelName)) return $this->resp(null, $id, -32601,'No such bean in the can!');\r\n\t\t\t\t\t$beanModel = new $modelName;\r\n\t\t\t\t\tif (!method_exists($beanModel,$action)) return $this->resp(null, $id, -32601,\"Method not found in Bean: $beanType \");\r\n\t\t\t\t\treturn $this->resp( call_user_func_array(array($beanModel,$action), $data), $id);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception $exception) {\r\n\t\t\treturn $this->resp(null, $id, -32099,$exception->getCode().'-'.$exception->getMessage());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Support for RESTFul GET-requests.\r\n\t * Only supports very BASIC REST requests, for more functionality please use\r\n\t * the JSON-RPC 2 interface.\r\n\t * \r\n\t * @param string $pathToResource RESTFul path to resource\r\n\t * \r\n\t * @return string $json a JSON encoded response ready for sending to client\r\n\t */\r\n\tpublic function handleRESTGetRequest( $pathToResource ) {\r\n\t\tif (!is_string($pathToResource)) return $this->resp(null,0,-32099,'IR');\r\n\t\t$resourceInfo = explode('/',$pathToResource);\r\n\t\t$type = $resourceInfo[0];\r\n\t\ttry {\r\n\t\t\tif (count($resourceInfo) < 2) {\r\n\t\t\t\treturn $this->resp(RedBean_Facade::findAndExport($type));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$id = (int) $resourceInfo[1];\r\n\t\t\t\treturn $this->resp(RedBean_Facade::load($type,$id)->export(),$id);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception $e) {\r\n\t\t\treturn $this->resp(null,0,-32099);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Query Logger\r\n *\r\n * @file \t\t\tRedBean/Plugin/QueryLogger.php\r\n * @description\t\tQuery logger, can be attached to an observer that\r\n * \t\t\t\t\tsignals the sql_exec event.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\n\r\nclass RedBean_Plugin_QueryLogger implements RedBean_Observer, RedBean_Plugin {\r\n\r\n\t/**\r\n\t * @var array\r\n\t * contains log messages\r\n\t */\r\n\tprotected $logs = array();\r\n\r\n\t/**\r\n\t * Creates a new instance of the Query Logger and attaches\r\n\t * this logger to the adapter.\r\n\t *\r\n\t * @static\r\n\t * @param RedBean_Observable $adapter the adapter you want to attach to\r\n\t *\r\n\t * @return RedBean_Plugin_QueryLogger $querylogger instance of the Query Logger\r\n\t */\r\n\tpublic static function getInstanceAndAttach( RedBean_Observable $adapter ) {\r\n\t\t$queryLog = new RedBean_Plugin_QueryLogger;\r\n\t\t$adapter->addEventListener( 'sql_exec', $queryLog );\r\n\t\treturn $queryLog;\r\n\t}\r\n\r\n\t/**\r\n\t * Singleton pattern\r\n\t * Constructor - private\r\n\t */\r\n\tprivate function __construct(){}\r\n\r\n\t/**\r\n\t * Implementation of the onEvent() method for Observer interface.\r\n\t * If a query gets executed this method gets invoked because the\r\n\t * adapter will send a signal to the attached logger.\r\n\t *\r\n\t * @param  string $eventName          ID of the event (name)\r\n\t * @param  RedBean_DBAdapter $adapter adapter that sends the signal\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function onEvent( $eventName, $adapter ) {\r\n\t\tif ($eventName=='sql_exec') {\r\n\t\t\t$this->logs[] = $adapter->getSQL();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Searches the logs for the given word and returns the entries found in\r\n\t * the log container.\r\n\t *\r\n\t * @param  string $word word to look for\r\n\t *\r\n\t * @return array $entries entries that contain the keyword\r\n\t */\r\n\tpublic function grep( $word ) {\r\n\t\t$found = array();\r\n\t\tforeach($this->logs as $log) {\r\n\t\t\tif (strpos($log,$word)!==false) {\r\n\t\t\t\t$found[] = $log;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $found;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all the logs.\r\n\t *\r\n\t * @return array $logs logs\r\n\t */\r\n\tpublic function getLogs() {\r\n\t\treturn $this->logs;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the logs.\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function clear() {\r\n\t\t$this->logs = array();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * TimeLine \r\n *\r\n * @file \t\t\tRedBean/Plugin/TimeLine.php\r\n * @description\t\tMonitors schema changes to ease deployment.\r\n * \r\n * @plugin\t\t\tpublic static function log($filename) { $tl = new RedBean_Plugin_TimeLine($filename); self::$adapter->addEventListener('sql_exec',$tl);}\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\n\r\nclass RedBean_Plugin_TimeLine extends RedBean_Plugin_QueryLogger implements RedBean_Plugin {\r\n\r\n\t/**\r\n\t * Path to file to write SQL and comments to.\r\n\t * \r\n\t * @var string \r\n\t */\r\n\tprotected $file;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * Requires a path to an existing and writable file.\r\n\t * \r\n\t * @param string $outputPath path to file to write schema changes to. \r\n\t */\r\n\tpublic function __construct($outputPath) {\r\n\t\tif (!file_exists($outputPath) || !is_writable($outputPath)) \r\n\t\t\tthrow new RedBean_Exception_Security('Cannot write to file: '.$outputPath);\r\n\t\t$this->file = $outputPath;\r\n\t}\r\n\r\n\t/**\r\n\t * Implementation of the onEvent() method for Observer interface.\r\n\t * If a query gets executed this method gets invoked because the\r\n\t * adapter will send a signal to the attached logger.\r\n\t *\r\n\t * @param  string $eventName          ID of the event (name)\r\n\t * @param  RedBean_DBAdapter $adapter adapter that sends the signal\r\n\t *\r\n\t * @return void\r\n\t */\r\n\tpublic function onEvent( $eventName, $adapter ) {\r\n\t\tif ($eventName=='sql_exec') {\r\n\t\t\t$sql = $adapter->getSQL();\r\n\t\t\t$this->logs[] = $sql;\r\n\t\t\tif (strpos($sql,'ALTER')===0) {\r\n\t\t\t\t$write = \"-- \".date('Y-m-d H:i').\" | Altering table. \\n\";\r\n\t\t\t\t$write .= $sql;\r\n\t\t\t\t$write .= \"\\n\\n\";\r\n\t\t\t}\r\n\t\t\tif (strpos($sql,'CREATE')===0) {\r\n\t\t\t\t$write = \"-- \".date('Y-m-d H:i').\" | Creating new table. \\n\";\r\n\t\t\t\t$write .= $sql;\r\n\t\t\t\t$write .= \"\\n\\n\";\r\n\t\t\t}\r\n\t\t\tif (isset($write)) {\r\n\t\t\t\tfile_put_contents($this->file,$write,FILE_APPEND);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * RedBean Cooker\r\n * @file\t\t\tRedBean/Cooker.php\r\n * \r\n * @plugin\t\t\tpublic static function graph($array,$filterEmpty=false) { $c = new RedBean_Plugin_Cooker(); $c->setToolbox(self::$toolbox);return $c->graph($array,$filterEmpty);}\r\n * \r\n * @description\t\tTurns arrays into bean collections for easy persistence.\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * The Cooker is a little candy to make it easier to read-in an HTML form.\r\n * This class turns a form into a collection of beans plus an array\r\n * describing the desired associations.\r\n *\r\n * (c) copyright G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community.\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\nclass RedBean_Plugin_Cooker implements RedBean_Plugin {\r\n\r\n\t/**\r\n\t * This flag indicates whether empty strings in beans will be\r\n\t * interpreted as NULL or not. TRUE means Yes, will be converted to NULL,\r\n\t * FALSE means empty strings will be stored as such (conversion to 0 for integer fields).\r\n\t * @var boolean\r\n\t */\r\n\tprivate static $useNULLForEmptyString = false;\r\n\r\n\t/**\r\n\t * Sets the toolbox to be used by graph()\r\n\t *\r\n\t * @param RedBean_Toolbox $toolbox toolbox\r\n\t * @return void\r\n\t */\r\n\tpublic function setToolbox(RedBean_Toolbox $toolbox) {\r\n\t\t$this->toolbox = $toolbox;\r\n\t\t$this->redbean = $this->toolbox->getRedbean();\r\n\t}\r\n\r\n\t/**\r\n\t * Turns an array (post/request array) into a collection of beans.\r\n\t * Handy for turning forms into bean structures that can be stored with a\r\n\t * single call.\r\n\t * \r\n\t * Typical usage:\r\n\t * \r\n\t * $struct = R::graph($_POST);\r\n\t * R::store($struct);\r\n\t * \r\n\t * Example of a valid array:\r\n\t * \r\n\t *\t$form = array(\r\n\t *\t\t'type'=>'order',\r\n\t *\t\t'ownProduct'=>array(\r\n\t *\t\t\tarray('id'=>171,'type'=>'product'),\r\n\t *\t\t),\r\n\t *\t\t'ownCustomer'=>array(\r\n\t *\t\t\tarray('type'=>'customer','name'=>'Bill')\r\n\t *\t\t),\r\n\t * \t\t'sharedCoupon'=>array(\r\n\t *\t\t\tarray('type'=>'coupon','name'=>'123'),\r\n\t *\t\t\tarray('type'=>'coupon','id'=>3)\r\n\t *\t\t)\r\n\t *\t);\r\n\t * \r\n\t * Each entry in the array will become a property of the bean.\r\n\t * The array needs to have a type-field indicating the type of bean it is\r\n\t * going to be. The array can have nested arrays. A nested array has to be\r\n\t * named conform the bean-relation conventions, i.e. ownPage/sharedPage\r\n\t * each entry in the nested array represents another bean.\r\n\t *  \r\n\t * @param\tarray   $array       array to be turned into a bean collection\r\n\t * @param   boolean $filterEmpty whether you want to exclude empty beans\r\n\t *\r\n\t * @return\tarray $beans beans\r\n\t */\r\n\tpublic function graph( $array, $filterEmpty = false ) {\r\n      \t$beans = array();\r\n\t\tif (is_array($array) && isset($array['type'])) {\r\n\t\t\t$type = $array['type'];\r\n\t\t\tunset($array['type']);\r\n\t\t\t//Do we need to load the bean?\r\n\t\t\tif (isset($array['id'])) {\r\n\t\t\t\t$id = (int) $array['id'];\r\n\t\t\t\t$bean = $this->redbean->load($type,$id);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$bean = $this->redbean->dispense($type);\r\n\t\t\t}\r\n\t\t\tforeach($array as $property=>$value) {\r\n\t\t\t\tif (is_array($value)) {\r\n\t\t\t\t\t$bean->$property = $this->graph($value,$filterEmpty);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif($value == '' && self::$useNULLForEmptyString){\r\n\t\t\t\t\t\t$bean->$property = null;\r\n                    }\r\n\t\t\t\t\telse\r\n\t\t\t\t\t$bean->$property = $value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $bean;\r\n\t\t}\r\n\t\telseif (is_array($array)) {\r\n\t\t\tforeach($array as $key=>$value) {\r\n\t\t\t\t$listBean = $this->graph($value,$filterEmpty);\r\n\t\t\t\tif (!($listBean instanceof RedBean_OODBBean)) {\r\n\t\t\t\t\tthrow new RedBean_Exception_Security('Expected bean but got :'.gettype($listBean)); \r\n\t\t\t\t}\r\n\t\t\t\tif ($listBean->isEmpty()) {  \r\n\t\t\t\t\tif (!$filterEmpty) { \r\n\t\t\t\t\t\t$beans[$key] = $listBean;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { \r\n\t\t\t\t\t$beans[$key] = $listBean;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $beans;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new RedBean_Exception_Security('Expected array but got :'.gettype($array)); \r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Toggles the use-NULL flag.\r\n\t *  \r\n\t * @param boolean $yesNo \r\n\t */\r\n\tpublic function setUseNullFlag($yesNo) {\r\n\t\tself::$useNULLForEmptyString = (boolean) $yesNo;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * RedBeanPHP Cache Plugin\r\n * \r\n * @file\t\t\tRedBean/Plugin/Cache.php\r\n * @description \tCache plugin, caches beans.\r\n * \r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * Provides a means to cache beans after loading or batch loading.\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n */\r\n\r\nclass RedBean_Plugin_Cache extends RedBean_OODB implements RedBean_Plugin {\r\n\r\n\t/**\r\n\t * Bean cache, contains the cached beans identified by\r\n\t * label keys containing the type id and the fetch method;\r\n\t * i.e. single load or batch load.\r\n\t *  \r\n\t * @var array \r\n\t */\r\n\tprivate $cache = array();\r\n\r\n\r\n\r\n\t/**\r\n\t * Number of hits (beans/calls being served from cache). \r\n\t * Can be used to monitor cache performance.\r\n\t *  \r\n\t * @var integer \r\n\t */\r\n\tprivate $hits = 0;\r\n\r\n\t/**\r\n\t * Number of misses (beans not being served from cache), can be\r\n\t * used to monitor cache performance.\r\n\t * \r\n\t * @var integer \r\n\t */\r\n\tprivate $misses = 0;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * Cache decorates RedBeanPHP OODB class, so needs a writer.\r\n\t * \r\n\t * @param RedBean_QueryWriter $writer \r\n\t */\r\n\tpublic function __construct(RedBean_QueryWriter $writer) {\r\n\t\tparent::__construct($writer);\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Loads a bean by type and id. If the bean cannot be found an\r\n\t * empty bean will be returned instead. This is a cached version\r\n\t * of the loader, if the bean has been cached it will be served\r\n\t * from cache, otherwise the bean will be retrieved from the database\r\n\t * as usual an a new cache entry will be added..\r\n\t * \r\n\t * @param string  $type type of bean you are looking for\r\n\t * @param integer $id   identifier of the bean\r\n\t * \r\n\t * @return RedBean_OODBBean $bean the bean object found\r\n\t */\r\n\tpublic function load($type,$id) {\r\n\t\tif (isset($this->cache[$type][$id])) {\r\n\t\t\t$this->hits ++;\r\n\t\t\t$bean = $this->cache[$type][$id];\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$this->misses ++;\r\n\t\t\t$bean = parent::load($type,$id);\r\n\t\t\tif (!isset($this->cache[$type])) $this->cache[$type]=array();\r\n\t\t\t$this->cache[$type][$id] = $bean;\r\n\t\t}\r\n\t\treturn $bean;\r\n\t}\r\n\r\n\t/**\r\n\t * Stores a RedBean OODBBean and caches it.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean the bean you want to store\r\n\t * \r\n\t * @return integer $id \r\n\t */\r\n\tpublic function store( $bean ) {\r\n\t\t$id = parent::store($bean);\r\n\t\t$type = $bean->getMeta('type');\r\n\t\tif (!isset($this->cache[$type])) $this->cache[$type]=array();\r\n\t\t$this->cache[$type][$id] = $bean;\r\n\t\treturn $id;\r\n\t}\r\n\r\n\t/**\r\n\t * Trashes a RedBean OODBBean and removes it from cache.\r\n\t * \r\n\t * @param RedBean_OODBBean $bean bean\r\n\t * @return mixed \r\n\t */\r\n\tpublic function trash( $bean ) {\r\n\t\t$type = $bean->getMeta('type');\r\n\t\t$id = $bean->id;\r\n\t\tif (isset($this->cache[$type][$id])) unset($this->cache[$type][$id]);\r\n\t\treturn parent::trash($bean);\r\n\t}\r\n\r\n\t/**\r\n\t * Flushes the cache for a given type.\r\n\t * \r\n\t * @param string $type\r\n\t * \r\n\t * @return RedBean_Plugin_Cache \r\n\t */\r\n\tpublic function flush($type) {\r\n\t\tif (isset($this->cache[$type])) $this->cache[$type]=array();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\t/**\r\n\t * Flushes the cache completely.\r\n\t * \r\n\t * @return RedBean_Plugin_Cache \r\n\t */\r\n\tpublic function flushAll() {\r\n\t\t$this->cache = array();\r\n\t\treturn $this;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the number of hits. If a call to load() or\r\n\t * batch() can use the cache this counts as a hit.\r\n\t * Otherwise it's a miss.\r\n\t * \r\n\t * @return integer \r\n\t */\r\n\tpublic function getHits() {\r\n\t\treturn $this->hits;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of hits. If a call to load() or\r\n\t * batch() can use the cache this counts as a hit.\r\n\t * Otherwise it's a miss.\r\n\t * \r\n\t * @return integer \r\n\t */\r\n\tpublic function getMisses() {\r\n\t\treturn $this->misses;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets hits counter to 0.\r\n\t */\r\n\tpublic function resetHits() {\r\n\t\t$this->hits = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets misses counter to 0.\r\n\t */\r\n\tpublic function resetMisses() {\r\n\t\t$this->misses = 0;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * RedBean Dependency Injector\r\n * \r\n * @file\t\t\tRedBean/DependencyInjector.php\r\n * @description\t\tA default dependency injector that can be subclassed to\r\n *\t\t\t\t\tsuit your needs.\r\n * \t\t\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\nclass RedBean_DependencyInjector {\r\n\r\n\t/**\r\n\t * List of dependencies.\r\n\t * @var array \r\n\t */\r\n\tprotected $dependencies = array();\r\n\r\n\t/**\r\n\t * Adds a dependency to the list.\r\n\t * You can add dependencies using this method. Pass both the key of the\r\n\t * dependency and the dependency itself. The key of the dependency is a \r\n\t * name that should match the setter. For instance if you have a dependency\r\n\t * class called My_Mailer and a setter on the model called setMailSystem\r\n\t * you should pass an instance of My_Mailer with key MailSystem.\r\n\t * The injector will now look for a setter called setMailSystem.\r\n\t * \r\n\t * @param string $dependencyID name of the dependency (should match setter)\r\n\t * @param mixed  $dependency   the service to be injected\r\n\t */\r\n\tpublic function addDependency($dependencyID,$dependency) {\r\n\t\t$this->dependencies[$dependencyID] = $dependency;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of the class $modelClassName completely\r\n\t * configured as far as possible with all the available\r\n\t * service objects in the dependency list.\r\n\t * \r\n\t * @param string $modelClassName the name of the class of the model\r\n\t * \r\n\t * @return mixed $object the model/object\r\n\t */\r\n\tpublic function getInstance($modelClassName) {\r\n\t\t$object = new $modelClassName;\r\n\t\tif ($this->dependencies && is_array($this->dependencies)) {\r\n\t\t\tforeach($this->dependencies as $key=>$dep) {\r\n\t\t\t\t$depSetter = 'set'.$key;\r\n\t\t\t\tif (method_exists($object,$depSetter)) {\r\n\t\t\t\t\t$object->$depSetter($dep);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $object;\r\n\t}\r\n}\r\n\r\n/**\r\n * RedBean Duplication Manager\r\n * \r\n * @file\t\t\tRedBean/DuplicationManager.php\r\n * @description\t\tCreates deep copies of beans\r\n * \t\t\r\n * @author\t\t\tGabor de Mooij and the RedBeanPHP Community\r\n * @license\t\t\tBSD/GPLv2\r\n *\r\n * copyright (c) G.J.G.T. (Gabor) de Mooij and the RedBeanPHP Community\r\n * This source file is subject to the BSD/GPLv2 License that is bundled\r\n * with this source code in the file license.txt.\r\n *\r\n */\r\nclass RedBean_DuplicationManager {\r\n\r\n\r\n\t/**\r\n\t * The Dup Manager requires a toolbox\r\n\t * @var RedBean_Toolbox \r\n\t */\r\n\tprotected $toolbox;\r\n\r\n\t/**\r\n\t * Association Manager \r\n\t * @var RedBean_AssociationManager\r\n\t */\r\n\tprotected $associationManager;\r\n\r\n\t/**\r\n\t * RedBeanPHP OODB instance\r\n\t * @var RedBean_OODBBean \r\n\t */\r\n\tprotected $redbean;\r\n\r\n\tprotected $tables = array();\r\n\tprotected $columns = array();\r\n\tprotected $filters = array();\r\n\tprotected $cacheTables = false;\r\n\t/**\r\n\t * Constructor,\r\n\t * creates a new instance of DupManager.\r\n\t * @param RedBean_Toolbox $toolbox \r\n\t */\r\n\tpublic function __construct( RedBean_Toolbox $toolbox ) {\r\n\t\t$this->toolbox = $toolbox;\r\n\t\t$this->redbean = $toolbox->getRedBean();\r\n\t\t$this->associationManager = $this->redbean->getAssociationManager();\r\n\t}\r\n\r\n\t/**\r\n\t * For better performance you can pass the tables in an array to this method.\r\n\t * If the tables are available the duplication manager will not query them so\r\n\t * this might be beneficial for performance.\r\n\t * \r\n\t * @param array $tables \r\n\t */\r\n\tpublic function setTables($tables) {\r\n\t\tforeach($tables as $key=>$value) {\r\n\t\t\tif (is_numeric($key)) {\r\n\t\t\t\t$this->tables[] = $value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$this->tables[] = $key;\r\n\t\t\t\t$this->columns[$key] = $value;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->cacheTables = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a schema array for cache.\r\n\t * \r\n\t * @return array \r\n\t */\r\n\tpublic function getSchema() {\r\n\t\treturn $this->columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether you want the duplication manager to cache the database schema.\r\n\t * If this flag is set to TRUE the duplication manager will query the database schema\r\n\t * only once. Otherwise the duplicationmanager will, by default, query the schema\r\n\t * every time a duplication action is performed (dup()).\r\n\t * \r\n\t * @param boolean $yesNo \r\n\t */\r\n\tpublic function setCacheTables($yesNo) {\r\n\t\t$this->cacheTables = $yesNo;\r\n\t}\r\n\r\n\t/**\r\n\t * A filter array is an array with table names.\r\n\t * By setting a table filter you can make the duplication manager only take into account\r\n\t * certain bean types. Other bean types will be ignored when exporting or making a\r\n\t * deep copy. If no filters are set all types will be taking into account, this is\r\n\t * the default behavior.\r\n\t * \r\n\t * @param array $filters \r\n\t */\r\n\tpublic function setFilters($filters) {\r\n\t\t$this->filters = $filters;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether the bean has an own list based on\r\n\t * schema inspection from realtime schema or cache.\r\n\t * \r\n\t * @param string $type   bean type\r\n\t * @param string $target type of list you want to detect\r\n\t * \r\n\t * @return boolean \r\n\t */\r\n\tprotected function hasOwnList($type,$target) {\r\n\t\treturn (isset($this->columns[$target][$type.'_id']));\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether the bea has a shared list based on\r\n\t * schema inspection from realtime schema or cache.\r\n\t * \r\n\t * @param string $type   bean type\r\n\t * @param string $target type of list you are looking for\r\n\t * \r\n\t * @return boolean \r\n\t */\r\n\tprotected function hasSharedList($type,$target) {\r\n\t\t$linkType = array($type,$target);\r\n\t\tsort($linkType);\r\n\t\t$linkType = implode('_',$linkType);\r\n\t\treturn (in_array($linkType,$this->tables));\r\n\t}\r\n\r\n\t/**\r\n\t * Makes a copy of a bean. This method makes a deep copy\r\n\t * of the bean.The copy will have the following features.\r\n\t * - All beans in own-lists will be duplicated as well\r\n\t * - All references to shared beans will be copied but not the shared beans themselves\r\n\t * - All references to parent objects (_id fields) will be copied but not the parents themselves\r\n\t * In most cases this is the desired scenario for copying beans.\r\n\t * This function uses a trail-array to prevent infinite recursion, if a recursive bean is found\r\n\t * (i.e. one that already has been processed) the ID of the bean will be returned.\r\n\t * This should not happen though.\r\n\t *\r\n\t * Note:\r\n\t * This function does a reflectional database query so it may be slow.\r\n\t *\r\n\t * Note:\r\n\t * this function actually passes the arguments to a protected function called\r\n\t * duplicate() that does all the work. This method takes care of creating a clone\r\n\t * of the bean to avoid the bean getting tainted (triggering saving when storing it).\r\n\t * \r\n\t * @param RedBean_OODBBean $bean  bean to be copied\r\n\t * @param array            $trail for internal usage, pass array()\r\n\t * @param boolean          $pid   for internal usage\r\n\t *\r\n\t * @return array $copiedBean the duplicated bean\r\n\t */\r\n\tpublic function dup($bean,$trail=array(),$pid=false) {\r\n\t\tif (!count($this->tables))  $this->tables = $this->toolbox->getWriter()->getTables();\r\n\t\tif (!count($this->columns)) foreach($this->tables as $table) $this->columns[$table] = $this->toolbox->getWriter()->getColumns($table);\r\n\t\t$beanCopy = clone($bean);\r\n\t\t$rs = $this->duplicate($beanCopy,$trail,$pid);\r\n\t\tif (!$this->cacheTables) {\r\n\t\t\t$this->tables = array();\r\n\t\t\t$this->columns = array();\r\n\t\t}\r\n\t\treturn $rs;\r\n\t}\r\n\r\n\t/**\r\n\t * Makes a copy of a bean. This method makes a deep copy\r\n\t * of the bean.The copy will have the following features.\r\n\t * - All beans in own-lists will be duplicated as well\r\n\t * - All references to shared beans will be copied but not the shared beans themselves\r\n\t * - All references to parent objects (_id fields) will be copied but not the parents themselves\r\n\t * In most cases this is the desired scenario for copying beans.\r\n\t * This function uses a trail-array to prevent infinite recursion, if a recursive bean is found\r\n\t * (i.e. one that already has been processed) the ID of the bean will be returned.\r\n\t * This should not happen though.\r\n\t *\r\n\t * Note:\r\n\t * This function does a reflectional database query so it may be slow.\r\n\t *\r\n\t * @param RedBean_OODBBean $bean  bean to be copied\r\n\t * @param array            $trail for internal usage, pass array()\r\n\t * @param boolean          $pid   for internal usage\r\n\t *\r\n\t * @return array $copiedBean the duplicated bean\r\n\t */\r\n\tprotected function duplicate($bean,$trail=array(),$pid=false) {\r\n\r\n\t$type = $bean->getMeta('type');\r\n\t\t$key = $type.$bean->getID();\r\n\t\tif (isset($trail[$key])) return $bean;\r\n\t\t$trail[$key]=$bean;\r\n\t\t$copy =$this->redbean->dispense($type);\r\n\t\t$copy->import( $bean->getProperties() );\r\n\t\t$copy->id = 0;\r\n\t\t$tables = $this->tables;\r\n\t\tforeach($tables as $table) {\r\n\t\t\tif (count($this->filters) && !in_array($table,$this->filters)) continue;\r\n\t\t\tif (strpos($table,'_')!==false || $table==$type) continue;\r\n\t\t\t$owned = 'own'.ucfirst($table);\r\n\t\t\t$shared = 'shared'.ucfirst($table);\r\n\t\t\tif ($this->hasOwnList($type,$table)) {\r\n\t\t\t\tif ($beans = $bean->$owned) {\r\n\t\t\t\t\t$copy->$owned = array();\r\n\t\t\t\t\tforeach($beans as $subBean) {\r\n\t\t\t\t\t\tarray_push($copy->$owned,$this->duplicate($subBean,$trail,$pid));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$copy->setMeta('sys.shadow.'.$owned,null);\r\n\t\t\t}\r\n\t\t\tif ($this->hasSharedList($type, $table)) {\r\n\t\t\t\tif ($beans = $bean->$shared) {\r\n\t\t\t\t\t$copy->$shared = array();\r\n\t\t\t\t\tforeach($beans as $subBean) {\r\n\t\t\t\t\t\tarray_push($copy->$shared,$subBean);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t$copy->setMeta('sys.shadow.'.$shared,null);\r\n\r\n\t\t}\r\n\t\tif ($pid) $copy->id = $bean->id;\r\n\t\treturn $copy;\r\n\t}\r\n}\r\n\r\nclass R extends RedBean_Facade{\r\n  \t\t\t\t\t   public static function syncSchema($from,$to) { return RedBean_Plugin_Sync::syncSchema($from,$to); }\r\n\t\t\tpublic static function log($filename) { $tl = new RedBean_Plugin_TimeLine($filename); self::$adapter->addEventListener('sql_exec',$tl);}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":284348}]],"length":284348,"saved":false}
